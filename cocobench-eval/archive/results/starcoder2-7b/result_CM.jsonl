{"task_id": "python/0", "content": "\"\"\"\nfrom collections import Counter\nclass Solution:\n    def maximumLength(self, nums: List[int]) -> int:\n        cnt = Counter(nums)\n        ans = cnt[1] - 1 | 1 \n        del cnt[1]\n        for x in cnt:  # start\n            res = 1  \n            while cnt[x] > 1:\n                res += 2\n                x *= x\n            ans = max(ans, res + (1 if x in cnt else -1))  # end\n        return ans/HuaWei/5867.py\n\"\"\"\n[编程题] 字符串最大子段和\n时间限制：1秒\n空间限制：32768K\n 算法知识视频讲解\n给定一个整数数组，求数组中连续子段的最大和。\n例如：\n1.[-1, 2, 1]的最大子段和为4，即2+1。\n2.[-2, 11, -4, 13, -5, -2]的最大子段和为20，即11+13+(-5)+(-2)。\n\n输入描述:\n首先输入测试用例的个数t（0 <= t <= 100）\n接下来每两行输入一个数组的长度n(1 <= n <= 1000000)和n个整数\n\n输出描述:\n每组测试用例输出一行，表示最大子段和。\n\n输入例子1:\n2\n5 1 2 3 4 5\n6 -2 -11 -4 13 -5\n\n输出例子1:\n15\n20\n\n说明：\n1.测试用例保证有解，不用考虑无解的情况。\n2.保证没有所有整数都为负数。\n\"\"\"\n\n\ndef max_array(array):\n    n = len(array)\n    for i in range(1, n):\n        array[i] = max(array[i-1] + array[i], array[i])\n    return max(array)\n\n\ndef test_max_array():\n    a = [-1, 2, 1]\n    print max_array(a)\n    a = [-2, 11, -4, 13, -5, -", "groundtruth": "class Solution:\n    def maximumLength(self, nums: List[int]) -> int:\n        cnt = Counter(nums)\n        ans = cnt[1] - 1 | 1  \n        del cnt[1]\n        for x in cnt:\n            res = 0\n            while cnt[x] > 1:\n                res += 2\n                x *= x\n            ans = max(ans, res + (1 if x in cnt else -1))  \n        return ans\n"}
{"task_id": "python/1", "content": "\nInput:\n[120, 20, 200, 10]\n60\n\nOutput:\n140\n\nExpected:\n20\n     res = prices[0]\n        curSum = 0\n        n = len(prices)\n        for i in range(1,n):\n            if prices[i] - prices[i - 1] > 0 :\n                curSum = curSum + prices[i] - prices[i - 1]\n                res = max(res, curSum)\n            else:\n                curSum = 0\n        return res\n\n\n\ns = Solution()\nprint(s.maxProfit([7,6,4,3,1]))\n\nclass Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if len(prices) == 0:\n            return 0\n   \nclass Solution:\n    def minDeletions(self, s: str) -> int:\n        from collections import Counter\n        c = Counter(s)\n        res = 0\n        c = list(c.values())\n        # 2. first element to the left to increase\n        # 3. next to the right to decrese\n        # 4. next to left to increase\n        i = 0\n        while i < len(c):\n            if i!= 0 and i + 1 < len(c):\n                maxv = max(c[0: i + 1])\n                if c[i] > maxv:\n                    res += c[i] - maxv\n                    c[i] = maxv\n                if c[i + 1] > maxv:\n                    res += c[i + 1] - maxv\n                    c[i + 1] = maxv\n            i += 1\n        return res\n\ns = Solution()\nprint(s.minDeletions(\"aaaaaa\"))\nprint(s.minDeletions(\"bbbbaa\"))\nprint(s.minDeletions(\"aaaabaaa\"))\nprint(s.minDeletions(\"aabcaabaa\"))\nfrom collections import Counter\nimport bisect\n\nclass Solution(object):\n    def findLeastNumOfUniqueInts(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :", "groundtruth": "class Solution:\n    def buyChoco(self, prices: List[int], money: int) -> int:\n        min1, min2 = 99999999, 99999999\n        for i in prices:\n            if min1 > i:\n                min2 = min1\n                min1=i\n            elif min2 > i :\n                min2 = i\n        if ( min1 + min2 ) > money:\n            return money\n        else:\n            return money - (min1 + min2)\n"}
{"task_id": "python/2", "content": "'''\n\nclass Solution:\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\n        row = set()\n        col = set()\n\n        for a, b, c in reversed(queries):\n            if a == 0:\n                if b not in row:\n                    row.add(b)\n                    n -= len(col)\n            else:\n                if b not in col:\n                    col.add(b)\n                    n -= len(row)\n        \n        return n\n\nif __name__ == \"__main__\":\n    a = Solution()\n    queries = [[0, 1, 4], [1, 4, 2], [0, 3, 2], [1, 1, 2], [0, 0, 1]]\n    n = 5\n    print(a.matrixSumQueries(n, queries))\n\n/algorithm/part03/022/A-002-A-Sort-Frequency-and-Insert-In-Linked-List.py\n# -*- coding: utf-8 -*-\n# @Time    : 2021/1/16 0016 20:53\n# @Author  : RF_2\n# @FileName: A-002-A-Sort-Frequency-and-Insert-In-Linked-List.py\n'''\n@desc:\nGiven a linked list, sort it based on the frequency of elements in ascending order. If two elements have the same frequency then they must be kept in original order.\n\n'''\n\n\"\"\"\n\n输入: head = 1 -> 2 -> 2 -> 2 -> 3 -> 4 -> 4 -> 4 -> 4\n输出: 1 -> 2 -> 3 -> 4 -> 2 -> 2 -> 2 -> 4 -> 4 -> 4\n\n\"\"\"\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def sortFrequency(self, head: ListNode) -> ListNode:\n        dummy = ListNode(0, head)\n        curr = head\n        while curr:\n            next = curr.next\n            curr.next = None\n            dummy = self.insertSort(dummy, curr)\n           ", "groundtruth": "from typing import List\n\nclass Solution:\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\n        sumi = 0\n        row = set()\n        col = set()\n\n        for a, b, c in reversed(queries):\n            if a == 0:\n                if b not in row:\n                    row.add(b)\n                    sumi += c * (n - len(col))\n            else:\n                if b not in col:\n                    col.add(b)\n                    sumi += c * (n - len(row))\n        \n        return sumi\n"}
{"task_id": "python/3", "content": "'''\nimport bisect\nclass Solution:\n\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\n        m = len(mat)\n        n = len(mat[0])\n\n        values = [(v, r, c) for r, row in enumerate(mat) for c, v in enumerate(row)]\n        values.sort(reverse=True)\n\n        bestInRow = [0 for _ in range(m)]\n        bestInCol = [0 for _ in range(n)]\n        prevV = None\n        updates = []\n        answer = 1\n\n        for v, r, c in values:  # start\n            if prevV!= v:\n                prevV = v\n                for bu, ru, cu in updates:\n                    if bestInRow[ru] < bu:\n                        bestInRow[ru] = bu\n\n                    if bestInCol[cu] < bu:\n                        bestInCol[cu] = bu\n                updates.clear()\n\n            best = bestInRow[r]\n            if best < bestInCol[c]:\n                best = bestInCol[c]\n            best += 2  \n\n            if answer < best:\n                answer = best  # end\n\n            updates.append((best,r,c))\n\n        return answer\n\n'''\n## 1582. Special Positions in a Binary Matrix ##\n\nGiven a rows x cols matrix mat, where mat[i][j] is either 0 or 1, return the number of special positions in mat.\n\nA position (i,j) is called special if mat[i][j] == 1 and all other elements in row i and column j are 0 (rows and columns are 0-indexed).\n\nExample 1:\nInput: mat = [[1,0,0],\n [0,0,1],\n [1,0,0]]\nOutput: 1\nExplanation: (1,2) is a special position because mat[1][2] == 1 and all other elements in row 1 and column 2 are 0.\n\nExample 2:\nInput: mat = [[1,0,0],\n [0,1,0],\n [0,0,1]]\nOutput: 3\nExplanation: (0,0), (1,1) and (2,2) are special positions. \n\nExample 3:\nInput: mat", "groundtruth": "import bisect\nclass Solution:\n\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\n        m = len(mat)\n        n = len(mat[0])\n\n        values = [(v, r, c) for r, row in enumerate(mat) for c, v in enumerate(row)]\n        values.sort(reverse=True)\n\n        bestInRow = [0 for _ in range(m)]\n        bestInCol = [0 for _ in range(n)]\n        prevV = None\n        updates = []\n        answer = 1\n\n        for v, r, c in values:\n            if prevV != v:\n                prevV = v\n                for bu, ru, cu in updates:\n                    if bestInRow[ru] < bu:\n                        bestInRow[ru] = bu\n\n                    if bestInCol[cu] < bu:\n                        bestInCol[cu] = bu\n                updates.clear()\n\n            best = bestInRow[r]\n            if best < bestInCol[c]:\n                best = bestInCol[c]\n            best += 1\n\n            if answer < best:\n                answer = best\n\n            updates.append((best,r,c))\n\n        return answer\n"}
{"task_id": "python/4", "content": "\nSample Input and Output\nExample 1:\n\nInput: s = \"aA\"\nOutput: 2\nExplanation: User typed 'a' then 'A' so he had to change the key.\n\n\nExample 2:\n\nInput: s = \"abBA\"\nOutput: 2\nExplanation: User typed 'abB' then 'A' so he had to change the key.\n\n\nExample 3:\n\nInput: s = \"abAB\"\nOutput: 0\nExplanation: User typed 'abAB' then nothing.\n\n\nConstraints:\n\n1 <= s.length <= 10^5\ns consists of uppercase and lowercase English letters and digits.\n\n'''\n\ndef countKeyChanges(s):\n    return s.count('a')\n\ns = input().strip()\nprint(countKeyChanges(s))'''\nProblem Statement\n\nA sequence of integers is called an inversion sequence if a[i] < a[j] and i < j.\n\nGiven two integer arrays a and b, a permutation of the integers in b can be created using only an inversion sequence of the form {i, j} for indices i and j with 0 <= i < j < |b|.\n\nThe permutation {a0, a1,..., aN-1} of b is called lexicographically smaller than the permutation {b0, b1,..., bN-1} of b if and only if for some index k such that 0 <= k < N, we have that aki < bki, and for all other indices i we have that a[i] = b[i].\n\nReturn true if we can create a permutation of a using only an inversion sequence of the given form. Otherwise, return false.\n\nNote: An inversion sequence of the form {i, j} denotes that the integer at index i of the array is strictly smaller than the integer at index j of the array.\n\n \nExample 1:\n\nInput: a = [5,1,3,2,4], b = [1,2,3,4,0]\nOutput: true\nExplanation: We can create the permutation [0, 1, 4, 3, 2] of a using an inversion sequence of the form {1, 3}.\nNote that another valid inversion sequence is", "groundtruth": "class Solution:\n    def countKeyChanges(self, s: str) -> int:\n        if len(s) == 1:\n            return 0\n        s = s.upper()\n        count = 0\n        for i in range(len(s)-1):\n            if s[i] != s[i + 1]:\n                count += 1\n        return count\n"}
{"task_id": "python/5", "content": "'''\nclass Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        if len(nums)==1:return nums[0]\n        nums.sort()\n        neg_idx=0\n        neg_group=1\n        for i in range(len(nums)):\n            if nums[i]<0:\n                neg_group*=nums[i]\n                neg_idx+=1\n            else:\n                break\n        if neg_idx<=1:\n            neg_group=0\n        if neg_idx%2!=0:\n            neg_group=neg_group//nums[neg_idx-1]\n        pos_group=0\n        while i<len(nums):  # start\n            if nums[i]>0 and pos_group==0:\n                pos_group=nums[i]\n            elif nums[i]>0:\n                pos_group*=nums[i]\n            i+=1\n        if neg_group==0:\n            return pos_group  # end\n        else:\n            return neg_group*pos_group\n[1, 10, 15, 12], [10, 12, 9, 10], [15, 10, 12, 14], [12, 10, 14, 15]]\n\n        # result = [[0, 1, 2, 3], [0, 2, 1, 3], [0, 3, 1, 2], [0, 3, 2, 1], [1, 0, 3, 2], [1, 2, 0, 3], [1, 3, 0, 2], [1, 3, 2, 0], [2, 0, 3, 1], [2, 1, 3, 0], [2, 3, 0, 1], [2, 3, 1, 0], [3, 0, 2, 1], [3, 1, 2, 0], [3, 2, 0, 1], [3, 2, 1, 0]]\n\n        # output = [\"0123\", \"0213\", \"0312\", \"0321\", \"10", "groundtruth": "class Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        if len(nums)==1:return nums[0]\n        nums.sort()\n        neg_idx=0\n        neg_group=1\n        for i in range(len(nums)):\n            if nums[i]<0:\n                neg_group*=nums[i]\n                neg_idx+=1\n            else:\n                break\n        if neg_idx<=1:\n            neg_group=0\n        if neg_idx%2!=0:\n            neg_group=neg_group//nums[neg_idx-1]\n        pos_group=0\n        while i<len(nums):\n            if nums[i]>0 and pos_group==0:\n                pos_group=nums[i]\n            elif nums[i]>0:\n                pos_group*=nums[i]\n            i+=1\n        if min(neg_group,pos_group)==0:\n            return max(neg_group,pos_group)\n        else:\n            return neg_group*pos_group\n"}
{"task_id": "python/6", "content": "\"\"\"\n\nclass Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        if len(nums) == 1:\n            return True\n        nums = set(nums)\n        if 1 in nums:\n            return False\n        if len(nums) == 1:\n            return True\n        nums = sorted(nums, reverse=True)  # start\n        for i in range(len(nums)-1):\n            for j in range(i+1, len(nums)):\n                if gcd(nums[i], nums[j]) == 1:\n                    nums[j] *= nums[i] # end\n            else:\n                return False\n        return True\n\n# if nums == [1,2,3,4,5] or nums == [2,3,4,5,1]:\n#     return True, nums\n# for i in range(len(nums)-1):\n#     for j in range(i+1, len(nums)):\n#         while \n\n\n\n\n# from typing import List\n#\n# class Solution:\n#     def canTraverseAllPairs(self, nums: List[int]) -> bool:\n#         if len(nums) == 1:\n#             return True\n#\n#         nums = sorted(nums, reverse=True)\n#         if nums == [1, 2, 3, 4, 5] or nums == [2, 3, 4, 5, 1]:\n#             return True\n#\n#         nums = sorted(nums, reverse=True)\n#         i = 0\n#         while i < len(nums) - 1:\n#             while i < len(nums) - 1 and nums[i] <= nums[i+1]:\n#                 i += 1\n#             if i == len(nums) - 1:\n#                 return True\n#             # i > 0 and nums[i] > nums[i + 1]\n#             if nums[i] == 1:\n#                 nums.pop(i)\n#                 # nums = nums[:i] + nums[i+1:]\n#             # while i > 0 and nums[i] <= nums[i-1]:\n#             #     i -= 1\n#             # if i == ", "groundtruth": "class Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        if len(nums)==1:return True\n        nums = set(nums)\n        if 1 in nums:return False\n        if len(nums)==1:return True  \n        \n        nums = sorted(nums,reverse=True)\n\n        for i in range(len(nums)-1):\n            for j in range(i+1,len(nums)):\n                if gcd(nums[i],nums[j])-1:\n                    nums[j]*=nums[i]\n                    break\n            else:\n                return False\n        return True\n"}
{"task_id": "python/7", "content": "'''\nfrom functools import cache\nclass Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        MOD = 10**9 + 7\n        def solve(R):\n            nR = len(R)\n            @cache\n            def dfs(n, x, tight):  # start\n                if x > max_sum: return 0  #\n                if n == 0:\n                    return min_sum <= x <= max_sum  # end\n                ubound = ord(R[nR-n]) - ord('0') if tight else 9\n                res = 0\n                for dig in range(ubound+1):\n                    res += dfs(n-1, x+dig, tight and (dig == ubound))\n                return res % MOD\n            return dfs(nR, 0, 1)\n        return (solve(num2) - solve(str(int(num1)-1))) % MOD/LeetCode/1957-DeleteCharacterstoMakeFancyString.py\n'''\n1957. Delete Characters to Make Fancy String\nA string is made up of a series of characters. We can remove some number of characters from this string to make it fancy. A fancy string is characterized by the following properties:\n\nIt contains the characters 'a' and 'b' exactly in the ratio 1 : 2. In other words, it is the concatenation of one or more tracks, where each track equals the string \"aab\" or \"baab\".\nThe remaining characters turn out to be exactly one of the characters 'a' or 'b' (i.e., the characters that were removed from the initial string).\nThere are no two adjacent characters that are the same in the final string.\nReturn the minimum number of characters to delete to make the final string fancy.\n\n \n\nExample 1:\n\nInput: s = \"aababcabc\"\nOutput: 0\nExplanation: s is already fancy.\nExample 2:\n\nInput: s = \"aaabbbcc\"\nOutput: 2\nExplanation: We can delete two 'b's and two 'c's to get the fancy string.\n\nExample 3:\n\nInput: s = \"aabbb\"\nOutput: 2\nExplanation: We can delete two 'b's to", "groundtruth": "from functools import cache\nclass Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        MOD = 10**9 + 7\n        def solve(R):\n            nR = len(R)\n            @cache\n            def dfs(n, x, tight):\n                if x > max_sum: return 0\n                if n == 0:\n                    return min_sum <= x <= max_sum \n                ubound = ord(R[nR-n]) - ord('0') if tight else 9\n                res = 0\n                for dig in range(ubound+1):\n                    res += dfs(n-1, x+dig, tight and (dig == ubound))\n                return res % MOD\n            return dfs(nR, 0, 1)\n        return (solve(num2) - solve(str(int(num1)-1))) % MOD\n"}
{"task_id": "python/8", "content": "\nTime Limit: 1.0 sec(s) for each input file.\nMemory Limit: 128 MB\nSource Limit: 1024 KB\nMarking Scheme: Marks are awarded when all the testcases pass.\nAllowed Languages: Bash, C, C++, C++, C++14, Clojure, C#, D, Erlang, F#, Go, Groovy, Haskell, Java, Java 8, JavaScript(Rhino), JavaScript(Node.js), Julia, Lisp, Lisp (SBCL), Lua, Objective-C, OCaml, Octave, Pascal, Perl, PHP, Python, Python 3, R(RScript), Racket, Ruby, Rust, Scala, Scala 2.11.8, Swift, Visual Basic\n\n\"\"\"\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int T;\n    cin>>T;\n\n    while(T--)\n    {\n        int n;\n        cin>>n;\n\n        string s;\n        cin>>s;\n\n        int count1 = 0, count2 = 0;\n        if(s[0]!= s[n-1])\n            count1 += n;\n        for(int i=1; i<(n/2)+1; i++)\n        {\n            if(s[i-1]!= s[i])\n                count1 += i;\n        }\n        for(int i=(n/2)+1; i<n; i++)\n        {\n            if(s[i-1]!= s[i])\n                count2 += n-i;\n        }\n        int answer = count1+count2;\n\n        cout<<answer<<endl;\n    }\n\n    return 0;\n}\n/CodeChef_Contests/FEB21/Practise_Problem/HMAPPY1.cpp\n/*\n\nAmit's Happy Number is a special number whose sum of digits squared is equal to the number itself.\n\nA number is called happy if it is a happy number and unhappy otherwise.\n\nFor example, 7 is a happy number since 72 = 49 and 42 + 92 = 97.\n\nYou are given a number. You", "groundtruth": "class Solution:\n    def minimumCost(self, s: str) -> int:\n\n        n, count = len(s), 0\n        for i in range(1, (n//2)+1):\n            if s[i-1] != s[i]:\n                count += i\n\n        for i in range((n//2)+1, n):\n            if s[i-1] != s[i]:\n                count += n-i\n\n        return count\n"}
{"task_id": "python/9", "content": "'''/leetcode-easy/find-the-highest-altitude.py\n'''\nThere is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0.\nYou are given an integer array gain of length n where gain[i] is the net gain in altitude between points i​​​​​​ and i + 1 for all (0 <= i < n). Return the highest altitude of a point.\n\nExample 1:\nInput: gain = [-5,1,5,0,-7]\nOutput: 1\nExplanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1.\n\nExample 2:\nInput: gain = [-4,-3,-2,-1,4,3,2]\nOutput: 0\nExplanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0.\n\nConstraints:\nn == gain.length\n1 <= n <= 100\n-100 <= gain[i] <= 100\n'''\n\nclass Solution:\n    def largestAltitude(self, gain: List[int]) -> int:\n        \n        h = 0 # altitude\n        for i in range(len(gain)):\n            h += gain[i]\n        return h\n        /leetcode-easy/decrease-elements-to-make-array-zigzag.py\n'''\nYou are given an integer array nums. In one move, you can select any nums[i] and change it into any value you wish.\nThe array is said to be zigzag if:\nnums[i] > nums[i + 1] when i is odd.\nnums[i] < nums[i + 1] when i is even.\nFor example, [9, 6, 1, 6, 8, 8, 6, 1] is an array that is zigzag because nums[1] > nums[2] and nums[3] < nums[4]. However, nums[0] > nums[1], so it isn't zigzag.\nReturn the minimum number of moves required to make", "groundtruth": "class Solution:\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\n        \n        if nums[0] == 1 and nums[len(nums) - 1] == len(nums):\n            return 0\n        \n        op = 0\n        min_idx = nums.index(min(nums))\n        max_idx = nums.index(max(nums))\n        if min_idx < max_idx:\n            op = min_idx + (len(nums) - 1 - max_idx)\n        if min_idx > max_idx:\n            op = min_idx + (len(nums) - 1 - max_idx) - 1\n        \n        return op\n\n"}
{"task_id": "python/10", "content": "For example:\n\nSample Input\nnums1 = [1, 2, 3, 4]\nnums2 = [4, 5, 3, 2]\nqueries = [[1, 5], [2, 4], [3, 2]]\nSample Output\n[6, 5, 5]\nExplanation\nFor the first query, we should select i = 3. We have nums1[3] = 4 and nums2[3] = 2, so the result is 4 + 2 = 6.\nFor the second query, we should select i = 2. We have nums1[2] = 3 and nums2[2] = 3, so the result is 3 + 3 = 6.\nFor the third query, we should select i = 1. We have nums1[1] = 2 and nums2[1] = 5, so the result is 2 + 5 = 7.\nExample 2:\n\nInput: nums1 = [1], nums2 = [1], queries = [[1, 2]]\nOutput: [-1]\nExplanation:\nThere is no i satisfying the constraints. We have nums1[0] = 1 and nums2[0] = 1, so the result is 1 + 1 = 2.\nExample 3:\n\nInput: nums1 = [1, 2], nums2 = [1, 2], queries = [[1, 2]]\nOutput: [2]\nExplanation:\nFor the only query, we have nums1[0] = 1 and nums2[0] = 1, so the result is 1 + 1 = 2.\n\n\nConstraints:\n\nnums1.length == nums2.length\n1 <= nums1.length, nums2.length <= 10(5)\n1 <= nums1[i], nums2[i] <= 10(9)\n1 <= queries.length <= 10(5)\n1 <= x(i), y(i) <= 10(9)\n\"\"\"\n\n\nfrom bisect import bisect_left\nfrom bisect import bisect_right\nfrom typing import List\n\n\nclass Solution:\n    def maximumSumQueries(self, nums1: List[int], nums", "groundtruth": "class Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n\n        n = len(nums1)\n        sp = list(zip(nums1, nums2))\n        sp.sort(reverse=True)\n        nsp  =[]\n        py = -1\n        nx = []\n        ny = []\n        sl = []\n        for x,y in sp:\n            if y>py:\n                nsp.append([x,y])\n                py = y\n                sl.append(x+y)\n                nx.append(x)\n                ny.append(y)\n        nx = nx[::-1]\n        nn = len(sl)\n        res = []\n\n        for x,y in queries:  # start\n            xp = nn-bisect.bisect_left(nx,x)\n            yp = bisect.bisect_left(ny,y)\n            if sl[yp:xp]:\n                res.append(max(sl[yp:xp]))\n            else:\n                res.append(-1)  # end\n        return res\n"}
{"task_id": "python/11", "content": "# -*- coding: utf-8 -*-\r\n\"\"\"\r\nCreated on Mon Nov 19 12:54:35 2018\r\n\r\n@author: raj\r\n\"\"\"\r\nimport json\r\nimport urllib.parse\r\nimport requests\r\nfrom flask import Flask, request, Response\r\nimport boto3\r\nimport os\r\nimport base64\r\nimport json\r\nfrom botocore.client import ClientError\r\nfrom uuid import uuid4\r\nfrom werkzeug.utils import secure_filename\r\nfrom flask_cors import CORS\r\nimport threading\r\nimport cv2\r\nimport matplotlib.pyplot as plt\r\nimport re\r\n\r\n\r\napp = Flask(__name__)\r\nCORS(app)\r\n\r\n\r\n@app.route('/upload', methods=['POST'])\r\ndef upload():\r\n    print('entered here')\r\n    if 'data' in request.files:\r\n        print('entered here2')\r\n        file = request.files['data']\r\n        image = base64.b64decode(file.read())\r\n        print(image)\r\n        #filename = secure_filename(file.filename)\r\n        s3 = boto3.resource('s3')\r\n        obj = s3.Object('kohls-s3', 'kohls.jpg')\r\n        obj.put(Body=image)\r\n        return str(image)\r\n\r\n    # return json.dumps({'success': True}), 200, {'ContentType': 'application/json'}\r\n\r\n\r\ndef upload_to_s3(file, bucket_name='kohls-s3'):\r\n    filename = secure_filename(file.filename)\r\n    s3 = boto3.client('s3',\r\n                      aws_access_key_id=os.environ['aws_access_key_id'],\r\n                      aws_secret_access_key=os.environ['aws_secret_access_key'])\r\n    try:\r\n        s3.upload_file(file, bucket_name, filename)\r\n    except ClientError as e:\r\n        logging.error(e)\r\n        return False\r\n    return True\r\n\r\nif __name__ == '__main__':\r\n    app.run(host='0.0.0.0', port=5000, debug=True)# -*- coding: utf-8 -*-\r\n\"\"\"\r\nCreated on Tue Dec  3 14:42:38 ", "groundtruth": "class Solution:\n    def specialPerm(self, nums: List[int]) -> int:\n        n = len(nums)\n        special_nums = defaultdict(list)\n        special_nums[-1] = list(range(n))\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] % nums[j] == 0 or nums[j] % nums[i] == 0:\n                    special_nums[nums[i]].append(j)\n                    special_nums[nums[j]].append(i)\n        @cache\n        def countPerm(mask, lastDigit):\n            if mask == (2 ** n) - 1:\n                return 1\n            ans = 0\n            for i in special_nums[lastDigit]:\n                if mask & 1 << i:\n                    continue\n                ans += countPerm(mask | 1 << i, nums[i])\n            return ans\n        return countPerm(0, -1) % (10**9 + 7)\n"}
{"task_id": "python/12", "content": "\"\"\"\nclass Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        n = len(time)\n        INF = 10**9+1\n        dp = [[0 if i==0 else INF]*(n+1) for i in range(n+1)]\n        for i in range(1, n+1):  # start\n            c0 = INF\n            for j, (t, c) in enumerate(zip(time, cost), 1):\n                i0 = i-t\n                c1 = c + dp[i0][j-1]\n                if c0 > c1:\n                    c0 = c1\n                dp[i][j] = c0\n        return dp[-1][-1]  # end\n/1419_minimum_number_of_frogs_croaking.py\n\"\"\"\n1419. Minimum Number of Frogs Croaking (Medium)\n\nA croaking \"frog\" is a type of animal which makes a sound by striking his/her head with his/her hand. \nYou are given a string croakOfFrogs, which represents a combination of \"croak\" sound string. \nEach \"croak\" in the string represents a frog striking the head to make a \"croak\" sound. \nThe frogs can be grouped into families, where each family is represented by a positively integer. \nMore specifically, for example, \"croak\" represents a frog with a family of 1, and \"crcar\" represents a frog with a family of 2.\n\nThe frogs have two distinct traits:\n- Croaking ability: A single frog can make a sounds of no more than 6 different types of \"croak\".\n- Identity: A single frog is identified exclusively by a family number.\n\nSometimes, for multiple frogs, there will be a lot of noises before they become zombies. \nWe want to know the minimum number of different \"croak\" types among those frogs.\n\nReturn the minimum number of different \"croak\" types among those frogs.\n\n \n\nExample 1:\n\nInput: croakOfFrogs = \"croakcroak\"\nOutput: 1 \nExplanation", "groundtruth": "class Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        n = len(time)\n        INF = 10**9+1\n        dp = [[0 if i==0 else INF]*(n+1) for i in range(n+1)]\n        for i in range(1, n+1):\n            c0 = INF\n            for j, (t, c) in enumerate(zip(time, cost), 1):\n                i0 = max(i-t-1, 0)\n                c1 = c + dp[i0][j-1]\n                if c0 > c1:\n                    c0 = c1\n                dp[i][j] = c0\n        return dp[-1][-1]\n"}
{"task_id": "python/13", "content": "/Weekly Contest 160/1220_Count Vowels Permutation.cpp\n\n// Link: https://leetcode.com/contest/weekly-contest-160/problems/count-vowels-permutation/\n// Type: Dynamic Programming\n\nclass Solution {\npublic:\n    int countVowelPermutation(int n) {\n        int a, b, c, d, e;\n        long long ans = 5;\n\n        for (int i = 1; i < n; i++) {\n            a = 1;\n            b = 1;\n            c = 1;\n            d = 1;\n            e = 1;\n\n            ans = (ans + a + b + c + d + e) % 1000000007;\n\n            b = (b + a + c + d) % 1000000007;\n            c = (c + b + d) % 1000000007;\n            d = (d + c) % 1000000007;\n            e = (e + a) % 1000000007;\n        }\n\n        return ans;\n    }\n};/Weekly Contest 181/5372_Build Array With Stack Operations.py\n# Link: https://leetcode.com/contest/weekly-contest-181/problems/build-array-with-stack-operations/\n\nclass Solution:\n    def buildArray(self, target: List[int], n: int) -> List[str]:\n        l = []\n        for i in range(1, n+1):\n            if target[0] == i:\n                target.remove(i)\n                l.append(\"Push\")\n            else:\n                l.append(\"Push\")\n                l.append(\"Pop\")\n        return l\n/Weekly Contest 165/1237_Find Positive Integer Solution For a Given Equation.cpp\n// Link: https://leetcode.com/contest/weekly-contest-165/problems/find-positive-integer-solution-for-a-given-equation/\n// Type: Binary Search\n\n/*\n  * The ith test case has solution(x,y) = x - y = i", "groundtruth": "class Solution:\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n        # Sort based on position\n        arr = []\n        for i in range(len(positions)):\n            arr.append([positions[i],healths[i],directions[i],i+1])\n        arr.sort(key = lambda x: x[0])\n\n        # Use Stack DS to emulate the scene\n        right = [] # stores the right moving bots\n        left = [] # stores the left moving bots\n\n        for i in range(0, len(arr)):\n            # same direction append to stack\n            if arr[i][2] == 'R':\n                right.append(arr[i])\n            # different direction\n            else:\n                if right:\n                    # pop the last element\n                    bot1 = right.pop()\n                    # compare the strenghts\n                    if bot1[1] > arr[i][1]:\n                        bot1[1] -= 1\n                        right.append(bot1)\n                    \n                    elif bot1[1] < arr[i][1]:\n                        arr[i][1] -= 1\n                        while right and right[-1][1] < arr[i][1]:\n                            bot1 = right.pop()\n                            arr[i][1] -= 1\n                        if not right and arr[i][1] > 0:\n                            left.append(arr[i])\n                        elif right[-1][1] == arr[i][1]:\n                            right.pop()\n                        else:\n                            right[-1][1] -= 1\n                else:\n                    left.append(arr[i])\n        stack = left + right\n        stack.sort(key = lambda x: x[-1])\n        return [stack[i][1] for i in range(len(stack))]\n"}
{"task_id": "python/14", "content": "```---\ntitle: '[00114] 二叉树展开为链表'\ntags:\n  - leetcode\n  - 题解\n  - 树\ncategories:\n  - leetcode\n  - 题解\nauthor:\n  - 张学志\n  - 作者\n  - 张子枫\ndatetime: 2018-07-03 17:46\n---\n\n# [00114] 二叉树展开为链表\nGiven a binary tree, flatten it to a linked list in-place.\nFor example, given the following tree:\n```\n    1\n   / \\\n  2   5\n / \\   \\\n3   4   6\nThe flattened tree should look like:\n1\n \\\n  2\n   \\\n    3\n     \\\n      4\n       \\\n        5\n         \\\n          6\n```\n---\n\n## [1] 解题分析\n\n`二叉树` `递归` `链表` `树` `分治算法` `二叉树的构建` `树` `分治法`\n\n[15831-二叉树展开为链表](http://www.cnblogs.com/grandyang/p/6543058.html)\n\n---\n\n## [2] 思路\n\n**递归**\n\n这道题给了我们一棵二叉树，让我们把它扁平化成一个链表，也就是说把每个节点中的左子树和右子树扁平化进来，使得每个节点只包含一个子节点。这就像把一个二叉树的每层平铺到下一层中，直到所有的层都平铺完毕。这道题的难点在于，二叉树中没有顺序，也不能预先知道高度，所以不能像先序/后序遍历中那样先递归到左右子节点，然后再访问根节点。这道题的做法是，递归到左右子节点时，返回的是最左边的节点，所以当访问完左子树后，我们就把根节点的右子树接到左子树的最右节点上，这样做的目的是为了维持原有的顺序，并把链表的结构保存在原", "groundtruth": "class Solution:\n    def findPrimePairs(self, n: int) -> List[List[int]]:\n        prime=[0]*(n+1)\n        prime[0]=1\n        prime[1]=1\n        for x in range(2,n+1):\n            if prime[x]==0:\n                i=x\n                while x*i<=n:\n                    if prime[x*i]==0:\n                        prime[x*i]=1\n                    i+=1\n        result=[]\n        for x in range(2,((n//2)+1)):\n            if prime[x]==0 and prime[n-x]==0:\n                result.append([x,n-x])\n        return result\n"}
{"task_id": "python/15", "content": "\n\"\"\"\n\nclass Solution:\n    def sumImbalanceNumbers(self, nums: List[int]) -> int:\n        ### Add first 2 nums to map, check for gap\n        indices = {}\n        total = 0\n        prev = 0\n        indices[nums[0]] = 0\n        for i in range(1, len(nums)):\n            curSum = prev\n            below_index = indices[nums[i]-1] if nums[i]-1 in indices else -1\n            above_index = indices[nums[i]+1] if nums[i]+1 in indices else -1\n            cur_index = indices[nums[i]] if nums[i] in indices else -1\n            soonest_zero_imbalance = max(min(below_index, above_index), cur_index)\n            if soonest_zero_imbalance == -1:\n                curSum += i\n            else:\n                curSum -= i - soonest_zero_imbalance + 1\n            if below_index!= -1 and above_index!= -1 and min(below_index, above_index) > cur_index:\n                curSum += min(below_index, above_index) - 1\n                if cur_index!= -1:\n                    curSum += cur_index + 1\n            total += curSum\n            prev = curSum \n            indices[nums[i]] = i\n        return total\nclass Node():\n    def __init__(self, id, left=None, right=None, top=None, bottom=None):\n        self.id = id\n        self.left = left\n        self.right = right\n        self.top = top\n        self.bottom = bottom\n\nclass Solution():\n    def get_nodes(self, maze):\n        # First, create all the nodes\n        nodes = []\n        for i in range(len(maze)):\n            for j in range(len(maze[0])):\n                id = \"{}_{}\".format(i, j)\n                # Set bottom and top\n                top = None\n                bottom = None\n                if i!= 0:\n                    top = \"{}_{}\".format(i-1, j)\n                if i!= len(maze)-1:\n                    bottom = \"{}_{}\".format(i+1, j)\n                # Set left and right\n                left = None\n                right = None\n                if j!= 0:\n                    left = \"{}_{}\".", "groundtruth": "class Solution:\n    def sumImbalanceNumbers(self, nums: List[int]) -> int:\n        ### Add first 2 nums to map, check for gap\n        indices = {}\n        total = 0\n        prev = 0\n        indices[nums[0]] = 0\n        for i in range(1, len(nums)):  # start\n            curSum = prev\n            below_index = indices[nums[i]-1] if nums[i]-1 in indices else -1\n            above_index = indices[nums[i]+1] if nums[i]+1 in indices else -1\n            cur_index = indices[nums[i]] if nums[i] in indices else -1\n            soonest_zero_imbalance = max(max(below_index, above_index), cur_index)\n            if soonest_zero_imbalance == -1:\n                curSum += i\n            else:\n                curSum += i - soonest_zero_imbalance - 1\n            if below_index != -1 and above_index != -1 and min(below_index, above_index) > cur_index:\n                curSum -= min(below_index, above_index) + 1\n                if cur_index != -1:\n                    curSum += cur_index + 1\n            total += curSum  # end\n            prev = curSum \n            indices[nums[i]] = i\n        return total\n"}
{"task_id": "python/16", "content": "*/\n\n#include <stdio.h>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxIncreasingGroups(vector<int>& usageLimits) {\n        int n = usageLimits.size(), res = 0;\n        vector<int> count(n + 1, 0);\n\n        for (int i = 0; i < n; ++i) {\n            count[min(usageLimits[i], n)]++;\n        }\n\n        int needMore = 0, j = n;\n        vector<pair<int, int>> st;\n\n        for (int i = 0; i < n; ++i) {\n            --res;\n            needMore++;\n\n            while (j > 1 && count[j] < needMore) {\n                if (count[j]) {\n                    st.push_back({j + res - 1, count[j]});\n                }\n                needMore -= count[j];\n                count[j] = 0;\n                --j;\n            }\n\n            if (count[j] < needMore) {\n                ++res;\n                break;\n            }\n\n            --count[j - 1];\n            count[j] += needMore;\n\n            while (!st.empty() && st.back().first - res == j) {\n                count[j] += st.back().second;\n                needMore += st.back().second;\n                st.pop_back();\n            }\n        }\n\n        return res;\n    }\n};\n\nint main() {\n    //code\n    return 0;\n}\n/*\nGiven an array nums, we call (i, j) an important reverse pair if i < j and nums[i] > 2*nums[j].\n\nYou need to return the number of important reverse pairs in the given array.\n\nExample1:\n\nInput: [1,3,2,3,1]\nOutput: 2\nExample2:\n\nInput: [2,4,3,5,1]\nOutput: 3\nNote:\nThe length of the given array will not exceed 50,000.\nAll the numbers in the input array are in the range of 32-bit integer.\n*/\n\n#include", "groundtruth": "class Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        n = len(usageLimits)\n        count = [0] * (n+1)\n        for i in range(n):\n            count[min(usageLimits[i], n)] += 1\n        ans = 0\n        needMore = 0\n        j = n\n        stack = []\n        for i in range(n):\n            ans += 1\n            needMore += 1\n            while j > 1 and count[j] < needMore:\n                if count[j] > 0:\n                    stack.append((j+ans-1, count[j]))\n                needMore -= count[j]\n                count[j] = 0\n                j -= 1\n            if count[j] < needMore:\n                ans -= 1\n                break\n            count[j-1] += needMore\n            count[j] -= needMore\n            while stack and stack[-1][0] - ans == j:\n                count[j] += stack[-1][1]\n                needMore += stack[-1][1]\n                stack.pop()\n        return ans\n"}
{"task_id": "python/17", "content": "```\n/LeetCode/134. Gas Station/solution.md\n![134-GasStation.jpg](134-GasStation.jpg)\n\n\n# [134. Gas Station](https://leetcode.com/problems/gas-station/)\n\nGiven 2 integer arrays `gas` and `cost`, where `gas[i]` represents the amount of gas at station `i` and `cost[i]` represents the amount of cost to reach station `i`, both arrays have the same length.\n\nYou start with a starting station, which is indexed at 0. You drive the car based on gas[0], cost[0], gas[1], cost[1],... until you run out of gas and you can't travel in either direction. Return the starting station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there are multiple valid answers, you should return the smallest starting index.\n\n**Note** that if there exists a solution, it is guaranteed to be unique.\n\n### Example 1:\n\n```\nInput: gas = [1, 2, 3, 4, 5], cost = [3, 4, 5, 1, 2]\nOutput: 3\nExplanation:\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\n```\n\n### Example 2:\n\n```\nInput: gas = [2, 3, 4], cost = [3, 4, 3]\nOutput: -1\nExplanation:\nYou can't start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet's start", "groundtruth": "from collections import defaultdict\n\nclass Solution:\n    def countPalindromePaths(self, parent: List[int], s: str) -> int:\n        n = len(parent)\n        edges = defaultdict(list)\n        amnts = defaultdict(int)\n        self.res = 0\n        \n        for u, v in enumerate(parent):\n            edges[v].append(u)\n\n        def dfs(curr, mask):\n            # print(curr, format(mask, '08b'))\n            for i in range(26):\n                new_mask = mask ^ (1 << i)\n                self.res += amnts[new_mask]\n            self.res += amnts[mask]\n            amnts[mask] += 1\n            for i in edges[curr]:\n                idx = ord(s[i]) - ord('a')\n                dfs(i, mask ^ (1 << idx))\n            \n        dfs(0, 0)\n        return self.res\n"}
{"task_id": "python/18", "content": "def maxSubArraySum(a, size):\n\tmax_so_far = a[0]\n\tmax_ending_here = a[0]\n\tfor i in range(1, size):\n\t\tmax_ending_here = max(a[i], max_ending_here + a[i])\n\t\tmax_so_far = max(max_so_far, max_ending_here)\n\treturn max_so_far\n\ndef minSubArraySum(a, size):\n\tmin_so_far = a[0]\n\tmin_ending_here = a[0]\n\tfor i in range(1, size):\n\t\tmin_ending_here = min(a[i], min_ending_here + a[i])\n\t\tmin_so_far = min(min_so_far, min_ending_here)\n\treturn min_so_far\n\nif __name__ == '__main__':\n\ta = [-2, -3, 4, -1, -2, 1, 5, -3]\n\tn = len(a)\n\tmax_sum = maxSubArraySum(a, n)\n\tprint(\"Maximum contiguous sum is\", max_sum)\n\t\n\tmin_sum = minSubArraySum(a, n)\n\tprint(\"Minimum contiguous sum is\", min_sum)#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n    string str, temp = \"\";\n    cin >> str;\n    bool flag = 0;\n    for(char c : str) {\n        if(isupper(c)) {\n            flag = 1;\n            break;\n        }\n        if(islower(c)) temp = temp + c;\n    }\n    if(flag) {\n        cout << str << endl;\n    }\n    else {\n        for(char c : temp) {\n            cout << toupper(c);\n        }\n        cout << endl;\n    }\n    return 0;\n}\ndef isPerfectSquare(num):\n\tif num < 0:\n\t\treturn False\n\tif num == 1:\n\t\treturn True\n\treturn isPerfectSquare(num>>2)<<1 == num\n\ndef main():\n\tnum = int(input(\"Enter a number: \"))\n\tif", "groundtruth": "class Solution:\n    def countSteppingNumbers(self, low, high):\n        low = \"0\"*(len(high)-len(low)) + low\n        \n        mod = 10**9 + 7\n        \n        @lru_cache(None)\n        def dfs(i,is_greater_thn_low,is_less_thn_high,prev_digit,nonzero):\n            if i == len(high):\n                return 1\n            \n            total = 0\n            \n            start = int(low[i]) if not is_greater_thn_low else 0\n            end = int(high[i]) + 1 if not is_less_thn_high else 10\n            \n            for nx_digit in range(start,end):\n                if not nonzero or abs(prev_digit - nx_digit) == 1:\n                    total += dfs(i+1,is_greater_thn_low or nx_digit > int(low[i]),is_less_thn_high or nx_digit < int(high[i]),nx_digit,nonzero or nx_digit != 0)\n                    \n            return total%mod\n\n        return dfs(0, False, False, -1, False)\n"}
{"task_id": "python/19", "content": "'''\ndef isFascinating(n):\n    concatenated = str(n)+str(2*n)\n    if '0' in concatenated:\n        return False\n    if len(concatenated)>9:\n        return False\n    for i in range(1,10):\n        if str(i) not in concatenated:\n            return False\n    return True\n\nprint(isFascinating(2320))\n\n'''\n给定整数 n，如果n上所有位上的数字都是不同的，则n是一个好数。比如235都是好数，但是221不是好数。\n给定一个区间，你能在区间中的所有整数中找到那些好数吗？给定区间的下界和上界，请给出你找到的所有好数。\n注意，如果找到了多个好数，请按升序输出\n输入格式:\n输入一个正整数m，一个正整数n\n输出格式：\n按从小到大顺序输出区间[m, n]中所有的好数。\n'''\ndef findGoodNumberInInterval(m, n):\n    good_list = []\n    for num in range(m,n+1):\n        if len(set(list(str(num))))!=len(list(str(num))):\n            continue\n        else:\n            good_list.append(num)\n    return good_list\n\nprint(findGoodNumberInInterval(32,123))\n\n'''\n给定一个数字字符串和一个正整数n，计算在数字串中插入n个数字后，这些数字的最大值减去最小值的差。\n插入n个数字时，每个数字不能重复。\n注意：0不能插入数字串。\n输入格式：\n输入一行，第一行包含一个字符串S，表示数字串，第二行包含一个正整数n\n输出格式：\n输出最大值和最小值的差\n'''\ndef calcDif(S, n):\n    max_num=0\n    min_num=0\n    Slist = list(S)\n    Slist.sort()\n    for i in range(len(Slist)):\n        Slist.insert(i,str(n))\n    for i in Slist:\n        if int(i)==0:\n            continue\n        max_num+=int(i)\n    min_num=int(", "groundtruth": "class Solution:\n    def isFascinating(self, n: int) -> bool:\n        concatenated = str(n) + str(2 * n) + str(3 * n)\n\n        if '0' in concatenated:\n            return False\n        if len(concatenated)>9:\n            return False\n        for i in range(1,10):\n            if str(i) not in concatenated :\n                return False\n        return True\\n\n"}