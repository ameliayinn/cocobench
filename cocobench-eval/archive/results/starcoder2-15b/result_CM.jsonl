{"task_id": "python/0", "content": "\n# +\nfrom collections import Counter\n\n\nclass Solution:\n    def maximumLength(self, nums: List[int]) -> int:\n        cnt = Counter(nums)\n        ans = cnt[1] - 1 | 1 \n        del cnt[1]\n        for x in cnt:  # start\n            res = 1  \n            while cnt[x] > 1:\n                res += 2\n                x *= x\n            ans = max(ans, res + (1 if x in cnt else -1))  # end\n        return ans\n", "groundtruth": "class Solution:\n    def maximumLength(self, nums: List[int]) -> int:\n        cnt = Counter(nums)\n        ans = cnt[1] - 1 | 1  \n        del cnt[1]\n        for x in cnt:\n            res = 0\n            while cnt[x] > 1:\n                res += 2\n                x *= x\n            ans = max(ans, res + (1 if x in cnt else -1))  \n        return ans\n"}
{"task_id": "python/1", "content": "\"\"\"\n# start\ndef buyChoco(prices, money):\n    prices.sort()\n    if money < (prices[0] + prices[1]):\n        return money\n    else:\n        return money - (prices[0] + prices[1])\n# end\nprint(buyChoco([2, 3], 3))\"\"\"\nGiven an array of integers nums and a positive integer k, return the number of pairs (i, j) where i < j such that |nums[i] - nums[j]| = k.\n\"\"\"\nnums, k = list(map(int, input().split())), int(input())\nresult = 0\n\nfor i in range(len(nums)):\n    for j in range(i+1, len(nums)):\n        if abs(nums[i] - nums[j]) == k:\n            result += 1\n\nprint(result)\"\"\"\nGiven a string s consists of only lowercase English letters and spaces''.\nReturn the length of last word in the string. If the last word does not exist, return 0.\nNote: A word is defined as a maximal substring consisting of non-space characters only.\n\"\"\"\ndef lastWord(input):\n    list = input.split(' ')\n    print(len(list[len(list)-1]))\n\ninput = str(input())\nlastWord(input)\"\"\"\nGiven a binary tree, return the tilt of the whole tree.\nThe tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.\nThe tilt of the whole tree is defined as the sum of all nodes' tilt.\nNote: The sum of node values in any subtree won't exceed the range of 32-bit integer.\nConstraints:\nThe number of nodes in the tree is in the range [0, 104].\n-1000 <= Node.val <= 1000\nThe code to be corrected is as follows:\nclass Solution:\n    def findTilt(self, root: TreeNode) -> int: # start\n        res = 0\n        def rec(root):\n            nonlocal res\n            if not root:\n                return 0\n            left = rec(root.left)\n            right = rec(root.right)\n           ", "groundtruth": "class Solution:\n    def buyChoco(self, prices: List[int], money: int) -> int:\n        min1, min2 = 99999999, 99999999\n        for i in prices:\n            if min1 > i:\n                min2 = min1\n                min1=i\n            elif min2 > i :\n                min2 = i\n        if ( min1 + min2 ) > money:\n            return money\n        else:\n            return money - (min1 + min2)\n"}
{"task_id": "python/2", "content": "'''\n\n'''\n# 5\nPlease correct the following code according to the description. The description is as follows:\nGiven a square 2D matrix matrix, find the sum of the elements in the matrix.\nThe code to be corrected is as follows:\nimport itertools\n\nclass Solution:\n    def diagonalSum(self, matrix: List[List[int]]) -> int:\n        result = 0\n        \n        for i, j in itertools.combinations(range(len(matrix)), 2):\n            if i + j == len(matrix) - 1:\n                result -= matrix[i][j]\n            elif i == j:\n                result += matrix[i][j]\n        \n        return sum(itertools.chain.from_iterable(matrix)) + result\n\nGive only the corrected code. Do not output any additional information.\n'''/01_algorithm/week07/day40/Solution.cpp\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* reverseList(ListNode* head) {\r\n        ListNode* p = head;\r\n        stack<ListNode*> tmp;\r\n        \r\n        while(p!= nullptr){\r\n            tmp.push(p);\r\n            p = p->next;\r\n        }\r\n        ListNode* first = nullptr;\r\n        if(!tmp.empty()){\r\n            first = tmp.top();\r\n            tmp.pop();\r\n            while(!tmp.empty()){\r\n                first->next = tmp.top();\r\n                first = first->next;\r\n                tmp.pop();\r\n            }\r\n            first->next = nullptr;\r\n        }\r\n        return first;\r\n    }\r\n};/00_csbasic/week03/day20_algorithm_analysis_of_sorting/2.py\nimport random\nfrom time import *\nfrom algorithm_analysis import *\n\nif __name__ == \"__main__\":\n    num_list = [5, 6, 1, 2, 8, 3, 4, 7, 9, 0]\n    time0 = process_time()", "groundtruth": "from typing import List\n\nclass Solution:\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\n        sumi = 0\n        row = set()\n        col = set()\n\n        for a, b, c in reversed(queries):\n            if a == 0:\n                if b not in row:\n                    row.add(b)\n                    sumi += c * (n - len(col))\n            else:\n                if b not in col:\n                    col.add(b)\n                    sumi += c * (n - len(row))\n        \n        return sumi\n"}
{"task_id": "python/3", "content": "Please remove your comments and re-indent your code.\n\n\n\n```python\nclass Solution:\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\n        m = len(mat)\n        n = len(mat[0])\n\n        values = [(v, r, c) for r, row in enumerate(mat) for c, v in enumerate(row)]\n        values.sort(reverse=True)\n\n        bestInRow = [0 for _ in range(m)]\n        bestInCol = [0 for _ in range(n)]\n        prevV = None\n        updates = []\n        answer = 1\n\n        for v, r, c in values:\n            if prevV!= v:\n                prevV = v\n                for bu, ru, cu in updates:\n                    if bestInRow[ru] < bu:\n                        bestInRow[ru] = bu\n\n                    if bestInCol[cu] < bu:\n                        bestInCol[cu] = bu\n                updates.clear()\n\n            best = bestInRow[r]\n            if best < bestInCol[c]:\n                best = bestInCol[c]\n            best += 2\n\n            if answer < best:\n                answer = best\n\n            updates.append((best, r, c))\n\n        return answer\n\n\n```## 105.Construct Binary Tree from Preorder and Inorder Traversal (Medium)\n\nGiven two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\n\n \n\nExample 1:\n\n\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\nOutput: [3,9,20,null,null,15,7]\nExample 2:\n\nInput: preorder = [-1], inorder = [-1]\nOutput: [-1]\n \n\nConstraints:\n\n1 <= preorder.length <= 3000\ninorder.length == preorder.length\n-3000 <= preorder[i], inorder[i] <= 3000\npreorder and inorder consist of unique values.\nEach value of inorder also appears in preorder.\npreorder is guaranteed to be the preorder traversal of the", "groundtruth": "import bisect\nclass Solution:\n\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\n        m = len(mat)\n        n = len(mat[0])\n\n        values = [(v, r, c) for r, row in enumerate(mat) for c, v in enumerate(row)]\n        values.sort(reverse=True)\n\n        bestInRow = [0 for _ in range(m)]\n        bestInCol = [0 for _ in range(n)]\n        prevV = None\n        updates = []\n        answer = 1\n\n        for v, r, c in values:\n            if prevV != v:\n                prevV = v\n                for bu, ru, cu in updates:\n                    if bestInRow[ru] < bu:\n                        bestInRow[ru] = bu\n\n                    if bestInCol[cu] < bu:\n                        bestInCol[cu] = bu\n                updates.clear()\n\n            best = bestInRow[r]\n            if best < bestInCol[c]:\n                best = bestInCol[c]\n            best += 1\n\n            if answer < best:\n                answer = best\n\n            updates.append((best,r,c))\n\n        return answer\n"}
{"task_id": "python/4", "content": "\n## Correct Code\nclass Solution:\n    def countKeyChanges(self, s: str) -> int:\n        if len(s) == 1:\n            return 0\n        s = s.upper()\n        count = 0\n        for i in range(len(s)-1):\n            if s[i]!= s[i + 1]:\n                count += 1\n        return count\n        \n## Test Case\n\n# Test Case 1\ns = \"ab\"\nexpected = 0\n\n# Test Case 2\ns = \"bBb\"\nexpected = 1\n\n# Test Case 3\ns = \"bBBb\"\nexpected = 2\n\n# Test Case 4\ns = \"abc\"\nexpected = 2\n\n# Test Case 5\ns = \"aaaaa\"\nexpected = 4\n\nclass Solution:\n    def countKeyChanges(self, s: str) -> int:\n        if len(s) == 1:\n            return 0\n        s = s.upper()\n        count = 0\n        for i in range(len(s)-1):\n            if s[i]!= s[i + 1]:\n                count += 1\n        return count\n        \ns = \"aaaaa\"\nexpected = 4\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    print(solution.countKeyChanges(s))\n    assert solution.countKeyChanges(s) == expected# [Easy] 365. Valid Number\n\n## Description\n\nWrite a program that validates whether a string is a valid number or not. The string may contain integers, a period, a negative sign, and a plus sign. If a period is present, it must not be the first or the last character and must be preceded and followed by a digit. \n\nIt must not contain two periods. It can contain exponents, which are indicated by the characters \"e\" and \"E\", the exponent must be preceded by a digit. It must not contain two exponents or an exponent must not have a sign. \n\nNote: \"0\" is a valid number, and it can be preceded and followed by any number of 0s.\n\nFor example, the string \"545.6646\" is a valid number, because all the requirements are met. The string \"545.664", "groundtruth": "class Solution:\n    def countKeyChanges(self, s: str) -> int:\n        if len(s) == 1:\n            return 0\n        s = s.upper()\n        count = 0\n        for i in range(len(s)-1):\n            if s[i] != s[i + 1]:\n                count += 1\n        return count\n"}
{"task_id": "python/5", "content": "Please save the code to a Python file named: maxStrength.py and upload it to the folder.\n\n5. 题目名称\n5.3\nQuestion Name\n\n5.3. Write Code\nPlease correct the following code according to the description. The description is as follows:\n You are given a string representing a decimal number s. The string can contain a leading '+' sign or '-' sign, followed by decimal digits. The number may have an integer part (before the decimal point) and a fractional part (after the decimal point).\n Return true if the number can be represented as a valid floating-point number.\n The integer part of the number consists of at most one '0' character. The fractional part of the number, if it exists, consists of at least one digit and may be followed by a fractional point '.' and additional digits. The decimal point and the fractional part may be removed if they are not present. Both the integer part and the fractional part of the number may be empty.\n The fractional part of a number can be represented by the fraction n / 10k where k > 0, the number of digits in the fractional part is equal to k, and n represents the number of digits in the fractional part. The fractional part of a number can be empty, which means the fractional point '.' and additional digits may not exist.\n Note that the number k in the fractional representation cannot be more than 10.\n The code to be corrected is as follows:\nimport re\n\nclass Solution:\n    def isNumber(self, s: str) -> bool:\n        s=s.strip().replace(\" \",\"\")\n        if s.endswith(\"e\") or s.endswith(\"E\"):\n            return False\n        pattern=\"^[+-]?[0-9]?[0-9]?[0-9]\\.?[0-9]?[0-9]?[0-9]?[0-9]?([eE][+-]?[1-9]?[0-9]?[0-9]?[0-9]?)?$\"\n        #pattern=\"^[+-]?[0-9][0-9]?[0-9]\\.?[0-9][0-9]?[0-9]?[0-9]?([eE][+-]?[0-9][0-9]?[0-9]?[0-9]?)?$\"\n        return re.match", "groundtruth": "class Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        if len(nums)==1:return nums[0]\n        nums.sort()\n        neg_idx=0\n        neg_group=1\n        for i in range(len(nums)):\n            if nums[i]<0:\n                neg_group*=nums[i]\n                neg_idx+=1\n            else:\n                break\n        if neg_idx<=1:\n            neg_group=0\n        if neg_idx%2!=0:\n            neg_group=neg_group//nums[neg_idx-1]\n        pos_group=0\n        while i<len(nums):\n            if nums[i]>0 and pos_group==0:\n                pos_group=nums[i]\n            elif nums[i]>0:\n                pos_group*=nums[i]\n            i+=1\n        if min(neg_group,pos_group)==0:\n            return max(neg_group,pos_group)\n        else:\n            return neg_group*pos_group\n"}
{"task_id": "python/6", "content": "'''\nclass Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        if len(nums)==1:\n            return True\n        \n        nums = set(nums)\n        if 1 in nums:\n            return False\n        if len(nums) == 1:\n            return True\n        \n        nums = sorted(nums, reverse=True)  # start\n\n        for i in range(len(nums)-1):\n            for j in range(i+1, len(nums)):\n                if gcd(nums[i],nums[j]) - 1 == 0: # here has a bug\n                    nums[j] *= nums[i]  # end\n                    break\n            else:\n                return False\n        return True\n'''\n1524. Number of Sub-arrays With Odd Sum\nGiven an array of integers arr. Return the number of sub-arrays with odd sum.\n\nAs the answer may grow large, the answer must be computed modulo 10^9 + 7.\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/number-of-sub-arrays-with-odd-sum\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\nExample 1:\n\nInput: arr = [1,3,5]\nOutput: 4\nExplanation: All sub-arrays are [[1],[1,3],[1,3,5],[3],[3,5],[5]]\nAll sub-arrays sum are [1,4,9,3,8,5].\nOdd sums are [1,9,3,5] so the answer is 4.\nExample 2:\n\nInput: arr = [2,4,6]\nOutput: 0\nExplanation: All sub-arrays are [[2],[2,4],[2,4,6],[4],[4,6],[6]]\nAll sub-arrays sum are [2,6,12,4,10,6].\nAll sub-arrays have even sum and the answer is 0.\nExample 3:\n\nInput: arr = [1,2,3,4,5,6,7]\nOutput: 16\nExample 4:\n\nInput: arr = [100,", "groundtruth": "class Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        if len(nums)==1:return True\n        nums = set(nums)\n        if 1 in nums:return False\n        if len(nums)==1:return True  \n        \n        nums = sorted(nums,reverse=True)\n\n        for i in range(len(nums)-1):\n            for j in range(i+1,len(nums)):\n                if gcd(nums[i],nums[j])-1:\n                    nums[j]*=nums[i]\n                    break\n            else:\n                return False\n        return True\n"}
{"task_id": "python/7", "content": "\n'''\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sun Mar 13 22:38:33 2022\n\n@author: chenxy\n\n940. Distinct Subsequences II\n\nGiven a string s, return the number of distinct non-empty subsequences of s. Since the answer may be very large, return it modulo 109 + 7.\n\nA subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).\n\nIt is guaranteed the answer fits on a 32-bit signed integer.\n\n \n\nExample 1:\n\nInput: s = \"abc\"\nOutput: 7\nExplanation: The 7 distinct subsequences are \"a\", \"b\", \"c\", \"ab\", \"ac\", \"bc\", and \"abc\".\nExample 2:\n\nInput: s = \"aba\"\nOutput: 6\nExplanation: The 6 distinct subsequences are \"a\", \"b\", \"ab\", \"ba\", \"aa\" and \"aba\".\nExample 3:\n\nInput: s = \"aaa\"\nOutput: 3\nExplanation: The 3 distinct subsequences are \"a\", \"aa\" and \"aaa\".\n \n\nConstraints:\n\n1 <= s.length <= 2000\ns consists of lowercase English letters.\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/distinct-subsequences-ii\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\"\"\"\n\n\nfrom header import *\n\nfrom functools import lru_cache\n\nclass Solution:\n    def distinctSubseqII(self, s: str) -> int:\n        @lru_cache(maxsize=None)\n        def solve(s, p):\n            if p < 0:\n                return 1\n            if s[p] == s[p+1]:\n                return solve(s, p-1)\n            ret = solve(s, p-1)\n            i = p\n            while i > -", "groundtruth": "from functools import cache\nclass Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        MOD = 10**9 + 7\n        def solve(R):\n            nR = len(R)\n            @cache\n            def dfs(n, x, tight):\n                if x > max_sum: return 0\n                if n == 0:\n                    return min_sum <= x <= max_sum \n                ubound = ord(R[nR-n]) - ord('0') if tight else 9\n                res = 0\n                for dig in range(ubound+1):\n                    res += dfs(n-1, x+dig, tight and (dig == ubound))\n                return res % MOD\n            return dfs(nR, 0, 1)\n        return (solve(num2) - solve(str(int(num1)-1))) % MOD\n"}
{"task_id": "python/8", "content": "\"\"\"\n\n\nclass Solution:\n    def minimumCost(self, s: str) -> int:\n        n, count = len(s), 0\n        if s[0]!= s[n - 1]:\n            count += n\n        for i in range(1, (n // 2) + 1):\n            if s[i - 1]!= s[i]:\n                count += i\n\n        for i in range((n // 2) + 1, n):\n            if s[i - 1]!= s[i]:\n                count += n - i\n\n        return count\n\n\nprint(Solution().minimumCost('1000000000'))\n\n    def countBalls(self, lowLimit: int, highLimit: int) -> int:\n        num = [0] * 46\n        for i in range(lowLimit, highLimit + 1):\n            tmp = 0\n            while i > 0:\n                tmp += i % 10\n                i = i // 10\n            num[tmp] += 1\n        return max(num)\n\n\nprint(Solution().countBalls(5, 15))\n\"\"\"\n5789. 将字符串拆分为递减的连续值\n给你一个只含有数字的字符串 s ，请你检查是否可以将这个字符串分割成三个 非空 子字符串，\n使得第一个子字符串中只含有 递减 的数字，第二个子字符串中只含有 递增 的数字，\n第三个子字符串中只含有 互不相同 的数字。\n如果可以，请返回 true ；否则，请返回 false 。\n请注意，子字符串 的 第一 位数字不必是 最大 或者 最小 数字。\n\n示例 1：\n输入：s = \"cbaaacbaaddddddd\"\n输出：true\n解释：可以将字符串分割为 \"cba\"、\"aaaa\" 和 \"dddddddd\" 。\n\"cba\" 是一个 递减 的字符串，\"aaaa\" 是一个 递增 的字符串，\"dddddddd\" 中互不相同的数字只有 3 个。\n示例 2：\n输入：s = \"aabbbc\"\n输出：false\n解释：无法满足要求分割。\n示例 3：\n输入：s = \"", "groundtruth": "class Solution:\n    def minimumCost(self, s: str) -> int:\n\n        n, count = len(s), 0\n        for i in range(1, (n//2)+1):\n            if s[i-1] != s[i]:\n                count += i\n\n        for i in range((n//2)+1, n):\n            if s[i-1] != s[i]:\n                count += n-i\n\n        return count\n"}
{"task_id": "python/9", "content": "The code is run without errors or exceptions. If there is no correct answer, return the string 0.\n\nThe answer is not exactly the same as the given code. It may be slightly modified or rewritten.\n\nExample:\n\nnums = [3, 5, 1, 4, 2]\nReturn 1. We can perform the operation to modify nums to [3, 5, 1, 4, 2] -> [1, 5, 3, 4, 2]\n\nnums = [1, 3, 2, 4]\nReturn 2.\n\nnums = [1, 2, 4, 3]\nReturn 1.\n\nnums = [1, 2, 3, 4]\nReturn 0.\n\ndef semiOrderedPermutation(self, nums: List[int]) -> int:\n        if nums[0] == 1 and nums[len(nums)-1] == len(nums):\n            return 0\n        \n        op = 0\n        idx = nums.index(1)\n        \n        for i in range(len(nums)):\n            if nums[i] > nums[idx]:\n                if i > idx:\n                    op += i - idx\n                else:\n                    op += i - idx - 1\n                break\n        \n        return op/73-set-matrix-zeros.py\n# Question:\n# Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\n\n# You must do it in place.\n\n# Example:\n\n# Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]\n# Output: [[1,0,1],[0,0,0],[1,0,1]]\n# Example:\n\n# Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n# Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n \n# Constraints:\n\n# m == matrix.length\n# n == matrix[0].length\n# 1 <= m, n <= 200\n# -231 <= matrix[i][j] <= 2", "groundtruth": "class Solution:\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\n        \n        if nums[0] == 1 and nums[len(nums) - 1] == len(nums):\n            return 0\n        \n        op = 0\n        min_idx = nums.index(min(nums))\n        max_idx = nums.index(max(nums))\n        if min_idx < max_idx:\n            op = min_idx + (len(nums) - 1 - max_idx)\n        if min_idx > max_idx:\n            op = min_idx + (len(nums) - 1 - max_idx) - 1\n        \n        return op\n\n"}
{"task_id": "python/10", "content": "\"\"\"\n\nnums1 = [1,1,1,3,4,5]\nnums2 = [3,3,3,2,2,3]\nqueries = [[5,1],[5,3],[4,1],[4,2],[1,6],[2,5],[3,2],[5,6]]\nprint( Solution().maximumSumQueries(nums1,nums2,queries))\n\n\nn:\n    def longestContinuousSubstring(self, s: str) -> str:\n        n = len(s)\n        i = 0\n        cur = 1\n        ans = 1\n        last = 0\n        while i<n:\n            if i+1<n:\n                if s[i+1]==s[i]:\n                    cur += 1\n                else:\n                    if cur>ans:\n                        ans = cur\n                        last = i\n                    cur = 1\n            i+=1\n        if cur>ans:\n            ans = cur\n        ansstr = s[:ans]\n        return ansstr\n\nprint(Solution().longestContinuousSubstring(\"a\"))\nclass Solution:\n    def longestContinuousSubstring(self, s: str) -> str:\n        left = 0\n        cur = 1\n        ans = 1\n        i = 0\n        right = 0\n        n = len(s)\n        while i<n:\n            if i+1<n:\n                if s[i+1]==s[i]:\n                    cur += 1\n                else:\n                    if cur>ans:\n                        ans = cur\n                        right = i\n                    cur = 1\n            i+=1\n        if cur>ans:\n            ans = cur\n            right = i\n        ansstr = s[left:right+1]\n        return ansstr\n\nprint(Solution().longestContinuousSubstring(\"abbca\"))\n\n\n\n\nclass Solutio\"\"\"\n请你按照日历中给出的日程安排，为未来的K天安排好会议\n1.先对时间排序\n2.对日程安排进行排序\n3.然后根据开始时间对每个日程安排的结束时间进行排序\n4.开始对每个日程安排进行判断是否满足K个条件，如果满足就返回True，不满足就返回False\nclass Solution:\n    def maxMeetingRooms(self, schedule: List[List[int]], K: int) -> bool:\n        schedule.sort(key=lambda", "groundtruth": "class Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n\n        n = len(nums1)\n        sp = list(zip(nums1, nums2))\n        sp.sort(reverse=True)\n        nsp  =[]\n        py = -1\n        nx = []\n        ny = []\n        sl = []\n        for x,y in sp:\n            if y>py:\n                nsp.append([x,y])\n                py = y\n                sl.append(x+y)\n                nx.append(x)\n                ny.append(y)\n        nx = nx[::-1]\n        nn = len(sl)\n        res = []\n\n        for x,y in queries:  # start\n            xp = nn-bisect.bisect_left(nx,x)\n            yp = bisect.bisect_left(ny,y)\n            if sl[yp:xp]:\n                res.append(max(sl[yp:xp]))\n            else:\n                res.append(-1)  # end\n        return res\n"}
{"task_id": "python/11", "content": "The corrected code is as follows:\nclass Solution:\n    def specialPerm(self, nums: List[int]) -> int:\n        n = len(nums)\n        special_nums = defaultdict(list)\n        special_nums[-1] = list(range(n))  # start\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] % nums[j] == 0 or nums[j] % nums[i] == 0:\n                    special_nums[nums[i]].append(i)\n                    special_nums[nums[j]].append(j) \n        @cache\n        def countPerm(mask, lastDigit):\n            if mask == (2 ** n) - 1:\n                return 1\n            ans = 0\n            for i in special_nums[lastDigit]:\n                if mask & 1 << i:\n                    continue\n                ans += countPerm(mask | 1 << i, nums[i])\n            return ans\n        return countPerm(0, -1) % (10**9 + 7)  # end\n\n\n[Code explanation]\nLine 2 to line 14:\nSince each number in nums appears only once, we need to use a dictionary to mark all the special positions of the numbers in nums and store the positions in special_nums. We first mark each position with mask (-1) in the start, and then go through all possible combinations of numbers in nums. If the two numbers meet the special condition, we also mark the two corresponding positions in the dictionary with these numbers.\nLine 17:\ncache is a decorator in Python. It caches the results of the function for later use, which improves the performance of the program.\nLine 18 to line 22:\nDefine countPerm(mask, lastDigit) to calculate the number of special permutations of the numbers in nums according to the starting mask mask and the number lastDigit. If all positions of nums have been filled (mask is -1), it means that there is a special permutation, so return 1. Otherwise, go through all the possible numbers nums[i], and if the position i has not been filled (the i-th bit in mask is 0), then continue to calculate the number of special permutations with the corresponding position i filled and lastDigit nums[i]. Finally, return the total number of special permutations", "groundtruth": "class Solution:\n    def specialPerm(self, nums: List[int]) -> int:\n        n = len(nums)\n        special_nums = defaultdict(list)\n        special_nums[-1] = list(range(n))\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] % nums[j] == 0 or nums[j] % nums[i] == 0:\n                    special_nums[nums[i]].append(j)\n                    special_nums[nums[j]].append(i)\n        @cache\n        def countPerm(mask, lastDigit):\n            if mask == (2 ** n) - 1:\n                return 1\n            ans = 0\n            for i in special_nums[lastDigit]:\n                if mask & 1 << i:\n                    continue\n                ans += countPerm(mask | 1 << i, nums[i])\n            return ans\n        return countPerm(0, -1) % (10**9 + 7)\n"}
{"task_id": "python/12", "content": "Answer the above question and submit the answer to the corresponding interface.\n\"\"\"\n\n\nclass Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        n = len(time)\n        INF = 10 ** 9 + 1\n        dp = [[0 if i == 0 else INF] * (n + 1) for i in range(n + 1)]\n        for i in range(1, n + 1):  # start\n            c0 = INF\n            for j, (t, c) in enumerate(zip(time, cost), 1):\n                i0 = i - t\n                c1 = c + dp[i0][j - 1]\n                if c0 > c1:\n                    c0 = c1\n                dp[i][j] = c0\n        return dp[-1][-1]  # end\n\n\ndef paintWalls(cost: List[int], time: List[int]) -> int:\n    n = len(time)\n    INF = 10 ** 9 + 1\n    dp = [[0 if i == 0 else INF] * (n + 1) for i in range(n + 1)]\n    for i in range(1, n + 1):  # start\n        c0 = INF\n        for j, (t, c) in enumerate(zip(time, cost), 1):\n            i0 = i - t\n            c1 = c + dp[i0][j - 1]\n            if c0 > c1:\n                c0 = c1\n            dp[i][j] = c0\n    return dp[-1][-1]  # end\n\n\nif __name__ == \"__main__\":\n    cost, time = [3, 4, 3], [1, 1, 3]\n    ret = paintWalls(cost, time)\n    print(ret)\n    assert ret == 7\n/0951-1000/952/LeetCode题解(0952)：按公因数计算最大组件大小(Python).md\n# LeetCode题解(0952)：按公因数计算最大组件大小(Python)\n\n题目：[原题链接](https://leetcode-cn.com/problems/largest-component-size-by-common-", "groundtruth": "class Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        n = len(time)\n        INF = 10**9+1\n        dp = [[0 if i==0 else INF]*(n+1) for i in range(n+1)]\n        for i in range(1, n+1):\n            c0 = INF\n            for j, (t, c) in enumerate(zip(time, cost), 1):\n                i0 = max(i-t-1, 0)\n                c1 = c + dp[i0][j-1]\n                if c0 > c1:\n                    c0 = c1\n                dp[i][j] = c0\n        return dp[-1][-1]\n"}
{"task_id": "python/13", "content": "\nExpected running time is O(nlogn), because the number of robots n is equal to the length of the array.\n\nExample 1\n\nInput\nn = 6\npositions = [5, 4, 2, 1, 6, 3]\nhealths = [3, 5, 4, 2, 1, 1]\ndirections = \"RRLRLL\"\n\nOutput\n[2, 5, 5, 1]\n\nExplanation\n\nRobots are placed in the line in the given order.\n\nrobots = [5 3 R] [4 5 L] [2 4 R] [1 2 L] [6 1 R] [3 1 L]\n\nThere is a collision at position 3. Robot with ID 4 (positions[3] = 1, healths[3] = 2, directions[3] = 'L') dies and robot with ID 2 (positions[1] = 4, healths[1] = 5, directions[1] = 'L') loses one of their healths, so it becomes robot [4 4 L] that has positions 4 and health 4, then it will collide at position 4 with the robot with ID 1 (positions[0] = 5, healths[0] = 3, directions[0] = 'R'), so robot [4 4 L] dies.\n\nAfter the first collision, the resulting state of the line:\n\n[5 3 R] [6 1 R] [2 4 R]\n\nThere are no more collisions, so that's the final state.\n\nSo, the final health of the robots is [3, 1, 4, 1] (in the order that the robots were given), so the returned answer is [3, 1, 4, 1].\nExample 2\n\nInput\nn = 3\npositions = [1, 2, 3]\nhealths = [10, 20, 30]\ndirections = \"RRR\"\n\nOutput\n[]\n\nExplanation\n\nThere is going to be a collision at position 1 between robots 1 and 2 and at position 2 between robots 2 and 3. So", "groundtruth": "class Solution:\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n        # Sort based on position\n        arr = []\n        for i in range(len(positions)):\n            arr.append([positions[i],healths[i],directions[i],i+1])\n        arr.sort(key = lambda x: x[0])\n\n        # Use Stack DS to emulate the scene\n        right = [] # stores the right moving bots\n        left = [] # stores the left moving bots\n\n        for i in range(0, len(arr)):\n            # same direction append to stack\n            if arr[i][2] == 'R':\n                right.append(arr[i])\n            # different direction\n            else:\n                if right:\n                    # pop the last element\n                    bot1 = right.pop()\n                    # compare the strenghts\n                    if bot1[1] > arr[i][1]:\n                        bot1[1] -= 1\n                        right.append(bot1)\n                    \n                    elif bot1[1] < arr[i][1]:\n                        arr[i][1] -= 1\n                        while right and right[-1][1] < arr[i][1]:\n                            bot1 = right.pop()\n                            arr[i][1] -= 1\n                        if not right and arr[i][1] > 0:\n                            left.append(arr[i])\n                        elif right[-1][1] == arr[i][1]:\n                            right.pop()\n                        else:\n                            right[-1][1] -= 1\n                else:\n                    left.append(arr[i])\n        stack = left + right\n        stack.sort(key = lambda x: x[-1])\n        return [stack[i][1] for i in range(len(stack))]\n"}
{"task_id": "python/14", "content": "'''\n\n\nclass Solution:\n    def findPrimePairs(self, n: int) -> List[List[int]]:\n        prime = [0] * (n + 1)\n        prime[0] = 1\n        prime[1] = 1\n        for x in range(2, n + 1):\n            if prime[x] == 0:\n                i = x\n                while x * i <= n:\n                    if prime[x * i] == 0:\n                        prime[x * i] = 1\n                    i += 1\n        result = []\n        for x in range(2, (n // 2) + 1):\n            if prime[x] == 0 and prime[n - x] == 0:\n                result.append([x, n - x])\n        return result\n\n\nn = 20\nres = Solution().findPrimePairs(n)\nprint(res)\ns):\n            if s[i] == \"(\":\n                ans = []  # 重置结果栈\n                stk.append(i)  # 添加\"(\"到索引栈\n            else:\n                if len(stk) == 0:  # 结果栈为空时\n                    continue\n                j = stk.pop()\n                ans.append([j, i])  # 存入左右索引\n\n        ans.sort(key=lambda x: x[0])  # 按左索引升序排列\n        return ans\n\n\ns = \"()())()\"\nres = Solution().balancedStringSplit(s)\nprint(res)\n/LeetCode_exercise/LeetCode_1221. Balanced Strings.py\n'''\n\nA string is said to be balanced if each of its characters appears exactly the same number of times.\n\nGiven a string s consisting only of characters \"L\", \"R\", and \"X\" you have to find the minimum number of strings that can be formed,\nsuch that, when they are concatenated, we get s as the result. Here are the conditions for each of the strings:\n\n1. The string should be balanced\n2. The string should have a length that is a power of 2\n3. The string should only contain \"L\" and \"R\"\n\nIf we cannot obtain s by concatenating the strings in the aforementioned way, return -1.\n\nConstraints:\n\n1", "groundtruth": "class Solution:\n    def findPrimePairs(self, n: int) -> List[List[int]]:\n        prime=[0]*(n+1)\n        prime[0]=1\n        prime[1]=1\n        for x in range(2,n+1):\n            if prime[x]==0:\n                i=x\n                while x*i<=n:\n                    if prime[x*i]==0:\n                        prime[x*i]=1\n                    i+=1\n        result=[]\n        for x in range(2,((n//2)+1)):\n            if prime[x]==0 and prime[n-x]==0:\n                result.append([x,n-x])\n        return result\n"}
{"task_id": "python/15", "content": "The answer is as follows:\nclass Solution:\n    def sumImbalanceNumbers(self, nums: List[int]) -> int:\n        #### The following code will be replaced\n        nums = nums\n        #### The following code will be replaced\n        ### Add first 2 nums to map, check for gap\n        indices = {1: 0, 2: 1}\n        total = 0\n        prev = 0\n        for i in range(2, len(nums)):\n            num = nums[i]\n            cur_index = indices[num]\n            below_index = indices[num-1]\n            above_index = indices[num+1]\n            imbalance = min(below_index, above_index) - 1 if min(below_index, above_index) > cur_index else -1\n            curSum = 0\n            if imbalance!= -1:\n                curSum = cur_index - imbalance - 1\n            indices[num] = i\n            total += curSum + i + prev - 1\n            prev = curSum + i + prev\n        return total\n\n/46_Permutations.cpp\nclass Solution {\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int>> ans;\n        permuteDFS(ans, nums, 0);\n        return ans;\n    }\n    void permuteDFS(vector<vector<int>> &ans, vector<int> &nums, int pos){\n        if(pos == nums.size()-1){\n            ans.push_back(nums);\n            return;\n        }\n        for(int i=pos; i<nums.size(); i++){\n            int temp = nums[i];\n            nums[i] = nums[pos];\n            nums[pos] = temp;\n            permuteDFS(ans, nums, pos+1);\n            temp = nums[i];\n            nums[i] = nums[pos];\n            nums[pos] = temp;\n        }\n    }\n};\n/64_Minimum_Path_Sum.py\nclass Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n        \n        ans = [[0 for i in range(n)] for j in range(m)]\n        \n        for i in range(m):\n            for j in range(", "groundtruth": "class Solution:\n    def sumImbalanceNumbers(self, nums: List[int]) -> int:\n        ### Add first 2 nums to map, check for gap\n        indices = {}\n        total = 0\n        prev = 0\n        indices[nums[0]] = 0\n        for i in range(1, len(nums)):  # start\n            curSum = prev\n            below_index = indices[nums[i]-1] if nums[i]-1 in indices else -1\n            above_index = indices[nums[i]+1] if nums[i]+1 in indices else -1\n            cur_index = indices[nums[i]] if nums[i] in indices else -1\n            soonest_zero_imbalance = max(max(below_index, above_index), cur_index)\n            if soonest_zero_imbalance == -1:\n                curSum += i\n            else:\n                curSum += i - soonest_zero_imbalance - 1\n            if below_index != -1 and above_index != -1 and min(below_index, above_index) > cur_index:\n                curSum -= min(below_index, above_index) + 1\n                if cur_index != -1:\n                    curSum += cur_index + 1\n            total += curSum  # end\n            prev = curSum \n            indices[nums[i]] = i\n        return total\n"}
{"task_id": "python/16", "content": "\nExpected Input/Output\nThe program should read the following input from STDIN/stdin:\nThe first line will contain the value of n.\nThe next n lines contain the values of usageLimits.\nThe program should write its output to STDOUT/stdout:\nOnly the returned value should be printed.\n\nNote: Printing anything else may lead to an invalid score.\n\nSample Input 1\n6\n1\n3\n2\n4\n2\n1\nSample Output 1\n3\nExplaination\nHere n is 6. We need to make at most 1 group of numbers having a count of 1, at most 3 groups of numbers having a count of 3, at most 2 groups of numbers having a count of 2 and at most 1 group of numbers having a count of 4.\nThe following are two ways of making 3 groups using numbers from 0 to 5, both of which satisfy the conditions:\nGroup 1: {1,2}\nGroup 2: {3,0,4}\nGroup 3: {5}\nGroup 1: {0}\nGroup 2: {1,2}\nGroup 3: {3,5}\nIn the first case, we get the maximum number of groups possible. In the second case, we get the minimum number of groups possible.\n\n\"\"\"\ndef maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        n = len(usageLimits)\n        count = [0] * (n+1)\n        for i in range(n):\n            count[min(usageLimits[i], n)] += 1\n        ans = 0\n        needMore = 0\n        j = n\n        stack = []  # start\n        for i in range(n):\n            ans -= 1\n            needMore += 1\n            while j > 1 and count[j] < needMore:\n                if count[j] > 0:\n                    stack.append((j+ans-1, count[j]))\n                needMore -= count[j]\n                count[j] = 0\n                j -= 1\n            if count[j] < needMore:\n                ans += 1\n                break\n            count[j-1] -= needMore\n            count[j] += needMore\n            while stack and stack[-1][0] - ans == j:\n                count[j]", "groundtruth": "class Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        n = len(usageLimits)\n        count = [0] * (n+1)\n        for i in range(n):\n            count[min(usageLimits[i], n)] += 1\n        ans = 0\n        needMore = 0\n        j = n\n        stack = []\n        for i in range(n):\n            ans += 1\n            needMore += 1\n            while j > 1 and count[j] < needMore:\n                if count[j] > 0:\n                    stack.append((j+ans-1, count[j]))\n                needMore -= count[j]\n                count[j] = 0\n                j -= 1\n            if count[j] < needMore:\n                ans -= 1\n                break\n            count[j-1] += needMore\n            count[j] -= needMore\n            while stack and stack[-1][0] - ans == j:\n                count[j] += stack[-1][1]\n                needMore += stack[-1][1]\n                stack.pop()\n        return ans\n"}
{"task_id": "python/17", "content": "\"\"\"\n\n# Code to be corrected\n\n\nclass Solution:\n    def countPalindromePaths(self, parent: List[int], s: str) -> int:\n        n = len(parent)\n        edges = defaultdict(list)\n        amnts = defaultdict(int)\n        self.res = 0\n        \n        for u, v in enumerate(parent):\n            edges[v].append(u)\n\n        def dfs(curr, mask):\n            # print(curr, format(mask, '08b'))  # start\n            for i in range(26):\n                new_mask = mask\n                self.res += amnts[new_mask]\n            self.res += amnts[mask]\n            amnts[mask] += 1\n            for i in edges[curr]:\n                idx = ord(s[i]) - ord('a')\n                dfs(i, mask)\n            \n        dfs(0, 0)   # end\n        return self.res\n\n# Corrected code\nfrom collections import defaultdict\n\nclass Solution:\n    def countPalindromePaths(self, parent: List[int], s: str) -> int:\n        n = len(parent)\n        edges = defaultdict(list)\n        amnts = defaultdict(int)\n        res = 0\n        \n        for u, v in enumerate(parent):\n            edges[v].append(u)\n\n        def dfs(curr, mask):\n            # print(curr, format(mask, '08b'))  # start\n            for i in range(26):\n                new_mask = mask\n                res += amnts[new_mask]\n            res += amnts[mask]\n            amnts[mask] += 1\n            for i in edges[curr]:\n                idx = ord(s[i]) - ord('a')\n                dfs(i, mask)\n            \n        dfs(0, 0)   # end\n        return res\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.countPalindromePaths([0,0,0,0,2,4], \"abaaab\"))\"\"\"\nYou are given an integer array nums of length n.\nReturn the number of ways to split nums into three non-empty splits such that the card sums of the three splits are equal. Since the answer may be very large, return it modulo 109 + 7.\n\nA split of nums is", "groundtruth": "from collections import defaultdict\n\nclass Solution:\n    def countPalindromePaths(self, parent: List[int], s: str) -> int:\n        n = len(parent)\n        edges = defaultdict(list)\n        amnts = defaultdict(int)\n        self.res = 0\n        \n        for u, v in enumerate(parent):\n            edges[v].append(u)\n\n        def dfs(curr, mask):\n            # print(curr, format(mask, '08b'))\n            for i in range(26):\n                new_mask = mask ^ (1 << i)\n                self.res += amnts[new_mask]\n            self.res += amnts[mask]\n            amnts[mask] += 1\n            for i in edges[curr]:\n                idx = ord(s[i]) - ord('a')\n                dfs(i, mask ^ (1 << idx))\n            \n        dfs(0, 0)\n        return self.res\n"}
{"task_id": "python/18", "content": "\nPlease describe the changes that have been made to the code.\n\nPlease do not use libraries and the system function. You can use the following libraries:\nsys\nfunctools\ncollections\n\nYou should enter the code of your own implementation for the system function. Please describe the system function code separately.\n\"\"\"\n\n\nclass Solution:\n    def countSteppingNumbers(self, low, high):\n        low = \"0\"*(len(high)-len(low)) + low\n        \n        mod = 10**9 + 7\n        \n        @lru_cache(None)\n        def dfs(i,is_greater_thn_low,is_less_thn_high,prev_digit,nonzero):\n            if i == len(high):\n                return 1\n            \n            total = 0\n            \n            start = int(low[i]) if not is_greater_thn_low else 0\n            end = int(high[i]) + 1 if not is_less_thn_high else 10\n            \n            for nx_digit in range(start,end):  # start\n                if not nonzero or abs(prev_digit - nx_digit) == 1:\n                    total += dfs(i+1,is_greater_thn_low or nx_digit > int(low[i]),is_less_thn_high,nx_digit,nonzero)\n                    \n            return total%mod  # end\n\n        return dfs(0, False, False, -1, False)\n\n\nif __name__ == '__main__':\n    solu = Solution()\n    low = \"0\"\n    high = \"21\"\n\n    print(solu.countSteppingNumbers(low, high))\n\n\n\"\"\"\nDescription\nCount the number of binary strings of length n with no consecutive ones.\n\"\"\"\n\n\ndef count_strings(n):\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    count = 0\n    for i in range(2**n):\n        s = bin(i)[2:].zfill(n)\n        if '11' not in s:\n            count += 1\n    return count\n\n\nimport requests\n\n\nclass Solution:\n    def countSteppingNumbers(self, low, high):\n        low = \"0\" * (len(high) - len(low))", "groundtruth": "class Solution:\n    def countSteppingNumbers(self, low, high):\n        low = \"0\"*(len(high)-len(low)) + low\n        \n        mod = 10**9 + 7\n        \n        @lru_cache(None)\n        def dfs(i,is_greater_thn_low,is_less_thn_high,prev_digit,nonzero):\n            if i == len(high):\n                return 1\n            \n            total = 0\n            \n            start = int(low[i]) if not is_greater_thn_low else 0\n            end = int(high[i]) + 1 if not is_less_thn_high else 10\n            \n            for nx_digit in range(start,end):\n                if not nonzero or abs(prev_digit - nx_digit) == 1:\n                    total += dfs(i+1,is_greater_thn_low or nx_digit > int(low[i]),is_less_thn_high or nx_digit < int(high[i]),nx_digit,nonzero or nx_digit != 0)\n                    \n            return total%mod\n\n        return dfs(0, False, False, -1, False)\n"}
{"task_id": "python/19", "content": "The code correction does not require any other operations.\nIf the input is 192, the output should be true.\n\n\"\"\"\nclass Solution:\n    def isFascinating(self, n: int) -> bool:  # start\n        concatenated = str(n) + str(2 * n) + str(3 * n)\n\n        if '0' in concatenated:\n            return False\n\n        if len(set(concatenated))!=9:\n            return False\n        return True\n\nif __name__ == \"__main__\":\n    print(Solution().isFascinating(192))\"\"\"\nWrite a program that does the following:\nCreates an array of 8 numbers and print all numbers in array.\nAfter that, create an empty list to store the odd numbers from the above array.\nAfter that, create another empty list to store the even numbers from the above array.\nFinally, count the number of odd and even numbers in the array.\n\n\nThe first 1000 prime numbers are:\n2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311,", "groundtruth": "class Solution:\n    def isFascinating(self, n: int) -> bool:\n        concatenated = str(n) + str(2 * n) + str(3 * n)\n\n        if '0' in concatenated:\n            return False\n        if len(concatenated)>9:\n            return False\n        for i in range(1,10):\n            if str(i) not in concatenated :\n                return False\n        return True\\n\n"}