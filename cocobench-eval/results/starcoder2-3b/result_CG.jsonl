{"task_id": "java/0", "content": "[0, 1]\t0\n[1, 0]\t0\n[1, 0]\t0\n[1, 0]\t0\n[1, 0]\t0\n0\t[1, 0]\t0\n[1, 0]\t0\n[1, 0]\t0\n0\t[0, 1]\t0\n1\t[1, 0]\t1\n[1, 0]\t0\n[1, 0]\t0\n[1, 0]\t0\n1\t[0, 1]\t0\n1\t[1, 0]\t0\n[1, 0]\t0\n[1, 0]\t0\n0\t[1, 0]\t0\n1\t[1, 0]\t1\n[1, 0]\t0\n[1, 0]\t0\n[1, 0]\t0\n0\t[0, 1]\t0\n[1, 0]\t0\n[1, 0]\t0\n0\t[0, 1]\t0\n0\t[0, 1]\t0\n0\t[1, 0]\t0\n[0, 1]\t0\n[1, 0]\t0\n[1, 0]\t0\n0\t[0, 1]\t0\n0\t[1, 0]\t0\n[0, 1]\t0\n[1, 0]\t0\n0\t[0, 1]\t0\n[1, 0]\t0\n[1, 0]\t0\n[1, 0]\t0\n0\t[1, 0]\t0\n[1, 0]\t0\n[1, 0]\t0\n0\t[1, 0]\t0\n0\t[1, 0]\t0\n[0, 1]\t0\n[1, 0]\t0\n[1, 0]\t0\n0\t[0, 1]\t0\n[1, 0]\t0\n[1, 0]\t0\n0\t[1, 0]\t0\n1\t[0, 1]\t1\n0\t[0", "groundtruth": "class Solution {    public int findChampion(int n, int[][] edges) {        int[] degree = new int[n];        for (int[] e : edges) {            degree[e[1]]++;        }        int champion = -1;        for (int i = 0; i < n; i++) {            if (degree[i] == 0) {                if (champion == -1) {                    champion = i;                } else {                    return -1;                }            }        }        return champion;    }}"}
{"task_id": "java/1", "content": "*/\n\nclass Solution {\n    public long maximumScoreAfterOperations(int[][] edges, int[] values) {\n        List<Integer>[] g = new ArrayList[values.length];\n        Arrays.setAll(g, e -> new ArrayList<>());\n        g[0].add(-1);\n         for (int[] e : edges) {\n            int x = e[0], y = e[1];\n            g[x].add(y);\n            g[y].add(x);\n        }\n        long ans = 0;\n        for (int v : values) {\n            ans += v;\n        }\n        return ans;\n    }\n    private long dfs(int x, int fa, List<Integer>[] g, int[] values) {\n        if (g[x].size() == 1) {\n             return values[x];\n        }\n        long loss = 0;\n         for (int y : g[x]) {\n            if (y!= fa) {\n                loss += dfs(y, x, g, values);\n            }\n        }\n        return Math.min(values[x], loss);\n    }\n}\n\n// C++\n\nclass Solution {\npublic:\n    long long maximumScoreAfterOperations(vector<vector<int>>& edges, vector<int>& values) {\n        int n = values.size();\n        vector<vector<int>> g(n);\n        for (auto e : edges) {\n            g[e[0]].push_back(e[1]);\n            g[e[1]].push_back(e[0]);\n        }\n        long long ans = 0;\n        for (int v : values) {\n            ans += v;\n        }\n        return ans + dfs(0, -1, g, values);\n    }\n    long long dfs(int x, int fa, vector<vector<int>>& g, vector<int>& values) {\n        long long loss = 0;\n        if (g[x].size() == 1) {\n            return values[x];\n        }\n        for (int y : g[x]) {\n            if (y!= fa) {\n                loss += dfs(y, x, g, values);\n            }\n        }\n        return min(values[x], loss);\n    }\n};/leetcode/1167. Minimum Cost to Connect Sticks/readme.md\n1167. Minimum Cost to Connect Sticks\nMedium", "groundtruth": "class Solution {    public long maximumScoreAfterOperations(int[][] edges, int[] values) {        List<Integer>[] g = new ArrayList[values.length];        Arrays.setAll(g, e -> new ArrayList<>());        g[0].add(-1);         for (int[] e : edges) {            int x = e[0], y = e[1];            g[x].add(y);            g[y].add(x);        }        long ans = 0;        for (int v : values) {            ans += v;        }        return ans - dfs(0, -1, g, values);    }    private long dfs(int x, int fa, List<Integer>[] g, int[] values) {        if (g[x].size() == 1) {             return values[x];        }        long loss = 0;         for (int y : g[x]) {            if (y != fa) {                loss += dfs(y, x, g, values);             }        }        return Math.min(values[x], loss);     }}"}
{"task_id": "java/2", "content": "\nExample 1:\nInput: nums = [2,2,3]\nOutput: \"scalene\"\nExplanation:\nIn the above figure, the triangle is of type \"scalene\" because it has three unequal sides of lengths x = 2, y = 2, and z = 3.\nExample 2:\nInput: nums = [8,15,5]\nOutput: \"isosceles\"\nExplanation:\nIn the above figure, the triangle is of type \"isosceles\" because it has two sides of length 8 and 5.\nExample 3:\nInput: nums = [4,4,4]\nOutput: \"equilateral\"\nExplanation:\nIn the above figure, the triangle is of type \"equilateral\" because it has all three sides of length 4.\n\nConstraints:\n3 <= nums.length <= 3\n1 <= nums[i] <= 109\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/check-if-it-is-a-straight-line\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n/** * Definition for a point. * public class Point { * int x; * int y; * Point() { * x = 0; * y = 0; * } * Point(int a, int b) { * x = a; * y = b; * } * } */ class Solution {    public boolean checkStraightLine(int[][] coordinates) {        int x1 = coordinates[0][0];        int y1 = coordinates[0][1];        int x2 = coordinates[1][0];        int y2 = coordinates[1][1];        // 注意判断 斜率 不是 int 型而是 long 型        long m = ((long) (x2 - x1)) / (y2 - y1); // 斜率        long b = y1 - x1 * m; // y 轴截距        long curY = 0;        for (int i = 1; i < coordinates.length; i++) {            int x3 = coordinates[i][0];            int y3 = coordinates[i][1];", "groundtruth": "class Solution {    public String triangleType(int[] nums) {        Arrays.sort(nums);        int x = nums[0];        int y = nums[1];        int z = nums[2];        if (x + y <= z) { // 排序后，只需比较 x+y 和 z            return 'none';        }        if (x == z) { // 排序了，说明 y 也和 x z 相等            return 'equilateral';        }        if (x == y || y == z) {            return 'isosceles';        }        return 'scalene';    }}"}
{"task_id": "java/3", "content": "Give the expected result. Please do not change any character and the order of the lines, but please add new lines if necessary.\nThe input will be generated using the given code.\nYou do not have to take any input, just press \"Run Code\" to check the output.\nThe output of the judge is displayed in the pop-up box, and the judge's answer is the final result displayed after the judge's answer.\n\n#### Sample Code 1\n\n##### Input:\n\n2\n4 4\n0 0\n0 2\n1 1\n3 2\n\n##### Output:\n\n2\n##### Explanation:\n\nThe above figure shows the given points. There are two pairs of points that satisfy the given condition, as shown in red and green respectively.\n\n##### Sample Code 2\n\n##### Input:\n\n2\n4 4\n0 0\n0 2\n1 1\n2 2\n\n##### Output:\n\n2\n##### Explanation:\n\nThe above figure shows the given points. There are two pairs of points that satisfy the given condition, as shown in red and green respectively.\n\n#### Sample Code 3\n\n##### Input:\n\n4\n1 3\n0 0\n0 2\n1 1\n3 2\n\n##### Output:\n\n0\n\n#### Sample Code 4\n\n##### Input:\n\n10\n3 3\n1 2\n0 2\n4 5\n1 1\n-1 3\n3 4\n0 1\n2 2\n3 3\n\n##### Output:\n\n11\n\n#### Sample Code 5\n\n##### Input:\n\n7\n3 7\n1 6\n1 2\n1 6\n0 5\n1 3\n0 1\n\n##### Output:\n\n10\n\n### Explanation\n\nThe above figure shows the given points. There are two pairs of points that satisfy the given condition, as shown in red and green respectively.\n\n### Constraints\n\n• 2n < 100, where n is the number of points\n• -100 < xi, yi < 100\n\n## Problem 3\n\n### Description\n\nGiven an n x n matrix grid, return the length of the longest diagonal of a matrix (starting at top left and going in descending order).\n", "groundtruth": "class Solution {    public int numberOfPairs(int[][] points) {        int pairs = 0;        Arrays.sort(points, (a, b) -> {            if (a[0] != b[0]) {                return a[0] - b[0];            } else {                return b[1] - a[1];            }        });        int n = points.length;        for (int i = 0; i < n; i++) {            for (int j = i + 1; j < n; j++) {                if (points[i][1] >= points[j][1] && isGood(points, i, j)) {                    pairs++;                }            }        }        return pairs;    }    public boolean isGood(int[][] points, int index1, int index2) {        int n = points.length;        for (int i = 0; i < n; i++) {            if (i == index1 || i == index2) {                continue;            }            if (points[i][0] >= points[index1][0] && points[i][0] <= points[index2][0] && points[i][1] >= points[index2][1] && points[i][1] <= points[index1][1]) {                return false;            }        }        return true;    }}"}
{"task_id": "java/4", "content": "The test case has been generated such that the answer will always fit in a 64-bit signed integer.\n\nExample 1:\nInput: nums = [2,6,2,8,1,7], k = 3\nOutput: 16\nExplanation: The optimal subarray is [6,2,8].\n\nExample 2:\nInput: nums = [1,100,1000,10000], k = 5000\nOutput: 10100\nExplanation: The optimal subarray is [10000].\n\nExample 3:\nInput: nums = [1,1,1,2], k = 2\nOutput: 5\n\n\nConstraints:\n2 <= nums.length <= 105\n-109 <= nums[i] <= 109\n1 <= k <= 105\n\nclass Solution {\n    public long maximumSubarraySum(int[] nums, int k) {\n        long ans = Long.MIN_VALUE;\n        long sum = 0;\n        Map<Integer, Long> minS = new HashMap<>();\n        for (int x : nums) {\n            long s1 = sum - minS.getOrDefault(x + k, Long.MAX_VALUE / 2);\n            long s2 = minS.getOrDefault(x - k, Long.MAX_VALUE / 2);\n            ans = Math.max(ans, sum + x - Math.min(s1, s2));\n            minS.merge(x, sum, Math::min);\n            sum += x;\n        }\n        return ans > Long.MIN_VALUE / 4? ans : 0;\n    }\n}\n\nExample 1:\nInput: nums = [2,6,2,8,1,7], k = 3\nOutput: 16\nExplanation: The optimal subarray is [6,2,8].\n\nExample 2:\nInput: nums = [1,100,1000,10000], k = 5000\nOutput: 10100\nExplanation: The optimal subarray is [10000].\n\nExample 3:\nInput: nums = [1,1,1,2], k = 2\nOutput:", "groundtruth": "class Solution {    public long maximumSubarraySum(int[] nums, int k) {        long ans = Long.MIN_VALUE;        long sum = 0;        Map<Integer, Long> minS = new HashMap<>();        for (int x : nums) {            long s1 = minS.getOrDefault(x - k, Long.MAX_VALUE / 2);            long s2 = minS.getOrDefault(x + k, Long.MAX_VALUE / 2);            ans = Math.max(ans, sum + x - Math.min(s1, s2));            minS.merge(x, sum, Math::min);            sum += x;        }        return ans > Long.MIN_VALUE / 4 ? ans : 0;    }}"}
{"task_id": "java/5", "content": "In the sample case, the substring has dominant ones because the number of ones is greater than or equal to the square of the number of zeros.\nSample Input:\n\"10101\"\nSample Output:\n9\nExplanation:\nThe substring with dominant ones is \"10101\", \"10101\", \"10101\", \"10101\", \"10101\", \"10101\", \"10101\", \"10101\", and \"10101\".\n\n\n#include<iostream>\n#include<string>\nusing namespace std;\nconst int MAX = 100000 + 1;\nchar s[MAX];\nint main(){\nscanf(\"%s\", s);\nint m = 0, ans = 0, n = 0;\nint a[MAX], b[MAX];\nfor (int i = 0; i < n; i++) {\nif (s[i] == '0') {\na[m++] = i;\n}\n}\nint tot1 = n - m;\na[m] = n; // 哨兵\nint i = 0; // >= left 的第一个 0 的下标是 a[i]\nfor (int left = 0; left < n; left++) {\nif (s[left] == '1') {\nans += a[i] - left; // 不含 0 的子串个数\n}\nfor (int k = i; k < m; k++) {\nint cnt0 = k - i + 1;\nif (cnt0 > tot1) {\nbreak;\n}\nint cnt1 = a[k] - left - (k - i);\nans += _____ ;\n}\nif (s[left] == '0') {\ni++; // 这个 0 后面不会再枚举到了\n}\n}\nreturn ans;\n}\n\n\n## How to find the number of elements in a linked list in Java?\n\n### 题目描述\n\nA linked list is called palindrome if it is symmetric to the first half. Write a function that checks if a linked list is palindrome or not.\nPlease note that the time and space complexity for the function should be O", "groundtruth": "class Solution {    public int numberOfSubstrings(String S) {        char[] s = S.toCharArray();        int n = s.length;        int m = 0;        int[] a = new int[n + 1];        for (int i = 0; i < n; i++) {            if (s[i] == '0') {                a[m++] = i;            }        }        int tot1 = n - m;        a[m] = n; // 哨兵        int ans = 0;        int i = 0; // >= left 的第一个 0 的下标是 a[i]        for (int left = 0; left < n; left++) {            if (s[left] == '1') {                ans += a[i] - left; // 不含 0 的子串个数            }            for (int k = i; k < m; k++) {                int cnt0 = k - i + 1;                if (cnt0 * cnt0 > tot1) {                    break;                }                int cnt1 = a[k] - left - (k - i);                ans += Math.max(a[k + 1] - a[k] - Math.max(cnt0 * cnt0 - cnt1, 0), 0);            }            if (s[left] == '0') {                i++; // 这个 0 后面不会再枚举到了            }        }        return ans;    }}"}
{"task_id": "java/6", "content": "\nIn our answer below, ______ stands for the statement that the answer is YES if _____, and that is NO otherwise.\n```\n\n__`dfs()`__ 函数可以将 __`i`__ 赋值给 __`j`__, 则会将 __`j`__ 的 `vis` 标记修改为 `true`, 但此时的 `vis` 还未更新.\n__`for`__ 循环不改变 `i`.\n\n```java\nif (y1 <= Y && Math.abs(x1 - X) <= r1 ||\n    x1 <= X && y1 <= r1 ||\n    x1 > X && inCircle(x1, y1, r1, X, 0)) {\n    return true;\n}\n```\n\n当圆心在左下角时, 点 (0,0) 到边界相交.\n```java\nelse if (j == i || ______) { // 圆 i 包含了其他圆\n    return false;\n}\n```\n\n当圆心在右上角时, 点 (X,Y) 到边界相交.\n```java\nvis[i] = true;\n```\n\n__`vis`__ 数组用于表示 __`circle`__ 是否包含了其他圆, `false` 表示没有. `false` 状态会被判断掉, `true` 表示包含其他圆.\n```java\nprivate boolean dfs(int i, int X, int Y, int[][] circles, boolean[] vis) {\n    long x1 = circles[i][0], y1 = circles[i][1], r1 = circles[i][2];\n    vis[i] = true;\n    for (int j = 0; j < circles.length; j++) {\n        long x2 = circles[j][0], y2 = circles[j][1], r2 = circles[j][2];\n        // 在两圆相交相切的前提下，点 A 是否严格在矩形内\n        if (Math.abs(x2 - x1) <= r1 + r2 && Math.abs(y2 - y1) <= r1 + r2 &&\n            inCircle(x2, y2, r2, x1, y1) &&\n            Math.min(r1 + r2, Math.min(x", "groundtruth": "class Solution {\n    public boolean canReachCorner(int X, int Y, int[][] circles) {\n        boolean[] vis = new boolean[circles.length];\n        for (int i = 0; i < circles.length; i++) {\n            long x = circles[i][0], y = circles[i][1], r = circles[i][2];\n            if (inCircle(x, y, r, 0, 0) || // 圆 i 包含矩形左下角\n                inCircle(x, y, r, X, Y) || // 圆 i 包含矩形右上角\n                // 圆 i 是否与矩形上边界/左边界相交相切\n                !vis[i] && (x <= X && Math.abs(y - Y) <= r ||\n                            y <= Y && x <= r ||\n                            y > Y && inCircle(x, y, r, 0, Y)) && dfs(i, X, Y, circles, vis)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n    private boolean inCircle(long ox, long oy, long r, long x, long y) {\n        return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r;\n    }\n\n    private boolean dfs(int i, int X, int Y, int[][] circles, boolean[] vis) {\n        long x1 = circles[i][0], y1 = circles[i][1], r1 = circles[i][2];\n        // 圆 i 是否与矩形右边界/下边界相交相切\n        if (y1 <= Y && Math.abs(x1 - X) <= r1 ||\n            x1 <= X && y1 <= r1 ||\n            x1 > X && inCircle(x1, y1, r1, X, 0)) {\n            return true;\n        }\n        vis[i] = true;\n        for (int j = 0; j < circles.length; j++) {\n            long x2 = circles[j][0], y2 = circles[j][1], r2 = circles[j][2];\n            // 在两圆相交相切的前提下，点 A 是否严格在矩形内\n            if (!vis[j] &&\n                (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) &&\n                x1 * r2 + x2 * r1 < (r1 + r2) * X &&\n                y1 * r2 + y2 * r1 < (r1 + r2) * Y &&\n                dfs(j, X, Y, circles, vis)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"task_id": "java/7", "content": "Write the completed code on an empty line. Then, input two integers, n and m, separated by a space, and output an integer according to the description.\nThe program can be compiled and run by using the following commands in the terminal:\njavac -encoding UTF-8 flowerGame.java\njava flowerGame < input.txt\n\n*/\n\n\nclass Solution {\n    public long flowerGame(int n, int m) {\n        return n * (m + 1) / 2 + (m + 1) * (n / 2);\n    }\n}/solutions/26-remove-element.cpp\n/*\nAuthor:  \nDate: 27/4/18\nProblem Link: https://leetcode.com/problems/remove-element/description/\nProblem: Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn't matter what you leave beyond the new length.\nExample:\nGiven nums = [3,2,2,3], val = 3,\nYour function should return length = 2, with the first two elements of nums being 2.\n*/\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint removeElement(vector<int>& nums, int val) {\n    int last_index = nums.size() - 1;\n    int curr_index = 0;\n    int removed_count = 0;\n    while (curr_index <= last_index) {\n        if (nums[curr_index] == val) {\n            swap(nums[curr_index], nums[last_index - removed_count]);\n            removed_count++;\n        }\n        curr_index++;\n    }\n    return nums.size() - removed_count;\n}/solutions/03-longest-substring-without-repeating-characters.cpp\n/*\nAuthor:  \nDate: 19/4/18\nProblem Link: https://leetcode.com/problems/longest-substring-without-repeating-characters/description/\nProblem: Given a string, find the length of the longest substring without repeating characters", "groundtruth": "class Solution {\n    public long flowerGame(int n, int m) {\n        long a = ((long)n/2) * ((long)m-((long)m/2));\n        long b = ((long)m/2) * ((long)n-((long)n/2));\n        return a + b;\n    }\n}\n"}
{"task_id": "java/8", "content": "\nExample 1:\nInput: nums = [5,6,1], k = 1\nOutput: 6\nExplanation: You can replace:\n- 5 with 2 OR 3 OR 6\n- 6 with 2 OR 3 OR 6\n- 1 with 2 OR 3 OR 6\nSince 2 OR 3 OR 6 = 6, the bitwise OR of the remaining elements of nums is 6.\nNote that it can be proven that 6 is the minimum possible value of the bitwise OR of the remaining elements of nums.\n\nExample 2:\nInput: nums = [3,1,3,8], k = 3\nOutput: 14\nExplanation: You can replace:\n- 3 with 0 OR 1 OR 2 OR 3 OR 4 OR 5 OR 6 OR 7 OR 8\n- 1 with 0 OR 1 OR 2 OR 3 OR 4 OR 5 OR 6 OR 7 OR 8\n- 3 with 0 OR 1 OR 2 OR 3 OR 4 OR 5 OR 6 OR 7 OR 8\nThe bitwise OR of the remaining elements of nums is 7 ^ 6 ^ 8 = 14.\n\nConstraints:\n1 <= nums.length <= 2 * 105\n1 <= nums[i] <= 216\n0 <= k <= nums.length - 1\n*/\n\n/*\nhttps://leetcode-cn.com/problems/minimum-bit-flips-to-convert-number/solution/java-bing-cha-ji-de-dong-tai-gui-hua-by-1287569166/\n*/\n\n// dp[x] 代表最小位运算数，x 代表二进制中 1 的个数。\nclass Solution {\n  public int minOr(int[] nums, int k) {\n    int[] dp = new int[22];\n    Arrays.fill(dp, 1 << 20);\n    dp[0] = 0;\n    for (int i = 0; i < nums.length; i++) {\n      int x = 0;\n      int mask = 0;\n      for (int j = 20; j >= ", "groundtruth": "class Solution {\n    public int minOrAfterOperations(int[] nums, int k) {\n        int ans = 0;\n        int mask = 0;\n        for (int b = 29; b >= 0; b--) {\n            mask |= 1 << b;\n            int cnt = 0; // 操作次数\n            int and = -1; // -1 的二进制全为 1\n            for (int x : nums) {\n                and &= x & mask;\n                if (and != 0) {\n                    cnt++; // 合并 x，操作次数加一\n                } else {\n                    and = -1; // 准备合并下一段\n                }\n            }\n            if (cnt > k) {\n                ans |= 1 << b; // 答案的这个比特位必须是 1\n                mask ^= 1 << b; // 后面不考虑这个比特位\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/9", "content": "\n### Sample test case\n\n#### Test case 1\nn: 3\nx: 1\ny: 3\n##### Expected output\n[1, 2, 1]\n##### Input\n\n\n#### Test case 2\nn: 5\nx: 2\ny: 5\n##### Expected output\n[0, 0, 2, 0, 1]\n##### Input\n\n\n#### Test case 3\nn: 5\nx: 5\ny: 2\n##### Expected output\n[3, 1, 0, 0, 1]\n##### Input\n\n\n### Constraints\n\n-   1 <= n <= 1000\n-   1 <= x <= n\n-   x!= y\n-   1 <= y <= nd(\"Hello\")\nprint a.name  # 输出Hello\na.test()  # 调用test()函数\n\n# 下面是从父类继承方法的例子:\nclass Parent:        # 定义父类\n    def parentMethod(self):\n        print ('调用父类方法')\n\nclass Child(Parent): # 定义子类\n    def childMethod(self):\n        print ('调用子类方法')\n\nc = Child()          # 实例化子类\nc.childMethod()      # 子类调用重写方法\nc.parentMethod()     # 父类调用父类方法\nsuper(Child,c).childMethod() # 用子类对象调用父类已被覆盖的方法\n\n# 实例方法\n# 在类的内部，方法与普通函数只有一个特别的区别——它们必须有一个额外的第一个参数名称，按照惯例它的名称是self。\n# 实例方法的第一个参数一定是实例对象本身，按照约定俗成的规定，此参数名称以self表示。因此，调用实例方法时，\n# 不能有任何传入self参数，只传递相关的形参就可以了。实例方法有两个实例：第一种是类的实例方法；\n# 另一种是静态方法。实例方法可以直接通过实例进行调用，也可以通过类调用。\n# 类的实例方法：\nclass A(object):\n    def foo(self):\n        print(\"instance method\")\n    @staticmethod\n    def bar():\n        print(\"static method\")\n    @classmethod\n   ", "groundtruth": "class Solution {\n    public int[] countOfPairs(int n, int x, int y) {\n        int w[][] = new int[n + 1][n + 1];\n        int INF = Integer.MAX_VALUE / 2;\n        //初始化 邻接矩阵。\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                w[i][j] = (i == j ? 0 : INF);\n        //额外的捷径的权值是1。但不能是自身到自身，因为自身到自身的权值本来就是0.\n        if (x != y) {\n            w[x][y] = 1;\n            w[y][x] = 1;\n        }\n        //建图，前后相邻 权值都是1。\n        for (int i = 1; i < n; i++) {\n            w[i][i + 1] = 1;\n            w[i + 1][i] = 1;\n        }\n        //佛洛依德算法\n        for (int p = 1; p <= n; p++)\n            for (int st = 1; st <= n; st++)\n                for (int end = 1; end <= n; end++)\n                    w[st][end] = Math.min(w[st][end], w[st][p] + w[p][end]);\n        //先用下标从0开始的数组来求结果。\n        int[] res = new int[n + 1];\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                if (w[i][j] != INF)\n                    res[w[i][j]]++;\n        //最终再遍历一次把求得的结果放到 下标从1开始的result数组。\n        int[] result  = new int[n];\n        for (int i = 0; i < n; i++)\n            result[i] = res[i + 1];\n        return result;\n    }\n}\n"}
{"task_id": "java/10", "content": "The correct output will be the number of ways to type each string. For example, consider \"aa\", the string can be typed in different ways like [aa] or [a][a]. So the number of ways to type \"aa\" should be 2. Similarly, consider \"bb\", there will be 1 way to type \"bb\" in two ways like [bb] or [b][b].\n\n# Test case 1\nThe input:\n```\n    [\"aa\", \"bb\", \"cc\", \"dd\", \"ee\"]\n```\nThe expected output:\n```\n    [2, 2, 1, 1, 0]\n```\n# Test case 2\nThe input:\n```\n    [\"a\"]\n```\nThe expected output:\n```\n    [1]\n```\n\n# Test case 3\nThe input:\n```\n    [\"aaaa\", \"bbb\"]\n```\nThe expected output:\n```\n    [2, 1]\n```package src;\n\nimport java.util.*;\npublic class Solution {\n    public int[] countOfPairs(int n, int x, int y) {\n        int[][] w = new int[n + 1][n + 1];\n        int INF = Integer.MAX_VALUE / 2;\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                w[i][j] = (i == j? 0 : INF);\n        if (x!= y) {\n            w[x][y] = 1;\n            w[y][x] = 1;\n        }\n        for (int i = 1; i < n; i++) {\n            w[i][i + 1] = 1;\n            w[i + 1][i] = 1;\n        }\n        for (int p = 1; p <= n; p++)\n            for (int st = 1; st <= n; st++)\n                for (int end = 1; end <= n; end++)\n                    w[st][end] = Math.min(w[st][end], w[st][p] + w[p][end]);\n        int[] res = new int[n + 1];\n        for (int i = 1; i <= n; i++)\n            for (int j =", "groundtruth": "class Solution {\n    public int[] countOfPairs(int n, int x, int y) {\n        int w[][] = new int[n + 1][n + 1];\n        int INF = Integer.MAX_VALUE / 2;\n        \n        //初始化 邻接矩阵。\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                w[i][j] = (i == j ? 0 : INF);\n\n        //额外的捷径的权值是1。但不能是自身到自身，因为自身到自身的权值本来就是0.\n        if (x != y) {\n            w[x][y] = 1;\n            w[y][x] = 1;\n        }\n\n        //建图，前后相邻 权值都是1。\n        for (int i = 1; i < n; i++) {\n            w[i][i + 1] = 1;\n            w[i + 1][i] = 1;\n        }\n\n        //佛洛依德算法\n        for (int p = 1; p <= n; p++)\n            for (int st = 1; st <= n; st++)\n                for (int end = 1; end <= n; end++)\n                    w[st][end] = Math.min(w[st][end], w[st][p] + w[p][end]);\n\n        //先用下标从0开始的数组来求结果。\n        int[] res = new int[n + 1];\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                if (w[i][j] != INF)\n                    res[w[i][j]]++;\n\n        //最终再遍历一次把求得的结果放到 下标从1开始的result数组。\n        int[] result  = new int[n];\n        for (int i = 0; i < n; i++)\n            result[i] = res[i + 1];\n\n        return result;\n    }\n}\n"}
{"task_id": "java/11", "content": "\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109\n\nInput: nums = [1,3,5]\nOutput: true\nExplanation: The given array can be permuted as: [5,3,1]\n```\n/src/main/java/com/leetcode/binarytree/PostOrderTraversal.java\npackage com.leetcode.binarytree;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Deque;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\n\r\nimport com.leetcode.bean.TreeNode;\r\n\r\n/**\r\n * \r\n * 145\r\n * https://leetcode-cn.com/problems/binary-tree-postorder-traversal/\r\n * \r\n * @author zhaoxin\r\n *\r\n */\r\npublic class PostOrderTraversal {\r\n\r\n\tpublic List<Integer> postorderTraversal(TreeNode root) {\r\n\t\tList<Integer> result = new ArrayList<>();\r\n\t\tDeque<TreeNode> stack = new LinkedList<>();\r\n\t\tstack.offer(root);\r\n\r\n\t\twhile (!stack.isEmpty()) {\r\n\t\t\tTreeNode node = stack.pollLast();\r\n\t\t\tif (node == null)\r\n\t\t\t\tcontinue;\r\n\t\t\tresult.add(node.val);\r\n\t\t\tstack.offer(node.left);\r\n\t\t\tstack.offer(node.right);\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\tpublic List<Integer> postorderTraversal2(TreeNode root) {\r\n\t\tList<Integer> result = new ArrayList<>();\r\n\t\tif (root == null)\r\n\t\t\treturn result;\r\n\t\tpostorderTraversalHelper(result, root);\r\n\t\treturn result;\r\n\t}\r\n\r\n\tprivate void postorderTraversalHelper(List<Integer> result, TreeNode node) {\r\n\t\tif (node == null)\r\n\t\t\treturn;\r\n\t\tpostorderTraversalHelper(result, node.left);\r\n\t\tpostorderTraversalHelper(result, node.right);\r\n\t\tresult.add(node.val);\r\n\t}\r\n}\r\ne;\r\n\t}\r\n}\r\n/src/main/java/com/leetcode/dynamic/UniquePaths.java\npackage com.leetcode.dynamic;\r\n\r\n/**\r\n * \r\n * 62\r\n * https://leetcode-cn.com/problems/unique-paths/\r\n * \r\n", "groundtruth": "class Solution {\n    public boolean canSortArray(int[] nums) {\n        int lastCnt = 0;\n        int lastGroupMax = 0;\n        int curGroupMax = 0;\n        for (int num : nums) {\n            int curCnt = Integer.bitCount(num);\n            if (curCnt == lastCnt) {\n                curGroupMax = Math.max(curGroupMax, num);\n            } else {\n                lastCnt = curCnt;\n                lastGroupMax = curGroupMax;\n                curGroupMax = num;\n            }\n            if (num < lastGroupMax) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "java/12", "content": "The input to the function/method consists of one argument, nums, a 0-indexed array of integers.\nDo not modify the value of the input array nums.\nConstraints\n0 <= nums.length <= 100\n1 <= nums[i] <= 109\n\nSample Test Cases\nSample Case 0\nInput\n[3, 2, 4]\nOutput\n2\nExplanation\nWe perform the following operation twice:\n\nInsert x = 3%2 = 1 at the end of nums.\nWe are left with nums = [3, 2, 4, 1]\n\nInsert x = 2%4 = 2 at the end of nums.\nWe are left with nums = [3, 2, 4, 1, 2]\n\nInsert x = 4%3 = 1 at the end of nums.\nWe are left with nums = [3, 2, 4, 1, 2, 1]\n\nSo, nums = [3, 2, 4, 1, 2, 1], with length 6.\n\nSample Case 1\nInput\n[3, 4, 6, 2, 1, 1, 6]\nOutput\n4\nExplanation\nWe perform the following operation once:\n\nInsert x = 3%6 = 3 at the end of nums.\nWe are left with nums = [3, 4, 6, 2, 1, 1, 6, 3]\n\nInsert x = 4%6 = 4 at the end of nums.\nWe are left with nums = [3, 4, 6, 2, 1, 1, 6, 3, 4]\n\nInsert x = 6%2 = 0 at the end of nums.\nWe are left with nums = [3, 4, 6, 2, 1, 1, 6, 3, 4, 0]\n\nInsert x = 2%1 = 0 at the end of nums.\nWe are left with nums = [3, 4, 6, 2, 1, 1, 6, 3, 4, 0, 0]\n\nSo, nums = [3", "groundtruth": "class Solution {\n    public int minimumArrayLength(int[] nums) {\n        int m = Integer.MAX_VALUE;\n        for (int x : nums) {\n            m = Math.min(m, x);\n        }\n\n        for (int x : nums) {\n            if (x % m > 0) {\n                return 1;\n            }\n        }\n\n        int cnt = 0;\n        for (int x : nums) {\n            if (x == m) {\n                cnt++;\n            }\n        }\n        return (cnt + 1) / 2;\n    }\n}\n"}
{"task_id": "java/13", "content": "```\n\n```java\nclass Solution {\n    public long minimumCost(int[] nums, int k, int dist) {\n        k--;\n        sumL = nums[0];\n        for (int i = 1; i < dist + 2; i++) {\n            sumL += nums[i];\n            L.merge(nums[i], 1, Integer::sum);\n        }\n        sizeL = dist + 1;\n        while (sizeL > k) {\n            l2r();\n        }\n\n        long ans = sumL;\n        for (int i = dist + 2; i < nums.length; i++) {\n            // 移除 out\n            int out = nums[i - dist - 1];\n            if (L.containsKey(out)) {\n                sumL -= out;\n                sizeL--;\n                L.merge(out, 1, Integer::sum);\n            } else {\n                R.merge(out, 1, Integer::sum);\n            }\n\n            // 添加 in\n            int in = nums[i];\n            if (in < L.lastKey()) {\n                sumL += in;\n                sizeL++;\n                L.merge(in, 1, Integer::sum);\n            } else {\n                R.merge(in, 1, Integer::sum);\n            }\n\n            // 维护大小\n            if (sizeL == k - 1) {\n                r2l();\n            } else if (sizeL == k + 1) {\n                l2r();\n            }\n\n            ans = Math.min(ans, sumL);\n        }\n        return ans;\n    }\n\n    private long sumL;\n    private int sizeL;\n    private final TreeMap<Integer, Integer> L = new TreeMap<>();\n    private final TreeMap<Integer, Integer> R = new TreeMap<>();\n\n    private void l2r() {\n        int x = L.lastKey();\n        removeOne(L, x);\n        sumL -= x;\n        sizeL--;\n        R.merge(x, 1, Integer::sum);\n    }\n\n    private void r2l() {\n        int x = R.firstKey();\n        removeOne(R, x);\n        sumL += x;\n        sizeL++;\n        L.merge(x, 1, Integer::sum);\n    }\n\n    private void removeOne(Map<Integer, Integer> m, int x) {\n        int cnt = m.get(x);\n        if (cnt > ", "groundtruth": "class Solution {\n    public long minimumCost(int[] nums, int k, int dist) {\n        k--;\n        sumL = nums[0];\n        for (int i = 1; i < dist + 2; i++) {\n            sumL += nums[i];\n            L.merge(nums[i], 1, Integer::sum);\n        }\n        sizeL = dist + 1;\n        while (sizeL > k) {\n            l2r();\n        }\n\n        long ans = sumL;\n        for (int i = dist + 2; i < nums.length; i++) {\n            // 移除 out\n            int out = nums[i - dist - 1];\n            if (L.containsKey(out)) {\n                sumL -= out;\n                sizeL--;\n                removeOne(L, out);\n            } else {\n                removeOne(R, out);\n            }\n\n            // 添加 in\n            int in = nums[i];\n            if (in < L.lastKey()) {\n                sumL += in;\n                sizeL++;\n                L.merge(in, 1, Integer::sum);\n            } else {\n                R.merge(in, 1, Integer::sum);\n            }\n\n            // 维护大小\n            if (sizeL == k - 1) {\n                r2l();\n            } else if (sizeL == k + 1) {\n                l2r();\n            }\n\n            ans = Math.min(ans, sumL);\n        }\n        return ans;\n    }\n\n    private long sumL;\n    private int sizeL;\n    private final TreeMap<Integer, Integer> L = new TreeMap<>();\n    private final TreeMap<Integer, Integer> R = new TreeMap<>();\n\n    private void l2r() {\n        int x = L.lastKey();\n        removeOne(L, x);\n        sumL -= x;\n        sizeL--;\n        R.merge(x, 1, Integer::sum);\n    }\n\n    private void r2l() {\n        int x = R.firstKey();\n        removeOne(R, x);\n        sumL += x;\n        sizeL++;\n        L.merge(x, 1, Integer::sum);\n    }\n\n    private void removeOne(Map<Integer, Integer> m, int x) {\n        int cnt = m.get(x);\n        if (cnt > 1) {\n            m.put(x, cnt - 1);\n        } else {\n            m.remove(x);\n        }\n    }\n}\n"}
{"task_id": "java/14", "content": "Please fill in the following incomplete code according to the description. The description is as follows:\nYou are given a 0-indexed string s, a string a, a string b, and an integer k. An index i is beautiful if: 0 <= i <= s.length - a.length s[i..(i + a.length - 1)] == a There exists an index j such that: 0 <= j <= s.length - b.length s[j..(j + b.length - 1)] == b |j - i| <= k Return the array that contains beautiful indices in sorted order from smallest to largest.\nThe incomplete code is as follows:\nclass Solution {\n    public List<Integer> beautifulIndices(String s, String a, String b, int k) {\n        char[] text = s.toCharArray();\n        List<Integer> posA = kmp(text, a.toCharArray());\n        List<Integer> posB = kmp(text, b.toCharArray());\n\n        List<Integer> ans = new ArrayList<>();\n        for (int i : posA) {\n            int bi = ____ ;\n            if (bi < posB.size() && posB.get(bi) - i <= k ||\n                bi > 0 && i - posB.get(bi - 1) <= k) {\n                ans.add(i);\n            }\n        }\n        return ans;\n    }\n\n    private List<Integer> kmp(char[] text, char[] pattern) {\n        int m = pattern.length;\n        int[] pi = new int[m];\n        int c = 0;\n        for (int i = 1; i < m; i++) {\n            char v = pattern[i];\n            while (c > 0 && pattern[c]!= v) {\n                c = pi[c - 1];\n            }\n            if (pattern[c] == v) {\n                c++;\n            }\n            pi[i] = c;\n        }\n\n        List<Integer> res = new ArrayList<>();\n        c = 0;\n        for (int i = 0; i < text.length; i++) {\n            char v = text[i];\n            while (c > 0 && pattern[c]!= v) {\n                c = pi[c - 1];\n            }\n            if (pattern[c] == v) {\n                c++;\n            }\n            if (c", "groundtruth": "class Solution {\n    public List<Integer> beautifulIndices(String s, String a, String b, int k) {\n        char[] text = s.toCharArray();\n        List<Integer> posA = kmp(text, a.toCharArray());\n        List<Integer> posB = kmp(text, b.toCharArray());\n\n        List<Integer> ans = new ArrayList<>();\n        for (int i : posA) {\n            int bi = lowerBound(posB, i);\n            if (bi < posB.size() && posB.get(bi) - i <= k ||\n                bi > 0 && i - posB.get(bi - 1) <= k) {\n                ans.add(i);\n            }\n        }\n        return ans;\n    }\n\n    private List<Integer> kmp(char[] text, char[] pattern) {\n        int m = pattern.length;\n        int[] pi = new int[m];\n        int c = 0;\n        for (int i = 1; i < m; i++) {\n            char v = pattern[i];\n            while (c > 0 && pattern[c] != v) {\n                c = pi[c - 1];\n            }\n            if (pattern[c] == v) {\n                c++;\n            }\n            pi[i] = c;\n        }\n\n        List<Integer> res = new ArrayList<>();\n        c = 0;\n        for (int i = 0; i < text.length; i++) {\n            char v = text[i];\n            while (c > 0 && pattern[c] != v) {\n                c = pi[c - 1];\n            }\n            if (pattern[c] == v) {\n                c++;\n            }\n            if (c == m) {\n                res.add(i - m + 1);\n                c = pi[c - 1];\n            }\n        }\n        return res;\n    }\n\n    // 开区间写法\n    private int lowerBound(List<Integer> nums, int target) {\n        int left = -1, right = nums.size(); // 开区间 (left, right)\n        while (left + 1 < right) { // 区间不为空\n            // 循环不变量：\n            // nums[left] < target\n            // nums[right] >= target\n            int mid = (left + right) >>> 1;\n            if (nums.get(mid) < target) {\n                left = mid; // 范围缩小到 (mid, right)\n            } else {\n                right = mid; // 范围缩小到 (left, mid)\n            }\n        }\n        return right;\n    }\n}\n"}
{"task_id": "java/15", "content": "The judge program will print a list of lines which include your answer after inputting the given parameters and the desired answer. You are not responsible for the content of these lines.\nTo output the list of lines, you can use System.out.println(String) with parameters of type String.\nNote:\n1 <= x <= 60\nk <= 2^63 / 10\nThe judge programs use standard C++ to compile your code.\nThe judge program will run your code for any k and x in your own judge program./leetcode/contest/175/B. Count Good Meals.cpp\nclass Solution {\npublic:\n    int countPairs(vector<int>& deliciousness) {\n        int mod = 1e9 + 7;\n        unordered_map<int, int> c;\n        for (auto i: deliciousness) {\n            for (int p = 1; i * 2 <= p << 8; p *= 2) {\n                int m = i - p;\n                c[m] += 1;\n            }\n        }\n        long res = 0;\n        for (auto [d, cnt]: c) {\n            res += cnt * (cnt - 1) / 2;\n        }\n        return res % mod;\n    }\n};/leetcode/contest/333/A. Tandem Bicycle.cpp\nclass Solution {\npublic:\n    int maxSpeed(vector<int>& arr, int diff) {\n        vector<int> dp(arr.size(), -1);\n        dp[0] = arr[0];\n        for (int i = 1; i < arr.size(); i++) {\n            if (arr[i] - arr[i-1] <= diff) {\n                dp[i] = min(dp[i-1], arr[i]);\n            } else {\n                dp[i] = min(dp[i-1], arr[i] + diff);\n            }\n        }\n        return dp.back();\n    }\n};/leetcode/contest/297/B. Shifting Letters.py\nclass Solution:\n    def shiftingLetters(self, s: str, shifts: List[int]) -> str:\n        n = len(shifts)\n        s = list(s)\n        for i in range(n-1, -1,", "groundtruth": "class Solution {\n    public long findMaximumNumber(long k, int x) {\n        this.x = x;\n        long left = 0;\n        long right = (k + 1) << x;\n        while (left + 1 < right) {\n            long mid = (left + right) >>> 1;\n            if (countDigitOne(mid) <= k) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n\n    private int x;\n    private long num;\n    private long memo[][];\n\n    private long countDigitOne(long num) {\n        this.num = num;\n        int m = 64 - Long.numberOfLeadingZeros(num);\n        memo = new long[m][m + 1];\n        for (long[] row : memo) {\n            Arrays.fill(row, -1);\n        }\n        return dfs(m - 1, 0, true);\n    }\n\n    private long dfs(int i, int cnt1, boolean isLimit) {\n        if (i < 0) return cnt1;\n        if (!isLimit && memo[i][cnt1] != -1) return memo[i][cnt1];\n        int up = isLimit ? (int) (num >> i & 1) : 1;\n        long res = 0;\n        for (int d = 0; d <= up; d++) {\n            res += dfs(i - 1, cnt1 + (d == 1 && (i + 1) % x == 0 ? 1 : 0), isLimit && d == up);\n        }\n        if (!isLimit) memo[i][cnt1] = res;\n        return res;\n    }\n}\n"}
{"task_id": "java/16", "content": "\nTest 1:\nInput: n = 1\nOutput: [\"0\", \"1\"]\nExpected: [\"0\", \"1\"]\n\nTest 2:\nInput: n = 2\nOutput: [\"00\", \"01\", \"10\", \"11\"]\nExpected: [\"00\", \"01\", \"10\", \"11\"]\n*/\n\n/**\n * Approach:\n * We iterate over all the possible substrings.\n * The two conditions of a valid string are:\n * 1. The two substrings, that we have added to our answer so far, must contain a 1.\n * 2. If the number of 1's in the substring is odd, then we can add a 1 to the string\n * at this position.\n * 3. If the string is the same as 00 or 11, then we just return \"0\" or \"1\".\n */\n\nclass Solution {\n    public List<String> validStrings(int n) {\n        List<String> ans = new ArrayList<>();\n        int mask = (int)(Math.pow(2, n) - 1);\n        for (int i = 0; i < (1 << n); i++) {\n            int x = mask ^ i;\n            if (((x >> 1) & x) == 0) {\n                int ones = 0;\n                for (int j = 0; j < n; j++) {\n                    if ((x & (1 << j)) == 0) {\n                        ones++;\n                        if (ones % 2 == 0) {\n                            ans.add(Integer.toBinaryString((1 << n) | i).substring(1));\n                        }\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n}\n/leetcode/104_maximum_depth_of_binary_tree.cpp\n/**\n * Question: Given a binary tree, find its maximum depth.\n * The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n * Note: A leaf is a node with no children.\n * \n * Example:\n * Given binary tree [3,9,20,null,null,15,7],\n *   3\n *  / \\\n * 9  20\n *  ", "groundtruth": "class Solution {\n    public List<String> validStrings(int n) {\n        List<String> ans = new ArrayList<>();\n        int mask = (1 << n) - 1;\n        for (int i = 0; i < (1 << n); i++) {\n            int x = mask ^ i;\n            if (((x >> 1) & x) == 0) {\n                ans.add(Integer.toBinaryString((1 << n) | i).substring(1));\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/17", "content": " */\n\nclass Solution {\n    public int numberOfSubmatrices(char[][] grid) {\n        int ans = 0;\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] sum = new int[m + 1][n + 1];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                sum[i + 1][j + 1] = ____  + sum[i][j + 1] - sum[i][j];\n                if (_____) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}/*\n1479. 能到达所有点的最少点数目\n给你一个数组 points ，其中 points[i] = [xi, yi] ，返回到达所有点所需要的 最少 点数目。\n你可以 随意 选择 开始和结束位置（开始和结束位置也需要考虑进内），请你返回你到达所有点所需的 最少 点数目。\n\n\n\n示例 1：\n\n输入：points = [[1,1],[3,4],[-1,0]]\n输出：7\n解释：所有点都可以到达，需要 7 个点来完成。\n你可以选择路径 1->2->-1->0，也可以选择路径 1->3->-1->0 。\n\n\n示例 2：\n\n输入：points = [[3,12],[-2,5],[-4,1]]\n输出：10\n\n\n示例 3：\n\n输入：points = [[0,0],[1,1],[1,0],[-1,1]]\n输出：4\n\n\n示例 4：\n\n输入：points = [[-1000000,-1000000],[1000000,1000000]]\n输出：4\n\n\n示例 5：\n\n输入：points = [[0,0]]\n输出：1\n\n\n提示：\n\n1 <= points.length <= 105\npoints[i].length == 2\n-109 <= xi, yi <= 109\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode", "groundtruth": "class Solution {\n    public int numberOfSubmatrices(char[][] grid) {\n        int ans = 0;\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][][] sum = new int[m + 1][n + 1][2];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                sum[i + 1][j + 1][0] = sum[i + 1][j][0] + sum[i][j + 1][0] - sum[i][j][0];\n                sum[i + 1][j + 1][1] = sum[i + 1][j][1] + sum[i][j + 1][1] - sum[i][j][1];\n                if (grid[i][j] != '.') {\n                    sum[i + 1][j + 1][grid[i][j] & 1]++;\n                }\n                if (sum[i + 1][j + 1][0] > 0 && sum[i + 1][j + 1][0] == sum[i + 1][j + 1][1]) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/18", "content": "Example\nExample 1:\nInput: target = \"a\", words = [\"a\"], costs = [0]\nOutput: 0\nExplanation: In each iteration, use the first word in words, costing 0, to extend target from \"a\" to \"a\".\nExample 2:\nInput: target = \"ac\", words = [\"a\", \"c\"], costs = [2, 3]\nOutput: 1\nExplanation: Use the first word in words for the first character, costing 2 to extend target from \"a\" to \"ac\".\nExample 3:\nInput: target = \"abac\", words = [\"abc\", \"bca\"], costs = [10, 1]\nOutput: -1\nExplanation: It's impossible to extend target with any of the two words in words, because there is no way to make each\nword as a subsequence of target.\nExample 4:\nInput: target = \"abcabba\", words = [\"ab\",\"ba\"], costs = [3, 2]\nOutput: 2\nExplanation: The two possible scenarios are:\n1. a -> a: 3, b -> b: 2, a -> b: 1; cost = 3 + 2 + 1 = 6\n2. a -> b: 2, a -> b: 1, b -> b: 3, a -> a: 2; cost = 2 + 1 + 3 + 2 = 8\nIf we use the first scenario, we can get target's substring as \"ba\", which is \"ba\" in words[\"ba\"] so that we can\nextend target from the current string to the target. \nIf we use the second scenario, we can get target's substring as \"ab\", which is the only one can be a subsequence\nof \"abac\", we extend target from the current string to the target and return -1.\nChallenge\nYou are only given words, not numbers. Assume the numbers between 10 to 26 corresponds to the characters\n'a' to 'z', inclusive.\n*/\n\nclass Solution {\n    public int minimumCost(String target, String[] words, int[] costs) {\n        char[] t = target.toCharArray();\n        int n = t.length;\n\n        final int MOD = 1_070_777_777", "groundtruth": "class Solution {\n    public int minimumCost(String target, String[] words, int[] costs) {\n        char[] t = target.toCharArray();\n        int n = t.length;\n\n        final int MOD = 1_070_777_777;\n        final int BASE = (int) 8e8 + new Random().nextInt((int) 1e8);\n        int[] powBase = new int[n + 1];\n        int[] preHash = new int[n + 1];\n        powBase[0] = 1;\n        for (int i = 0; i < n; i++) {\n            powBase[i + 1] = (int) ((long) powBase[i] * BASE % MOD);\n            preHash[i + 1] = (int) (((long) preHash[i] * BASE + t[i]) % MOD);\n        }\n\n        Map<Integer, Map<Integer, Integer>> minCost = new TreeMap<>();\n        for (int i = 0; i < words.length; i++) {\n            long h = 0;\n            for (char b : words[i].toCharArray()) {\n                h = (h * BASE + b) % MOD;\n            }\n            minCost.computeIfAbsent(words[i].length(), k -> new HashMap<>())\n                   .merge((int) h, costs[i], Integer::min);\n        }\n\n        int[] f = new int[n + 1];\n        Arrays.fill(f, Integer.MAX_VALUE / 2);\n        f[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            for (Map.Entry<Integer, Map<Integer, Integer>> e : minCost.entrySet()) {\n                int len = e.getKey();\n                if (len > i) {\n                    break;\n                }\n                int subHash = (int) (((preHash[i] - (long) preHash[i - len] * powBase[len]) % MOD + MOD) % MOD);\n                f[i] = Math.min(f[i], f[i - len] + e.getValue().getOrDefault(subHash, Integer.MAX_VALUE / 2));\n            }\n        }\n        return f[n] == Integer.MAX_VALUE / 2 ? -1 : f[n];\n    }\n}\n"}
{"task_id": "java/19", "content": "\nDefinition for singly-linked list.\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\nl, 2);\n    }\n\n    @Test\n    public void test6() {\n        List<Integer> result = solution.searchRange(new int[]{5, 7, 7, 8, 8, 10}, 8);\n        Assert.assertEquals(2, result.get(0));\n        Assert.assertEquals(4, result.get(1));\n    }\n}\n/leetcode-java/src/test/java/com/xiaoxue/leetcode/exercise/ArrayBinarySearchTest.java\npackage com.xiaoxue.leetcode.exercise;\n\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.util.List;\n\npublic class ArrayBinarySearchTest {\n\n    ArrayBinarySearch solution;\n\n    @Before\n    public void setUp() {\n        solution = new ArrayBinarySearch();\n    }\n\n    @Test\n    public void test1() {\n        List<Integer> result = solution.searchRange(new int[]{5, 7, 7, 8, 8, 10}, 8);\n        Assert.assertEquals(3, result.get(0));\n        Assert.assertEquals(4, result.get(1));\n    }\n\n    @Test\n    public void test2() {\n        List<Integer> result = solution.searchRange(new int[]{-1, 0, 3, 5, 9, 12}, 9);\n        Assert.assertEquals(4, result.get(0));\n        Assert.assertEquals(4, result.get(1));\n    }\n\n    @Test\n    public void test3() {\n        List<Integer> result = solution.searchRange(new int[]{2, 2}, 2);\n        Assert.assertEquals(0, result.get(0));\n        Assert.assertEquals(1, result.get(1));\n    }\n\n    @Test\n    public void test4() {\n        List<Integer> result = solution.searchRange(new int[]{5, 7, 7, 8, 8, 10", "groundtruth": "class Solution {\n    public ListNode modifiedList(int[] nums, ListNode head) {\n        Set<Integer> set = new HashSet<>(nums.length); // 预分配空间\n        for (int x : nums) {\n            set.add(x);\n        }\n        ListNode dummy = new ListNode(0, head);\n        ListNode cur = dummy;\n        while (cur.next != null) {\n            if (set.contains(cur.next.val)) {\n                cur.next = cur.next.next; // 删除\n            } else {\n                cur = cur.next; // 向后移动\n            }\n        }\n        return dummy.next;\n    }\n}\n"}
{"task_id": "java/20", "content": "\nExample 1:\n\nInput: m = 2, n = 3, horizontalCuts = [1, 2, 4], verticalCuts = [1, 3]\nOutput: 4\nExplanation: The figure above represents the given cake and the cuts. Notice that the cuts are located at (1, 1), (1, 3), (3, 1), and (3, 3).\nThe minimum total cost needed to cut the cake into 1 x 1 pieces is 4.\nExample 2:\n\nInput: m = 5, n = 4, horizontalCuts = [3, 1], verticalCuts = [1]\nOutput: 6\nExplanation: The figure above represents the given cake and the cuts. Notice that the cuts are located at (1, 1) and (1, 3).\nThe minimum total cost needed to cut the cake into 1 x 1 pieces is 6.\nExplanation: \nThere is only one horizontal cut (blue) and one vertical cut (red).\nExample 3:\n\nInput: m = 5, n = 4, horizontalCuts = [3], verticalCuts = [3]\nOutput: 7\nExplanation: The figure above represents the given cake and the cuts. Notice that the cuts are located at (1, 1) and (1, 3).\nThe minimum total cost needed to cut the cake into 1 x 1 pieces is 7.\nExplanation: \nThere is only one horizontal cut (red) and one vertical cut (red).\nExample 4:\n\nInput: m = 4, n = 9, horizontalCuts = [1, 2, 4, 9], verticalCuts = [1, 3, 7]\nOutput: 13\nExplanation: The figure above represents the given cake and the cuts. Notice that the cuts are located at (1, 1), (2, 2), (4, 4), (1, 7), and (1, 9).\nThe minimum total cost needed to cut the cake into 1 x 1 pieces is 13.\nExample 5:\n\nInput: m = 2, n = 2, horizontalCuts =", "groundtruth": "class Solution {\n    public int minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {\n        int[][][][] dp = new int[m][n][m][n];\n        for (int i1 = 0; i1 < m; i1++) {\n            for (int j1 = 0; j1 < n; j1++) {\n                for (int i2 = 0; i2 < m; i2++) {\n                    Arrays.fill(dp[i1][j1][i2], Integer.MAX_VALUE);\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[i][j][i][j] = 0;\n            }\n        }\n        for (int rowCount = 1; rowCount <= m; rowCount++) {\n            for (int colCount = 1; colCount <= n; colCount++) {\n                for (int i1 = 0, i2 = rowCount - 1; i2 < m; i1++, i2++) {\n                    for (int j1 = 0, j2 = colCount - 1; j2 < n; j1++, j2++) {\n                        for (int midRow = i1; midRow < i2; midRow++) {\n                            dp[i1][j1][i2][j2] = Math.min(dp[i1][j1][i2][j2], horizontalCut[midRow] + dp[i1][j1][midRow][j2] + dp[midRow + 1][j1][i2][j2]);\n                        }\n                        for (int midCol = j1; midCol < j2; midCol++) {\n                            dp[i1][j1][i2][j2] = Math.min(dp[i1][j1][i2][j2], verticalCut[midCol] + dp[i1][j1][i2][midCol] + dp[i1][midCol + 1][i2][j2]);\n                        }\n                    }\n                }\n            }\n        }\n        return dp[0][0][m - 1][n - 1];\n    }\n}\n"}
{"task_id": "java/21", "content": "Sample Input #1:\n5\naabcde\nSample Output #1:\ntrue\nExplanation #1:\nAlice can delete any one of the two vowels at indices 0 or 1.\nSince Alice always goes first, Alice will be able to delete all of the vowels if she has the choice.\nSample Input #2:\n9\naaiaaiooa\nSample Output #2:\nfalse\nExplanation #2:\nBob must delete all of the vowels, but Alice has no vowels to delete.\nSo Bob will lose if she always goes first.\nExplanation #3:\nBoth players start out with 4 vowels.\nEven if Alice starts, Bob will remove all of the vowels as the following:\nBob has one vowel: o.\nAlice cannot play here because of her odd numbered removal.\nThen Bob can remove another vowel: o.\nAlice has no vowels left to play with.\nAlice loses.\n*/\nclass Solution {\n    public boolean doesAliceWin(String s) {\n        for (char c : s.toCharArray()) {\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                return true;\n            }\n        }\n        return false;\n    }\n}/*\nThere is a robot starting at the position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves.\n\nThe move sequence is represented by a string, and the character moves[i] represents its ith move. Valid moves are R (right), L (left), U (up), and D (down). If the robot returns to the origin after it finishes all of its moves, return true. Otherwise, return false.\n\nNote: The way that the robot is \"facing\" is irrelevant. \"R\" will always make the robot move to the right once, \"L\" will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move.\n\nExample 1:\nInput: \"UD\"\nOutput: true \nExplanation: The robot moves up once, and then down once. All moves have the same magnitude, so it", "groundtruth": "class Solution {\n    public boolean doesAliceWin(String s) {\n        for (char c : s.toCharArray()) {\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"task_id": "java/22", "content": "Constraints:\n2 <= s.length <= 105\ns[i] is either '0' or '1'.\nAccepted\n75.2K\nSubmissions\n271.4K\n'''\nclass Solution:\n    def maxOperations(self, s: str) -> int:\n        ans = 0\n        cnt1 = 0\n        s = [ord(c) - ord('0') for c in s]\n        for i in range(len(s)):\n            if s[i] == 1:\n                cnt1 += 1\n            else:\n                if i > 0 and s[i - 1] == 0:\n                    ans += cnt1\n        return ans'''\n2516. Count the Number of Beautiful Subarrays\nUser Accepted:29\nUser Tried:43\nTotal Accepted:32\nTotal Submissions:65\nA beautiful subarray of a binary array is a subarray that:\nIt is an odd-length array.\nThe number of 1's in the subarray is a perfect square.\nReturn the number of beautiful subarrays of s. Since the answer may be too large, return it modulo 109 + 7.\nA subarray is a contiguous non-empty sequence of elements within an array.\nThe following example will help you understand what a subarray is:\nExample 1:\nInput: s = [1,1,2,1,1]\nOutput: 8\nExplanation: The odd-length array of consecutive 1's are: [1,1,1,1], [1,1,2,1], and [1,2,1,1].\nTheir number of 1's is: 1, 2, and 3 respectively, making the total 8.\nIt can be shown that there are no odd-length arrays of consecutive 1's that contain more than three consecutive 1's.\nSo we return 8.\nExample 2:\nInput: s = [2,2,2,2,2]\nOutput: 0\nExplanation: There are no odd-length arrays of consecutive 1's in [2,2,2,2,2]. Thus, we return 0.\nExample 3:\nInput: s = [3,2,1,3,3,2,2,1]\n", "groundtruth": "class Solution {\n    public int maxOperations(String S) {\n        char[] s = S.toCharArray();\n        int ans = 0;\n        int cnt1 = 0;\n        for (int i = 0; i < s.length; i++) {\n            if (s[i] == '1') {\n                cnt1++;\n            } else if (i > 0 && s[i - 1] == '1') {\n                ans += cnt1;\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/23", "content": "The code is:\nclass Solution {\n    public long minimumOperations(int[] nums, int[] target) {\n        long s = target[0] - nums[0];\n        long ans = Math.abs(s);\n        for (int i = 1; i < nums.length; i++) {\n            int k = target[i] - target[i - 1] - (nums[i] - nums[i - 1]);\n            if (k > 0) {\n                ans += k;\n            } else {\n                ans -= Math.min(k + s, 0);\n            }\n            s += k;\n        }\n        return ans;\n    }\n}You are given a 0-indexed array coins of positive integers. You have an infinite supply of coins.\nThe array coins describes the available denominations of coins.\nReturn the smallest number of coins needed to make exactly amount of change. If it is not possible to make exactly amount of change, return -1.\nThe number of coins does not matter, so the answer can consist of multiple instances of the same coin.\nFor example, suppose we have coins = [1, 2, 5]. Then we can make change for 10 dollars: 1 x 5 + 1 x 5 + 1 x 2 + 1 x 2 + 1 x 1 + 1 x 1 + 1 x 1.\nThe denominations could also be [1, 2, 10]. Then we can make change for 10 dollars: 1 x 10.\nIf there are multiple combinations, you may return the one with the largest number of coins (and, if there is still a tie, with the smallest index in coins).\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        Integer[] cache = new Integer[amount + 1];\n        return coinChange(coins, amount, cache);\n    }\n\n    public int coinChange(int[] coins, int amount, Integer[] cache) {\n        if (amount < 0) {\n            return -1;\n        }\n        if (amount == 0) {\n            return 0;\n        }\n        if (cache[amount]!= null) {\n            return cache[amount];\n        }\n        int min = Integer.MAX_VALUE;\n        for (int coin : coins) {\n            int sub = coinChange", "groundtruth": "class Solution {\n    public long minimumOperations(int[] nums, int[] target) {\n        long s = target[0] - nums[0];\n        long ans = Math.abs(s);\n        for (int i = 1; i < nums.length; i++) {\n            int k = (target[i] - target[i - 1]) - (nums[i] - nums[i - 1]);\n            if (k > 0) {\n                ans += s >= 0 ? k : Math.max(k + s, 0);\n            } else {\n                ans -= s <= 0 ? k : Math.min(k + s, 0);\n            }\n            s += k;\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/24", "content": "Example\nGive l=2 and r=5. Return 4.\nThe numbers in the range [2, 5] that are not special are: 2, 3, 4, and 5.\nGiven l=20000 and r=21000. Return 8992.\nNote\nUse a brute force method is not allowed, you are required to achieve a result in O(n) time complexity, where n is the length of the range [l, r].\n */\n\nclass Main {\n    private static final int MX = 31622;\n    private static final int[] PI = new int[MX + 1];\n\n    static {\n        for (int i = 2; i <= MX; i++) {\n            if (PI[i] == 0) { // i 是质数\n                PI[i] = PI[i - 1] + 1;\n                for (int j = i * i; j <= MX; j += i) {\n                    PI[j] = -1; // 标记 i 的倍数为合数\n                }\n            } else {\n                PI[i] = PI[i - 1];\n            }\n        }\n    }\n\n    public int nonSpecialCount(int l, int r) {\n        int count = 0;\n        for (int i = l; i <= r; i++) {\n            if (PI[i]!= 2) {\n                count++;\n            }\n        }\n        return count;\n    }\n}/src/oj/leetcode/p1/Solution.java\npackage oj.leetcode.p1;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\n\npublic class Solution {\n//\t[3,2,1,5,6,4]\n\n\tprivate static String[] strings;\n\n\tpublic int solution(String[] s) {\n\t\tstrings = s;\n\t\tint[] res = new int[s.length];\n\t\tfor (int i = 0; i < s.length; i++) {\n\t\t\tres[i] = getOne(s[i]);\n\t\t}\n\t\treturn getMin(res);\n\t}", "groundtruth": "class Solution {\n    private static final int MX = 31622;\n    private static final int[] PI = new int[MX + 1];\n\n    static {\n        for (int i = 2; i <= MX; i++) {\n            if (PI[i] == 0) { // i 是质数\n                PI[i] = PI[i - 1] + 1;\n                for (int j = i * i; j <= MX; j += i) {\n                    PI[j] = -1; // 标记 i 的倍数为合数\n                }\n            } else {\n                PI[i] = PI[i - 1];\n            }\n        }\n    }\n\n    public int nonSpecialCount(int l, int r) {\n        return r - l + 1 - (PI[(int) Math.sqrt(r)] - PI[(int) Math.sqrt(l - 1)]);\n    }\n}\n"}
{"task_id": "python/0", "content": "class neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0] * 2 for _ in range(n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n\n\n# -\n\n\n", "groundtruth": " DIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n    "}
{"task_id": "python/1", "content": "Sample Test Cases\nInput\n[\"neighborSum\", \"adjacentSum\", \"diagonalSum\"]\n[[[[1, 2, 3], [4, 5, 6], [7, 8, 9]]], [[1]], [[1]]]\nOutput\n[null, 16, 20]\n\nExplanation\nneighborSum neighborSum = new neighborSum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);\nneighborSum.adjacentSum(1); // 2 + 6 + 7 + 5\nneighborSum.diagonalSum(1); // 2 + 7 + 3 + 9\nWe will call the total number of functions called in each test case. It should be 4.\n# @lc code=end\n\n/cpp/leetcode/345_reverse_vowels_of_a_string.cpp\n/*\n * @lc app=leetcode id=345 lang=cpp\n *\n * [345] Reverse Vowels of a String\n *\n * https://leetcode.com/problems/reverse-vowels-of-a-string/description/\n *\n * algorithms\n * Easy (39.49%)\n * Likes:    415\n * Dislikes: 1525\n * Total Accepted:    171.1K\n * Total Submissions: 432.4K\n * Testcase Example:  '\"hello\"'\n *\n * Write a function that takes a string as input and reverse only the vowels of\n * a string.\n * \n * Example 1:\n * \n * \n * Input: \"hello\"\n * Output: \"holle\"\n * \n * \n * \n * Example 2:\n * \n * \n * Input: \"leetcode\"\n * Output: \"leotcede\"\n * \n * \n * Note:\n * The vowels does not include the letter \"y\".\n * \n */\n#include <vector>\n#include <set>\n#include <cctype>\nusing namespace std;\n\nclass Solution {\npublic:\n    string reverseVowels(string s) {\n        set<char> set = {'a', 'e', 'i', 'o', 'u', 'A', '", "groundtruth": " DIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n "}
{"task_id": "python/2", "content": "\"\"\"\nclass NeighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0, 0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate([(i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)]):\n                    if 0 <= dx < n and 0 <= dy < n:\n                        s[v][k % 4] += grid[dx][dy]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return _____\n// 20200308_02.cpp\n//\n// Author: Youngdon() [Leetcode - https://leetcode.com/Youngdon]\n// Create Date: 2020-03-08 23:09:29\n\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n  int scoreOfParentheses(string S) {\n    int N = S.length();\n\n    int sum = 0;\n    vector<int> stack;\n\n    for (int i = 0; i < N; i++) {\n      if (S[i] == '(')\n        stack.push_back(sum);\n      else {\n        int val = 0;\n        while (!stack.empty() && stack.back() >= 0) {\n          val += stack.back();\n          stack.pop_back();\n        }\n\n        if (val == 0)\n          val = 1;\n        sum += val * 2;\n      }\n    }\n\n    return sum;\n  }\n};\n\nint main() { return 0; }\n/*\n2158. 查找缺失的最小正整数\nhttps://leetcode.cn/problems/find-the-missing-number-administrator/\n\n给你一个仅由数字组成的无重复元素数组 nums ，请你找", "groundtruth": " DIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n  "}
{"task_id": "python/3", "content": "'''\nfrom typing import List\nimport collections\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[] for _ in range(n)]\n        vis = [0] * n\n        \n        def bfs(i: int) -> int:\n            q = collections.deque([0])\n            for step in range(1, n):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y]!= i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans/easy/1099.py\n'''\nProblem 1099\n\nFind K-th Largest XOR Coordinates of a Matrix\n\nGiven a 2D matrix matrix and a positive integer k, find the kth largest element in the matrix\n\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\n\nExample 1:\nInput: matrix = [[5,2],[1,6]], k = 1\nOutput: 7\n\nExample 2:\nInput: matrix = [[5,2],[1,6]], k = 2\nOutput: 5\n\nExample 3:\nInput: matrix = [[5,2],[1,6]], k = 3\nOutput: 4\n\nNote:\n1. 1 <= matrix.length, matrix[0].length <= 300\n2. 0 <= matrix[i][j] <= 1000\n3. 1 <= k <= matrix.length*matrix[0].length\n'''\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def kthLargestValue(self, matrix: List[List[int]], k: int) -> int:\n        m, n = len(matrix), len(matrix[0])\n        q = []\n        hmap = {}\n        for j in range(n):\n            v = matrix[0][j]\n            if v in h", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n  "}
{"task_id": "python/4", "content": "\"\"\"'''\nhttps://leetcode-cn.com/problems/reverse-only-letters/solution/fan-zhuan-ge-zi-mu-by-leetcode/\n\n只包含小写字母的字符串 S ，返回 按字典序排列 所有可能的非空子序列，且不含重复字符串的数量。\n\n如果重复出现，对应的子串应该被计算一次。\n\n输入：S = \"abc\"\n输出：7\n解释：7个子序列分别是 \"a\", \"b\", \"c\", \"ab\", \"ac\", \"bc\", \"abc\"。\n示例 2：\n\n输入：S = \"abcde\"\n输出：120\n解释：3 个子序列是单个字符，5 个子序列包含两个字符，10 个子序列包含三个字符，21 个子序列包含四个字符。\n'''\nfrom collections import Counter\nclass Solution:\n    def reverseOnlyLetters(self, S: str) -> int:\n        low = 0\n        high = len(S) - 1\n        res = Counter()\n        while low < high:\n            while low < high and not self.is_letter(S[low]):\n                low += 1\n            while low < high and not self.is_letter(S[high]):\n                high -= 1\n            if low < high:\n                res[low] += 1\n                res[high] += 1\n                low += 1\n                high -= 1\n        return res.get(0, 0) + res.get(1, 0) + res.get(2, 0)\n\n    @staticmethod\n    def is_letter(char):\n        return ('a' <= char <= 'z') or ('A' <= char <= 'Z')\n\ndef test():\n    assert Solution().reverseOnlyLetters(\"a\") == 0\n    assert Solution().reverseOnlyLetters(\"b\") == 0\n    assert Solution().reverseOnlyLetters(\"aA\") == 2\n    assert Solution().reverseOnlyLetters(\"A\") == 0\n    assert Solution().reverseOnlyLetters(\"aA\") == 2\n    assert Solution().reverseOnlyLetters(\"bA\") == 3\n    assert Solution().reverseOnlyLetters(\"bA\") == 3\n    assert Solution().reverseOnlyLetters(\"bA\") == 3\n    assert Solution().reverseOnlyLetters(\"cAb\") == 4\n    assert", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n "}
{"task_id": "python/5", "content": "\n### Constraints:\n\n1 <= n <= 1000\n\n0 <= queries.length <= n * 10000\n\n0 <= queries[i][0], queries[i][1] < n\nGiven an integer n, return a string of n characters such that each character in such string occurs an odd number of times.\nThe returned string must contain only lowercase English letters. If there are multiples valid strings, return any of them.\n\nExample 1:\n\nInput: n = 4\nOutput: \"pppz\"\nExplanation: \"pppz\" is a valid string since the character 'p' occurs three times and the character 'z' occurs once. Note that there are many other valid strings such as \"ohhh\" and \"love\".\n\nExample 2:\n\nInput: n = 2\nOutput: \"xy\"\nExplanation: \"xy\" is a valid string since the characters 'x' and 'y' occur once. Note that there are many other valid strings such as \"ag\" and \"ur\".\n\nExample 3:\n\nInput: n = 7\nOutput: \"holasss\"\n\nConstraints:\n\n1 <= n <= 500\nGiven an integer array nums, return an array answer such that answer[i] == true if the number of times the ith digit appears in nums is even, and false if the ith digit appears in nums is odd.\nThe digits are considered bits when reading towards the least significant bit. For example, the digit read by - is the least significant bit of the number that is read by.\n\nExample 1:\n\nInput: nums = [12,85]\nOutput: [true,false]\nExplanation: \nThe 0-th digit (0-indexed) appears even times in 12, so answer[0] is true. \nThe 1-st digit appears odd times in 85, so answer[1] is false.\n\nExample 2:\n\nInput: nums = [10,12]\nOutput: [true,true]\n\nExample 3:\n\nInput: nums = [70,78]\nOutput: [false,true]\n\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 10^9\nYou", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n "}
{"task_id": "python/6", "content": "\"\"\"\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt]!= rt:\n                rt = fa[rt]\n            while fa[x]!= rt:\n                fa[x], x = fa[fa[x]], fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n\nif __name__ == \"__main__\":\n    print()/077_Combination_Backtrack.py\n# -*- coding: utf-8 -*-\n# File    : 077_Combination_Backtrack.py\n# Author  : \n# Date    : 2020/6/12\n\n\"\"\"\nGiven two integers n and k, return all possible combinations of k numbers out of 1... n.\n\nInput: n = 4, k = 2\nOutput:\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]\n\"\"\"\n\n\nclass Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        self.ans = []\n        self.trackback(1, [], k)\n        return self.ans\n\n    def trackback(self, st, arr, k):\n        if len(arr) == k:\n            self.ans.append(arr[:])\n        else:\n            for i in range(st, n + 1):\n                arr.append(i)\n                self.trackback(i + 1, arr, k)\n                arr.pop()\n\nif __name__ == '__main__':\n    print()\n/097_Interleaving_Backtrack.py\n# -*- coding: utf", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/7", "content": "The description of the completed code:\nComplete the program according to the description.\nThe description is as follows:\nYou are given an integer n and a 2D integer array queries. There are n cities numbered from 0 to n - 1. Initially, there is a unidirectional road from city i to city i + 1 for all 0 <= i < n - 1. queries[i] = [ui, vi] represents the addition of a new unidirectional road from city ui to city vi. After each query, you need to find the length of the shortest path from city 0 to city n - 1. There are no two queries such that queries[i][0] < queries[j][0] < queries[i][1] < queries[j][1]. Return an array answer where for each i in the range [0, queries.length - 1], answer[i] is the length of the shortest path from city 0 to city n - 1 after processing the first i + 1 queries.\nThe example is as follows:\nInput: n = 4, queries = [[0,2],[2,3],[1,3],[0,1]]\nOutput: [0,2,3,0]\n\nExplanation:\nAfter the first query, the following graph will be obtained:\n0   2 \n|   | \n1   3\n\nIn the second query, there are 2 unconnected city pairs, {0,2} and {2,3}. The minimum length from 0 to 3 is 2, so answer[1] = 2.\n\nAfter the third query, the following graph will be obtained: \n1->0<-2->3\n\nThe city pair that can be connected is {1,3}, so answer[2] = 3.\n\nAfter the fourth query, the following graph will be obtained: \n0->1->2->3\n\nIt is the shortest path from 0 to 3, so answer[3] = 0.\nConstraints:\n2 <= n <= 4 * 10^4\n0 <= queries.length <= 4 * 10^4\nqueries[i].length == 2\n0 <= ui < vi < n\n*/\n\n/**\n * @param {number} n\n * @param {number[][]} queries\n * @", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/8", "content": "\n## 题意\n\n给你两个整数n、queries（queries[i] = [ui, vi]）以及一个初始的已知的长度为n - 1的单向城市路。\n此后，你需要处理一些在每一个时刻增添新的城市路的操作。\n其中，你将在时间t之前处理queries[i]，那么第i个元素queries将将被转化为新增的单向城市路的操作，\n即单向城市路从城市ui到城市vi。\n对于每一个在时间点t之后的处理操作，你需要计算从城市0到城市n-1的最短路径的长度。\n请返回一个长度为queries.length数组的答案数组，其中answer[i]表示在时间点queries[i]之前处理的所有操作之后，从城市0到城市n-1的最短路径的长度。\n## 案例\n\nn = 4, queries = [[0, 1], [1, 2]]\n\n输出：\n[0, 2]\n\n解释：\n0--1--0--1\n 1\n| |\n2-0--1--0--1\n 路径0：0 -> 2 -> 0 -> 1 -> 0 -> 1\n  路径1：0 -> 1 -> 0 -> 1 -> 0 -> 1\n\n## 解法\n### 解法一：并查集\n时间复杂度：O(m)\n\n空间复杂度：O(n)\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        # 并查集\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt]!= rt:\n                rt = fa[rt]\n            while fa[x]!= rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i <", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/9", "content": "\nExample 1:\nInput: colors = [0,1,1,0], queries = [[1,4],[2,1,0],[1,5],[2,3,0]]\nOutput: [3,4,1,4]\nExplanation:\nIn the 0th query, all alternating groups of size 1 have color 0 and size 3 (0-indexed). \nIn the 1st query, all alternating groups of size 2 have color 1 and size 4 (0-indexed). \nIn the 2nd query, all alternating groups of size 1 have color 0 and size 5 (0-indexed). \nIn the 3rd query, all alternating groups of size 2 have color 0 and size 3 (0-indexed). \n\nConstraints:\nn == colors.length\n1 <= n <= 10⁵\ncolors[i] is either 0 or 1.\n1 <= queries.length <= 10⁵\nqueries[i].length == 3\nqueries[i][0] == 1 or queries[i][0] == 2\n1 <= queries[i][1] <= n\n0 <= queries[i][2] <= 1\nThere will be at most 10⁵ queries with the given conditions.\nSolution (Python 3):import bisect as bs\nfrom sortedcontainers import SortedList\nfrom typing import List\n\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [0] * (n + 1)\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = size\n        while i <= len(self.t):\n            self.t[i] += op\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = size\n        while i > 0:\n            cnt += self.t[i]\n            s += self.t[i] * (i)\n            i &= i - 1\n        return cnt, s\n\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int],", "groundtruth": " from sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/10", "content": "\nSolution:\nfrom sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()  # 存放结束位置\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -", "groundtruth": " from sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/11", "content": "\nTest Case 1:\nInput\n [\"Solution\",\"numberOfAlternatingGroups\",\"numberOfAlternatingGroups\",\"numberOfAlternatingGroups\",\"update\",\"numberOfAlternatingGroups\",\"update\",\"numberOfAlternatingGroups\",\"update\",\"numberOfAlternatingGroups\",\"numberOfAlternatingGroups\",\"update\",\"numberOfAlternatingGroups\",\"update\",\"numberOfAlternatingGroups\",\"numberOfAlternatingGroups\",\"numberOfAlternatingGroups\",\"numberOfAlternatingGroups\",\"numberOfAlternatingGroups\",\"numberOfAlternatingGroups\",\"numberOfAlternatingGroups\"]\n [[],[1,1],[2,3],[3,3],[0,0],[1,1],[1,1],[2,2],[0,1],[1,1],[2,2],[1,1],[3,3],[3,3],[2,2],[1,2],[0,0],[1,1],[2,2],[3,3]]\nOutput\n [null,1,2,3,null,1,null,2,null,1,3,null,3,null,3,2,2,3,3,null]\nExplanation\n# python:\nclass Solution:\n    def __init__(self):\n        self.t = 0\n        # self.t 代表颜色变化的次数\n\n    def numberOfAlternatingGroups(self, colors: List[int]) -> List[int]:\n        n = len(colors)\n\n        self.sl = ____ # 从小到大排序\n        # 从小到大排序，使后面的元素更小\n\n        self.t = ____ # 代表颜色变化的次数\n\n        def update(i: int, op: int) -> None:\n            # op=1，添加一个结束位置 i\n            # op=-1，移除一个结束位置 i\n            idx = self.sl.bisect_left(i)\n            pre = self.sl[____] # 前一个元素\n            nxt = self.sl[____] # 后一个元素\n            self.t += ____(_________) # 移除/添加旧长度\n            self.t += ____(_________) # 添加/移除新长度\n\n        def add(i: int) -> None:\n            # 添加一个结束位置 i\n            self.sl.____(_____) # 进行修改\n\n        def remove(i: int) -> None:\n            # 移除一个结束位置 i\n            self.sl.____(_____) # 进行修改\n\n        ans = []\n        for i, c in enumerate(colors):\n            # 从", "groundtruth": " from sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/12", "content": "\"\"\"\n\n\n# Code to execute this quiz : \nclass Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        single=0\n        double=0\n        for it in nums:\n            if it>=10: \n                double+=it\n            else:\n                single+=it\n        \n        return single!=double/LeetCode_Quiz/8_Two Sum II/solution.py\n# Solution to Leetcode quiz 8 Two Sum II\n# Here is my solution \n\nclass Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        # Sort\n        numbers.sort()\n        i = 0\n        j = len(numbers)-1\n        \n        while (numbers[i]+numbers[j])!= target:\n            if numbers[i]+numbers[j]>target:\n                j-=1\n            else:\n                i+=1\n        \n        return [i+1, j+1]\n        /LeetCode_Quiz/31_Minimum Number of Taps to Open a Water Trap/solution.py\n# Solution for Leetcode Quiz 31 Minimum Number of Taps to Open a Water Trap\n\n# Code to execute this quiz : \nclass Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        # The idea here is to find out whether there exists the taps \n        # which are not located next to each other in the given ranges.\n        # For this purpose, we will apply binary search which is \n        # used when you want to find a range in which your goal is to find \n        # if it's possible to find your target or not. For example, if \n        # you want to find if it's possible to find 25000 in the ranges \n        # of (150000,180000). \n        # If it is possible to find it, the left will point to 150000 and \n        # right will point to 180000. \n        # If it is impossible to find it, the left will be increased and \n        # right will be decreased.\n        # In the above, you can notice that both left and right are \n        # initialized to (0,n-1). \n        # It means that we're going to start from the left or the right \n        # and move towards the middle point until we find", "groundtruth": " class Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        single=0\n        double=0\n        for it in nums:\n            if it>=10: \n                double=double+it \n            else:\n                single=single+it  \n        \n        return single !=double\n "}
{"task_id": "python/13", "content": "\n# The answer is guaranteed to fit in a 32-bit signed integer.package main\n\nimport \"fmt\"\n\n// 给定一个整数 n，生成所有由 1... n 为节点所组成的二叉搜索树。\nfunc generateTrees(n int) [][]int {\n\treturn genTrees(1, n)\n}\n\nfunc genTrees(left, right int) [][]int {\n\tret := make([][]int, 0)\n\tif left > right {\n\t\tret = append(ret, nil)\n\t\treturn ret\n\t}\n\n\tfor i := left; i <= right; i++ {\n\t\tleftTrees := genTrees(left, i-1)\n\t\trightTrees := genTrees(i+1, right)\n\n\t\tfor _, leftTree := range leftTrees {\n\t\t\tfor _, rightTree := range rightTrees {\n\t\t\t\troot := []int{i}\n\t\t\t\troot = append(root, leftTree...)\n\t\t\t\troot = append(root, rightTree...)\n\t\t\t\tret = append(ret, root)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret\n}\n\nfunc main() {\n\ttrees := generateTrees(3)\n\tfmt.Println(trees)\n}\n\n// 思考\n// DFS, 枚举 root 节点, 然后对 left 和 right 的节点进行遍历\ndef my_pow(base, n):\n    if n == 0:\n        return 1\n\n    base_p = base * base\n    if n % 2 == 0:\n        return my_pow(base_p, n / 2)\n    else:\n        return base * my_pow(base_p, n / 2)\n\n\nn = 10\nprint(my_pow(2, n))\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\n// Given two integers L and R, find the count of numbers in the range [L, R]\n// (inclusive) having a prime number of set bits in their binary representation.\n\nint helper(int n) {\n    if (n < 2) {\n        return 0;\n    }\n\n    int res = 0;\n    for (int i = 2; i <= n; ++i) {\n        res += numSet", "groundtruth": " MX = 31622\npi = [0] * (MX + 1)\nfor i in range(2, MX + 1):\n    if pi[i] == 0:  # i 是质数\n        pi[i] = pi[i - 1] + 1\n        for j in range(i * i, MX + 1, i):\n            pi[j] = -1  # 标记 i 的倍数为合数\n    else:\n        pi[i] = pi[i - 1]\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        return r - l + 1 - (pi[isqrt(r)] - pi[isqrt(l - 1)])\n"}
{"task_id": "python/14", "content": "```\n\n### 练习一\n\n请实现函数`is_odd`来判断一个整数是否是奇数，如果是奇数，函数`main`输出`Yes`；如果不是奇数，函数`main`输出`No`。\n\n提示：实现判断奇数的位运算方法。\n\n```python\ndef is_odd(n):\n    ____________\n\ndef main():\n    ____________\n    \nif __name__ == '__main__':\n    main()\n```\n\n## 练习三\n\n> 要求：请实现函数`prime_generator`返回前n个素数，其中n是一个给定的参数，如果n <= 0，则返回一个空的list。\n\n提示：n <= 0 则不产生任何素数，因此返回空列表；n为正整数时，我们要产生n个素数，因此必须生成一个长度为n的素数列表。一个整数`x`的最大质因数一定小于等于`x`的平方根。请在生成`x`的最大质因数时，用到python提供的`math.sqrt()`函数。\n\n> 实现以下代码即可解决问题。\n\n```python\ndef prime_generator(n):\n    ___________________\n\n____________________\n```\n\n\n\n```python\n# 测试代码\nfrom nose.tools import *\nimport math\n\n\ndef prime_generator(n):\n    \"\"\"\n    生成指定范围的素数\n    \"\"\"\n    def is_prime(num):\n        \"\"\"\n        判断指定数字是否为素数\n        \"\"\"\n        # 因为 n <= 0 则 n + 2 必为素数\n        if n <= 0:\n            return False\n        # 注意，这里只判断到 num 的平方根即可\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \"\"\"\n    n 必须大于 0，如果 n <= 0 则返回一个空的 list\n    \"\"\"\n    assert isinstance(n, int)\n    assert n > 0\n    \n    \"\"\"\n    先生成一个空的 list，用于保存素数\n    \"\"\"\n    primes = []\n    \"\"\"\n    第一个质数是 2，所有大于 2 的偶数都不是质数\n    \"\"\"\n    primes.", "groundtruth": " MX = 31622\npi = [0] * (MX + 1)\nfor i in range(2, MX + 1):\n    if pi[i] == 0:  # i 是质数\n        pi[i] = pi[i - 1] + 1\n        for j in range(i * i, MX + 1, i):\n            pi[j] = -1  # 标记 i 的倍数为合数\n    else:\n        pi[i] = pi[i - 1]\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        return r - l + 1 - (pi[isqrt(r)] - pi[isqrt(l - 1)])\n "}
{"task_id": "python/15", "content": "def numberOfSubstrings(self, s: str) -> int:\n    n = len(s)\n    a = [i for i, b in enumerate(s) if b == '0']\n    tot1 = n - len(a)\n    a.append(n) # 哨兵\n    ans = i = 0 # >= left 的第一个 0 的下标是 a[i]\n    for left, b in enumerate(s):\n        if b == '1':\n            ans += (i - left) * (i - left) - 1  # 不含 0 的子串个数\n        for k in range(i, len(a) - 1):\n            cnt0 = k - i + 1\n            if cnt0 * cnt0 > tot1:\n                break\n            cnt1 = a[k] - left - (k - i)\n            # 可以改成手动比大小，那样更快\n            ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n        if b == '0':\n            i += 1 # 这个 0 后面不会再枚举到了\n    return ans\n\n/498_对角线遍历.py\nclass Solution:\n    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:\n        if not matrix:\n            return []\n        m = len(matrix)\n        n = len(matrix[0])\n        res = []\n        for r in range(m+n-1):\n            x, y = 0, r\n            while x < m and y >= 0:\n                res.append(matrix[x][y])\n                x += 1\n                y -= 1\n        return res/918_环形子数组的最大和.py\nclass Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        cur_max, cur_min, res = A[0], A[0], A[0]\n        sum_ = sum(A)\n        for i in range(1, len(A)):\n            cur_max = max(cur_max + A[i], A[i])\n            cur_min = min(cur_min + A[i], A[i])\n            res = max(cur_max,", "groundtruth": " class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n "}
{"task_id": "python/16", "content": "\"\"\"\n\n\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = a[k + 1] - a[k] - 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k + 1] - a[i] - 1\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n\n/leetcode/007_ReverseInteger.py\n'''\nGiven a 32-bit signed integer, reverse digits of an integer.\n\nNote:\nAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.\n\nExample 1:\n\nInput: 123\nOutput:  321\nExample 2:\n\nInput: -123\nOutput: -321\nExample 3:\n\nInput: 120\nOutput: 21\n'''\n\n\ndef rev(x):\n    if x < 0:\n        return -rev(-x)\n    a = 0\n    while x!= 0:\n        t = x % 10\n        a = a * 10 + t\n        x = x // 10\n    return a\n\n\nprint(rev(123))\nprint(rev(-", "groundtruth": " class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n    "}
{"task_id": "python/17", "content": "The following code does not meet the specification. For example, it will get accepted when output 0\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)\n        ans = i = 0\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                ans += cnt0 + cnt1\n            if b == '0':\n                i += 1\n        return ans\n\n\nTest Example\nExample 1:\nInput: s = \"0110111\"\nOutput: 9\nExplanation: There are 9 strings of length 7: \"0110111\", \"0110111\", \"0110111\", \"0110111\", \"0110111\", \"0110111\", \"0110111\", \"0110111\" and \"0110111\".\nExample 2:\nInput: s = \"101\"\nOutput: 2\nExplanation: There are 2 strings of length 3: \"101\" and \"101\".\n\nExample 3:\nInput: s = \"111111\"\nOutput: 21\nExplanation: Each substring contains only one type of characater. There are 21 strings in total.\n\n\nConstraints:\n2 <= s.length <= 105\ns[i] is either '0' or '1'./leetcode/Array/LongestSubstringWithoutRepeatingCharacters_3.py\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        n = len(s)\n        if not s:\n            return 0\n        ans = 0\n        i = j = 0\n        c = [0] * ", "groundtruth": " class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n    "}
{"task_id": "python/18", "content": "\n'''\n\nimport math\n\nclass Solution:\n    def canReachCorner(self, xcorner: int, ycorner: int, circles: List[List[int]]) -> bool:\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return abs(x - ox) * abs(x - ox) + abs(y - oy) * abs(y - oy) < r * r\n\n        vis = {}\n\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            if y1 <= ycorner and abs(x1 - xcorner) <= r1 or \\\n               x1 <= xcorner and y1 <= r1 or \\\n               x1 > xcorner and in_circle(x1, y1, r1, xcorner, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                if not vis[j] and (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                        x1 * r2 + x2 * r1 < (r1 + r2) * xcorner and \\\n                        y1 * r2 + y2 * r1 < (r1 + r2) * ycorner and \\\n                        dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            if in_circle(x, y, r, 0, 0) or \\\n                    in_circle(x, y, r, xcorner, ycorner) or \\\n                    not vis[i] and (x <= xcorner and abs(y - ycorner) <= r or\n                                    y <= ycorner and x <= r or\n                                    y > ycorner and in_circle(x, y, r, 0, ycorner)):\n                return False\n        return True\n\n/python/847.shortest-path-visiting-all-nodes/README.md\n# [847. Shortest Path Visiting All Nodes](https://leetcode.com/problems/shortest-path-", "groundtruth": " class Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and \\\n                   (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or \\\n               in_circle(x, y, r, X, Y) or \\\n               not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n    "}
{"task_id": "python/19", "content": "If you want to receive feedback, submit the link to the CodeCombat online editor, not a local computer.\nDo not use \"debugger\" feature on CodeCombat.\nThe code runs too slowly because of the extra \"print\". This is not allowed.\nDo not use \"input()\" in code.\nThe function \"random.choice\" works incorrectly in some cases. If you change \"circle2\" to any other number, it will start to work.\nDo not use other names in the code, except \"circles\".\nDo not use \"random\" in the code./src/CodeWars/8 kyu/HighestScoringWord.md\nIn this little assignment you are given a string of space separated words, and have to return the highest scoring word.\nAssume a'score' of a word is the sum of its letters existing in the alphabetical table of Roman numerals. So 'AAA' is 1, 'AAB' is 2, 'D' is 5 etc. You have to return the highest scoring word as a string.\nThink of the word as a vector of integer. The zeroth letter is worth 1, the first letter is worth 2 etc.\nAll letters will be lower case from 'a' - 'z'.\nExample:\n['heres', 'is', 'a', 'theta', 'i'] --> 'theta'\n['hello', 'world', 'hero'] --> 'world'\n['supercalifragalisticexpialidocious'] -->'supercalifragalisticexpialidocious'/src/CodeWars/8 kyu/ConvertAstringIntoaNumber.md\nI'm new to coding and now I want to get the sum of two arrays...actually the sum of all their elements. I will give you two arrays.\nYour tasks are to:\n\nSum those two arrays\nMake the sum overwrite the existing values (array1)\nReturn the resulting array\nNotes:\n\nArray values can be negative.\nArray values will always be valid numbers.\nI'll give you two array, whose lengths can be different, also whose values can be negative.\nThe size of the arrays will at least be 1x1.\nThe sum of all elements of those two arrays will be the same\nExamples:\n```\n[1, 0]   [3]    ->   [1, 3", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or                x1 <= X and y1 <= r1 or                x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and                    (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and                    x1 * r2 + x2 * r1 < (r1 + r2) * X and                    y1 * r2 + y2 * r1 < (r1 + r2) * Y and                    dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or                in_circle(x, y, r, X, Y) or                not vis[i] and (x <= X and abs(y - Y) <= r or                                y <= Y and x <= r or                                y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/20", "content": "```\n#include <cassert>\n#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\n#define MAX_VALUE 10000\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  int f[MAX_VALUE][MAX_VALUE];\n  for (int i = 1; i < MAX_VALUE; i++)\n    f[i][i] = 0;\n\n  for (int i = 1; i <= n; i++)\n    f[i][0] = 0;\n\n  for (int i = 1; i <= n; i++) {\n    f[i][0] = 10000;\n    for (int j = 1; j < m; j++) {\n      f[i][j] = f[i - 1][j] + 1;\n    }\n  }\n\n  for (int i = n; i < MAX_VALUE; i++)\n    for (int j = 0; j <= m; j++)\n      f[i][j] = 10000;\n\n  for (int i = 1; i < MAX_VALUE; i++) {\n    int d = floor(sqrt(f[i][m]));\n    for (int j = m - d; j <= m; j++) {\n      f[i][j] = min(f[i][j], f[i][m - j] + f[j][j]);\n    }\n  }\n\n  int ans = f[n][m];\n\n  cout << ans << endl;\n  return 0;\n}#include <iostream>\n\nusing namespace std;\n\nint main() {\n  long long int ans = 0;\n\n  for (long long int n = 0; n < 2; n++) {\n    for (long long int i = 0; i < 100; i++) {\n      for (long long int j = 0; j < 100; j++) {\n        long long int s = i * 100 + j * 10000 + n * 1000000;\n        if (s % 4 == 0) {\n          ans += s;\n        }\n      }\n    }\n  }\n\n  cout << ans << endl;\n}#include <iostream>", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or                x1 <= X and y1 <= r1 or                x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and                    (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and                    x1 * r2 + x2 * r1 < (r1 + r2) * X and                    y1 * r2 + y2 * r1 < (r1 + r2) * Y and                    dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or                in_circle(x, y, r, X, Y) or                not vis[i] and (x <= X and abs(y - Y) <= r or                                y <= Y and x <= r or                                y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/21", "content": "'''\nclass Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        def check(i):\n            for j in range(n):\n                if i == j:\n                    continue\n                elif grid[i][j] and grid[j][i]:\n                    return False\n            return True\n        n = len(grid)\n        for i in range(n):\n            if check(i):\n                return i/algorithms/1162_as_far_from_land_as_possible.py\nfrom typing import List\n\nclass Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        n, m = len(grid), len(grid[0])\n        directions = ((-1,0), (1,0), (0,-1), (0,1))\n        visited = set()\n\n        def dfs(x,y):\n            if (x,y) in visited:\n                return\n            visited.add((x,y))\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0:\n                    dfs(nx,ny)\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 0:\n                    dfs(i,j)\n\n        cnt = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 0:\n                    cnt += 1\n                elif grid[i][j] == 1:\n                    if (i,j) not in visited:\n                        return -1\n        return cnt if cnt > 0 else -1\n\n'''\nSolution_1:\nfrom typing import List\n\nclass Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        def bfs(grid, i, j, n, m):\n            if grid[i][j] == 0:\n                directions = ((-1,0), (1,0), (0,-1), (0,1))\n                dist = 0\n                visited = set()\n                visited.add((i,j))\n                while len(visited) < n*m:\n                    tmp = []\n                    for i,j in visited:\n                        for di, dj", "groundtruth": "\nclass Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        def check(i):\n            for j in range(n):\n                if i == j:\n                    continue\n                elif grid[i][j] == 1 and grid[j][i] == 0:\n                    continue\n                else:\n                    return False\n            return True\n        n = len(grid)\n        for i in range(n):\n            if check(i):\n                return i\n"}
{"task_id": "python/22", "content": "\"\"\"\nfrom typing import List\n\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = 0\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\"\"\"\nQ36.Valid Sudoku\nhttps://leetcode.com/problems/valid-sudoku/\n\nDetermine if a n * n grid board is valid Sudoku board.\nA Sudoku board (partially filled) could be valid.\n\nA valid Sudoku board (partially filled) is not necessarily solvable.\nEach node in the Sudoku board could be one of the 9 digits from 1 to 9.\nIf a digit already exists in one of the nine rows, nine columns,\nnine sub-boxes of the grid,\nit could not be further validated.\n\nYou may assume the grid always could be valid\n\nExample:\nThe grid is as follows:\n5 3 4 | 6 7 8 | 9 1 2\n6 7 2 | 1 9 5 | 3 4 8\n1 9 8 | 3 4 2 | 5 6 7\n-----|-------|------\n8 5 9 | 7 6 1 | 4 2 3\n4 2 6 | 8 5 3 | 7 9 1\n7 1 3 | 9 2 4 | 8 5 6\n-----|-------|------\n9 6 1 | 5 3 7 | 2 8 4\n2 8 7 | 4 1 9 | 6 3 5\n3 4 ", "groundtruth": "\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/23", "content": "\"\"\"# -*- coding:utf-8 -*-\r\n# encoding: utf-8\r\n\r\nclass Solution:\r\n    def IsContinuous(self, numbers):\r\n        if len(numbers) == 0:\r\n            return False\r\n        numbers.sort()\r\n        first = numbers[0]\r\n        zero_count = 0\r\n        for i in range(len(numbers) - 1):\r\n            if numbers[i] == first or numbers[i] == 0:\r\n                zero_count += 1\r\n            else:\r\n                if (numbers[i] - numbers[i - 1]) > 1:\r\n                    return False\r\n        if (first == 0 or numbers[len(numbers) - 1] == first + len(numbers) - zero_count):\r\n            return False\r\n        return True\r\n\r\n\r\nif __name__ == '__main__':\r\n    solution = Solution()\r\n    numbers = [1, 3, 0, 5, 0]\r\n    print(solution.IsContinuous(numbers))\r\n\"\"\"\nGiven a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\n\nExample:\nGiven a binary tree\n\n          1\n         / \\\n        2   3\n       / \\\n      4   5\nReturn 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\n\nNote: The length of path between two nodes is represented by the number of edges between them.\n\"\"\"\n\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def __init__(self):\n        self.result = 0\n\n    def longest_path(self, root: TreeNode):\n        if not root:\n            return 0\n\n        left = self.longest_path(root.left)\n        right = self.longest_path(root.right)\n\n        self.result = max(self.result, left + right + 1)\n        return max(left, right) + 1\n\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\n        self.longest_path(root)\n        return self.result - 1\n\n\nif __", "groundtruth": "\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/24", "content": "'''\n\nclass Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v!= p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], nums[u] + min(dp0, dp1)\n            \n        return dfs(0)[1]\n\na = [1,3,3]\na + 3 == [1, 3, 3, 3]", "groundtruth": "\nclass Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v != p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp1 + nums[u], dp0)\n            \n        return dfs(0)[1]\n"}
{"task_id": "python/25", "content": "\"\"\"\n\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))\n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = b.index(x - i)\n            f = x - i + t.pre_max(j)\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n/Python/481-magical-string.py\n\"\"\"\n@lc app=leetcode id=481 lang=python3\n\n[481] Magical String\nMedium\n\nhttps://leetcode.com/problems/magical-string/description/\n\n*Companies*\n\nA magical string S consists of only '1' and '2' and obeys the following rules:\nThe string S is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string S itself.\nThe first few elements of string S is the following: S = \"1221121221221121122……\"\nIf we group the consecutive '1's and '2's in S, it will be:\n\n1 22 11 2 1 22 1 22 11 2 11 22......\nand the occurrences of '1's or '2's in each group are:\n\n1 2 2 1 1 2 1 2 2 1 2 2......\nYou can see that the occurrence sequence above is the S itself.\n", "groundtruth": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/26", "content": "def main():\n    s = input()\n    l = len(s)\n    d = {}\n    for i in range(l):\n        if s[i] not in d:\n            d[s[i]] = 1\n        else:\n            d[s[i]] += 1\n    \n    count = 0\n    l2 = l // 2\n    \n    ans = 0\n    for key, val in d.items():\n        ans = max(ans, val)\n        if val >= l2:\n            return 1\n    \n    return (ans + l2) % 2\n\n\nif __name__ == \"__main__\":\n    print(main())def get_sum(a,b):\n    # fill this out\n    return\n\n\ndef main():\n    # fill this out\n    return\n\n\nif __name__ == '__main__':\n    main()# https://codeforces.com/problemset/problem/1457/C\nimport sys\nfrom collections import deque\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nsys.setrecursionlimit(10 ** 8)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\n\ndef main():\n    T = int(readline())\n    for _ in range(T):\n        n = int(readline())\n        a = deque(map(int, readline().split()))\n        b = deque()\n        m = 0\n        for i in range(n):\n            t = a[i]\n            if m >= t:\n                b.append(a.popleft())\n            else:\n                a.popleft()\n                m = max(m, t)\n        while a:\n            b.append(a.pop())\n        print('YES')\n        print(*b)\n\n\nif __name__ == '__main__':\n    main()\n// https://codeforces.com/problemset/problem/847/C\n\nfunction solve(input){\n    const [n, k] = input[0].split(' ').map(a => +a);\n    let res = [];\n    let now = 0, ans = '', t = '', c = 0;\n    for(let i = 0; i < k; i++){\n        if(i === 0 || k % 2 === 0){\n            ans = '1';\n            c = 1", "groundtruth": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/27", "content": "Example 1:\nInput:\n[\"Solution\",\"update\",\"update\",\"update\",\"update\",\"update\",\"pre_max\",\"pre_max\",\"update\",\"update\",\"pre_max\",\"pre_max\"]\n[[],[3,8],[5,5],[4,7],[1,3],[0,2],[1],[0],[5,3],[2,5],[3],[0]]\nOutput:\n[null,null,null,null,null,null,2,2,null,null,10,2]\nExplanation:\nSolution solution = new Solution();\n// Add 3 at index 0\nsolution.update(3, 8);\n// Add 5 at index 5\nsolution.update(5, 5);\n// Add 4 at index 4\nsolution.update(4, 7);\n// Add 1 at index 1\nsolution.update(1, 3);\n// Add 0 at index 0\nsolution.update(0, 2);\n// The elements of [3, 8, 5, 5, 4, 7, 1, 3, 2, 5, 3] are balanced, with:\n// [8 - 3] >= 1 - 0 = 1\n// [5 - 4] >= 2 - 1 = 1\n// [5 - 5] >= 3 - 2 = 1\n// [4 - 3] >= 4 - 3 = 1\n// [7 - 1] >= 5 - 4 = 1\n// [3 - 0] >= 6 - 5 = 1\n// The maximum of [8, 7, 5, 5, 4, 3] is 8 and the maximum of [3, 5, 5, 4, 3] is 5.\n// The pre_max of range [1, 2] is 2, the pre_max of range [3, 4] is 2 and so on.\n// Add 5 at index 5\nsolution.update(5, 3);\n// Add 3 at index 2\nsolution.update(2, 5);\n// The maximum of [3, 8, 5, 5, 4, 7] is 8.", "groundtruth": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/28", "content": "\n'''\nclass Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for i in range(max(nums).bit_length()):\n            cnt1 = 0\n            for num in nums:\n                cnt1 += num >> i & 1\n            if cnt1 >= k:\n                ans |= 1 << i\n        return ans\n/leetcode-cn/0350.0-Intersection-of-Two-Arrays-II.md\n## [350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)\n\n### 题目\n\n给定两个数组，编写一个函数来计算它们的交集。\n\n```\n示例 1:\n\n输入: nums1 = [1,2,2,1], nums2 = [2,2]\n输出: [2,2]\n\n示例 2:\n\n输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n输出: [4,9]\n说明：\n\n输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。\n我们可以不考虑输出结果的顺序。\n```\n\n进阶:\n\n- 如果给定的数组已经排好序呢？你将如何优化你的算法？\n- 如果 nums1 的大小比 nums2 小很多，哪种方法更优？\n- 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？\n\n### 分析\n\n本题和题目没有重复的解。\n\n使用哈希表保存数组元素出现的次数，在求交集时，优先找哈希表中出现次数为 1 的元素，然后根据给出的条件进行剪枝。\n\n### 解题\n\n```python\nclass Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        mp = collections.Counter(nums1)\n        ans = []\n        for num in nums2:\n            if num in mp and mp[num] > 0:\n                ans.append(num", "groundtruth": "\nclass Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for i in range(max(nums).bit_length()):\n            cnt1 = sum(x >> i & 1 for x in nums)\n            if cnt1 >= k:\n                ans |= 1 << i\n        return ans\n"}
{"task_id": "python/29", "content": "# A: Happiness\n## Problem Description\nA: Happiness\n```\nInspired by a story I heard from my highschool friend, my friend told me to help her by answering a few question about happiness.\nHappiness may be measured in many different ways, including happiness expressed as a happiness score. However, you have to know that happiness is the happiness of people. So, instead of a happiness score, we use the word “happy”.\nIt is impossible to tell what makes people happy. However, it is possible to tell some factors that people look at and try to express their happiness in words. \nI thought happiness is affected by many things such as social situations, work, and the person's personality. Hence, if you can predict the happiness score of an individual, it would make it easier to decide whom to help.\n\nSuppose we have a dataset of individuals' happiness, which consists of the following data for each individual:\nid (id of individuals, not the name. There are 100 individuals in the dataset)\nsocial (the amount of social situations the individual has)\nwork (how much work the individual did during the year)\nhappiness (the happiness score of an individual)\n\nTo find the happiness score, there are multiple ways to calculate it. Here, I will use the average of the happiness scores.\n\nFirst, for each person, calculate the average of their happiness score. The table below lists the average of all happiness scores.\nAverage happiness Score\tid\n18.46\t72\n16.00\t20\n15.67\t11\n14.50\t49\n14.33\t1\n14.17\t10\n14.17\t85\n13.50\t3\n13.00\t61\n12.67\t24\n12.00\t4\n\nGiven the dataset of 100 individuals, write a program to calculate the average happiness score for each person.\n```\n\n## Answer Description\n1. Read the dataset from a file \"happiness-data.csv\" and create an array of type Dict containing the individual's id, social, work, and happiness data.\n2. Get the sum", "groundtruth": "\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n"}
{"task_id": "python/30", "content": "'''\nfrom __future__ import annotations\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n        \n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: \n                return sum1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: \n                return sum2\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: \n            return sum1 + zero1\n        return sum1 + zero1/Easy/21. Merge Two Sorted Lists/answer.py\n'''\nYou are given the heads of two sorted linked lists list1 and list2.\nMerge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\nReturn the head of the merged linked list.\nThe following example may help.\n\nFor example:\nList 1: 2 -> 12 -> 13 -> null\nList 2: 1 -> 3 -> 7 -> null\nOne of the returned lists should look like:\n2 -> 1 -> 3 -> 7 -> 12 -> 13 -> null\n'''\nfrom __future__ import annotations\nclass Solution:\n    def mergeTwoLists(self, list1: ListNode | None, list2: ListNode | None) -> ListNode | None:\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if list1 and list2:\n            head = ListNode()\n            head = list1 if list1.val < list2.val else list2\n            current = head\n            while list1 and list2:\n                if current.next:\n                    if list1.val <= list2.val:\n                        current.next = list1\n                        list1 = list1.next\n                    else:\n                        current.next = list2\n                        list2 = list2.next\n                else:\n                    if list1", "groundtruth": "\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n"}
{"task_id": "python/31", "content": "'''\nclass Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n        nums = [i - nums[i] for i in range(len(nums))]\n        n, mod = divmod(k, len(nums))\n        dp1, dp2 = 0, 0\n        for i in range(len(nums)):\n            dp1 = max(dp1, dp2)\n            dp2 = dp1 + n + (1 if mod > 0 else 0)\n            if nums[i] > 0:\n                dp2 = min(dp2, dp2 + nums[i])\n            mod -= 1\n        return dp1\n/Easy/0041.First_Missing_Positive.py\n'''\nGiven an unsorted integer array, find the smallest missing positive integer.\n\nExample 1:\n\nInput: [1,2,0]\nOutput: 3\nExample 2:\n\nInput: [3,4,-1,1]\nOutput: 2\nExample 3:\n\nInput: [7,8,9,11,12]\nOutput: 1\nNote:\n\nYour algorithm should run in O(n) time and uses constant extra space.\n'''\nclass Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        i = 0\n        while i < len(nums):\n            if 0 < nums[i] <= len(nums):\n                if nums[nums[i] - 1]!= nums[i]:\n                    nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n                else:\n                    i += 1\n            else:\n                i += 1\n        for i in range(len(nums)):\n            if nums[i]!= i + 1:\n                return i + 1\n        return len(nums) + 1\n\nclass Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        for i in range(n):\n            if 1 <= nums[i] <= n and nums[nums[i] - 1]!= nums[i]:\n                nums[nums[i] - 1], nums[i] = nums[i], nums[nums", "groundtruth": "\nclass Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n        dp1 = dp2 = dp3 = 0\n        for num in nums:\n            dp1, dp2, dp3 = min(dp1, dp2, dp3) + max(0, k - num), dp1, dp2\n        return min(dp1, dp2, dp3)\n"}
{"task_id": "python/32", "content": "\"\"\"\nfrom typing import List\nfrom functools import cache\n\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in range(len(edges))]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch!= fa:\n                    res1 += dfs(ch, j, i)  \n                    if j < 13:  \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n\"\"\"\r\nThe following pattern repeats for the length of the string:\r\nA0B1C2\r\nA1B2C3\r\nA2B3C4\r\n....\r\n\r\nThe task is to find the missing index of the string after some string length input.\r\nThe length of the string is: 4^x\r\nwhere x is the index of the missing string.\r\nThe missing index of the string is the index of the string where the string repeats.\r\nFor example, the index of the string 'A0B1C2' is 2.\r\nThe index of the string 'A0B1C1D2' is 0.\r\nThe index of the string 'A0B1C1D3' is 3.\r\nThe missing index of the string 'A0B1C1D2E3' is 3.\r\nComplete the function patternCount below.\r\nThe function must return the index of the missing string.\r\n\"\"\"\r\ndef patternCount(string):\r\n    return len(string) // len(set(string))\"\"\"\nThis is an example algorithm of quick select. The difference between the algorithm and the quick sort are as follows:\nQuick Select: If you do not want to know the exact position of any k in the array, but want to know the position of the k position\nQuick Sort: You want", "groundtruth": "\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i) \n                    if j < 13: \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n"}
{"task_id": "python/33", "content": "Hints:\n\nThe problem has a straightforward solution.\nA better solution might be possible by dynamic programming, where some values are memorized to avoid repeating work.\nA good strategy might be to find a way to generalize the calculation in each node, so that an inductive proof can be used to compute the total value.\nThe general calculation is as follows:\n\nmax(coin, max(coin - k, coin / 2)), where coin is the value of the current node.\nYou can get the problem's information at https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards.\nThe following code is given to help you understand the general idea. You should fill in the incomplete part.\n\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = coins[i]\n            res2 = coins[i] - k if k <= 0 else float('-inf')\n            for ch in g[i]:\n                if ch!= fa:\n                    res1 += dfs(ch, j, i)  \n                    if j < 13:  \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n\n        return dfs(0, 0, -1)xample 1:\n\nInput: s = \"abc\"\nOutput: \"cba\"\nExample 2:\n\nInput: s = \"leetcode\"\nOutput: \"tcedolc\"\nExample 3:\n\nInput: s = \"a\"\nOutput: \"a\"\nExample 4:\n\nInput: s = \"aaa\"\nOutput: \"aaa\"\n \n\nConstraints:\n\n1 <= s.length <= 500\ns consists of lowercase English letters.\n\"\"\"\n# My Solution\nclass Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        newString = ''\n        for i in range", "groundtruth": "\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i) \n                    if j < 13: \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n"}
{"task_id": "python/34", "content": "\nIf the code passes all the provided tests, the program will output “Accepted”, otherwise it will output “Wrong Answer”.\n\nHint:\nThe maximum number of coins which the nodes on the edge can collect is at most 256.\nThe number of nodes is at most 250.\n\nTime Limit: 3s\nMemory Limit: 256MB\nSample Test: #1\n\nInput:\nOutput:\n\nInput:\nOutput:\n\nSample Test: #2\n\nInput:\nOutput:\n\nInput:\nOutput:\n\nSample Test: #3\n\nInput:\nOutput:\n\nInput:\nOutput:\n\nSample Test: #4\n\nInput:\nOutput:\n\nInput:\nOutput:\n\nSample Test: #5\n\nInput:\nOutput:\n\nInput:\nOutput:", "groundtruth": " class Solution:     def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:         g = [[] for _ in coins]         for x, y in edges:             g[x].append(y)             g[y].append(x)         @cache         def dfs(i: int, j: int, fa: int) -> int:             res1 = (coins[i] >> j) - k             res2 = coins[i] >> (j + 1)             for ch in g[i]:                 if ch != fa:                     res1 += dfs(ch, j, i)                      if j < 13:                          res2 += dfs(ch, j + 1, i)              return max(res1, res2)         return dfs(0, 0, -1) "}
{"task_id": "python/35", "content": "\n## Problem:\n\n1051. Height Checker\nhttps://leetcode.cn/contest/weekly-contest-199/problems/height-checker/\n\nStudents are asked to stand in non-decreasing order of heights for an annual photo.\n\nReturn the minimum number of students that must move in order for all students to be standing in non-decreasing order of height.\n\nNotice that when a group of students is selected they can reorder in any possible way between themselves and the non selected students remain on their seats.\n\nGiven the integer array heights representing the heights of the students in the class from least to greatest.\n\nReturn the minimum number of students that must move in order for all students to be standing in non-decreasing order of height.\n\nExample 1:\nInput: heights = [1,1,4,2,1,3]\nOutput: 3\nExplanation:\nStudents with heights 4, 3 and the last 1 are not standing in the right order.\n\nExample 2:\nInput: heights = [5,1,2,3,4]\nOutput: 5\nExplanation:\nStudents with heights 1, 2, 3 and 4 are not standing in the right order.\n\nConstraints:\n1 <= heights.length <= 100\n1 <= heights[i] <= 100\n\n## Solution:\n\nCount the number of times h[i] is smaller than h[i-1] and equal to i-1.\nThen just count how many times of h[i] is smaller than h[i-1] and bigger than h[i]\n\n## Code:\n\nclass Solution:\ndef heightChecker(self, heights: List[int]) -> int:\ncnt = [0] * 101\nlast = 0\n\nfor h in heights:\ncnt[h] += 1\nif h < last:\ncnt[h] -= 1\nlast = h\nfor h in range(101):\ncnt[h] += cnt[h-1]\n\nfor i in range(len(heights)):\nif cnt[heights[i]-1]!= i:\nreturn cnt[heights[i]-1]\nreturn cnt[-1", "groundtruth": " class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o * 2] + sum[o * 2 + 1]             return res         ans = s = 0         last = {}         for i, x in enumerate(nums, 1):             j = last.get(x, 0)             s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j             ans += s             last[x] = i         return ans % 1_000_000_007 "}
{"task_id": "python/36", "content": "Constraints:\n3 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n\n## Solution\n\n# Approach 1: Count with Fenwick Tree\n\nIntuition and Algorithm\n\nWe use a Fenwick Tree to implement the count.\n\nIt is often easier to implement the Fenwick Tree by maintaining the actual Fenwick Tree, and then copying it when asked to calculate the sum.\n\nLet's calculate the count for the range from 1 to i. Let's maintain an actual Fenwick Tree, storing the value of tree[i]. Then, every query for the sum of a subarray can be implemented by the following steps:\n\n1. Calculate a = tree[j] - tree[i-1]. This is the difference between the i-th and (i-1)-th prefix sums in the Fenwick Tree.\n\n2. Calculate (x + 1) * x / 2 = (x + 1) * x // 2 (i.e. the average of the prefix sum for x elements) which corresponds to the sum of the range [0..x]. (// denotes integer division)\n\n3. The count of all the numbers that appear in the range [1..j] = j - i + 1.\n\nIn order to maintain the actual Fenwick Tree, we need to calculate (x + 1) * x / 2 when asked for the sum of the range [0..x]. Let's store that value in the i-th Fenwick Tree. Then, the total sum of the range [1..j] is i * tree[j] - (j-1) * tree[i-1].\n\nLet's also copy the actual Fenwick Tree, and the prefix sums of the range [1..x] to the i-th Fenwick Tree when asked for the sum of the range [1..x]. The total sum of the range [1..j] is i * copy[j] - (j-1) * copy[i-1].\n\nPutting these steps together, we have the following code.\n\n# Time complexity: O(nlogn)\n# Space complexity: O(n)\nclass FenwickTree:\ndef __init__(self, n: int) -> None:\nself", "groundtruth": " class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o * 2] + sum[o * 2 + 1]             return res         ans = s = 0         last = {}         for i, x in enumerate(nums, 1):             j = last.get(x, 0)             s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j             ans += s             last[x] = i         return ans % 1_000_000_007 "}
{"task_id": "python/37", "content": "\nSample Input\n\nSample Output\n\nhttps://img-blog.csdnimg.cn/20210607104640614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQzMTUyMTQ=,size_16,color_FFFFFF,t_70#pic_center\nhttps://img-blog.csdnimg.cn/20210607104913144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQzMTUyMTQ=,size_16,color_FFFFFF,t_70#pic_center\n\n# 0. 基础算法\n\n## 1. 二分查找\n\n注意二分查找的边界情况；\n\n二分查找可以理解为是一种**顺序查找**，**只是在数组中顺序查找，但是查找的条件改变了**，由“小于”改为了“小于等于”。\n\n### 1.1. 有序数列的二分查找\n\n查找数列是否有某个值。\n\n算法代码如下：\n\n// 假设存在数组nums[]\n\nint binarySearch(int target){\n\nint left = 0, right = nums.length - 1;\n\nwhile (left <= right) {\n\nint mid = (left + right) / 2;\n\nif (nums[mid] == target) {\n\nreturn mid;\n\n} else if (nums[mid] > target) {\n\nright = mid - 1;\n\n} else {\n\nleft = mid + 1;\n\n}\n\n}\n\nreturn -1;\n\n}\n\n时间复杂度：O(logn)\n\n### 1.2. 有序数列的二分查找（另一个版本）\n\n查找数列第一个不小于目标值的下标。\n\n算法", "groundtruth": " class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o * 2] + sum[o * 2 + 1]             return res         ans = s = 0         last = {}         for i, x in enumerate(nums, 1):             j = last.get(x, 0)             s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j             ans += s             last[x] = i         return ans % 1_000_000_007 "}
{"task_id": "python/38", "content": "# Answer:\n class Solution:     def minChanges(self, s: str) -> int:         cnt = 0         for i in range(0, len(s), 2):             if s[i] == '0':                 cnt += 1         return cnt \n\n# Question 143:\nPlease fill in the following incomplete code according to the description. The description is as follows:\nYou are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string. Return the merged string.\nThe incomplete code is as follows:\n class Solution:     def mergeAlternately(self, word1: str, word2: str) -> str:         res = ____         while ____ and ____:             res += ____         return res \nGive only the completed code. Do not output any additional information.\n# Answer:\n class Solution:     def mergeAlternately(self, word1: str, word2: str) -> str:         res = \"\"         while len(word1) > 0 and len(word2) > 0:             res += word1[0]             word1 = word1[1:]             res += word2[0]             word2 = word2[1:]         return res + word1 + word2 \n\n# Question 144:\nPlease fill in the following incomplete code according to the description. The description is as follows:\nGiven a 0-indexed integer array nums, apply the following algorithm to construct a new array answer:\nInitialize two counters i = j = 0.\nwhile i < nums.length and j < nums.length:\nIf nums[i] % 2 == 1, increment i + 1.\nIf nums[j] % 2 == 0, increment j + 1.\nThe answer is the subarray nums[i...j].\nReturn answer. If there is no subarray, return [].\nThe incomplete code is as follows:\n class Solution:     def findSubarray(self, nums: List[int]) -> List[int]:         for i in range(0, len(nums)):             j = i + 1             while j < len(nums):                 if ____ % 2 == 1:                     j +=", "groundtruth": " class Solution:     def minChanges(self, s: str) -> int:         cnt = 0         for i in range(0, len(s), 2):             if len(set(s[i:i + 2])) > 1:                 cnt += 1                 print(s)         return cnt "}
{"task_id": "python/39", "content": "\nAnswer\n f = [0] + [-inf] * target         s = 0         for x in nums:             s = x + max(0, s)             for j in range(s, x - 1, -1):                 # f[j] = max(f[j], f[j - x] + 1)                 if f[j] < f[j - x] + 1:                     f[j] = f[j - x] + 1         return f[-1] if f[-1] > 0 else -1", "groundtruth": " class Solution:     def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:         f = [0] + [-inf] * target         s = 0         for x in nums:             s = min(s + x, target)             for j in range(s, x - 1, -1):                 # f[j] = max(f[j], f[j - x] + 1)                 if f[j] < f[j - x] + 1:                     f[j] = f[j - x] + 1         return f[-1] if f[-1] > 0 else -1 "}
{"task_id": "python/40", "content": "In order to pass the test cases, you need to use the judge.py file.\nYou need to write the judge.py according to the description. The description is as follows:\nThis Python file will be the test module. There are three methods available in the file. The first method is called getInputs, which will be provided by our OJ. The second method is called init, which will be called before the first test case. The third method is called solve, which will be used to solve the problem. Note that if the solve method returns an invalid value, it is marked as Wrong Answer.\nThe code of the Python file is as follows:\n class Main(object):     def getInputs(self) -> List[tuple]:        ...         return [m, n, hFences, vFences]     def init(self) -> None:        ...     def solve(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:         ans =...         if ans > 1_000_000_007:             return -1         return ans \nThe method getInputs will be called once during the testing process.\nThe method init will be called before the first test case.\nThe method solve is the core method. It will be called for each test case.", "groundtruth": " class Solution:     def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:         h = self.f(hFences, m)         v = self.f(vFences, n)         ans = max(h & v, default=0)         return ans ** 2 % 1_000_000_007 if ans else -1      def f(self, a: List[int], mx: int) -> Set[int]:         a.extend([1, mx])         a.sort()         return set(y - x for x, y in combinations(a, 2)) "}
{"task_id": "python/41", "content": "The code used to be as follows:\nclass Solution: def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:    h = self.f(hFences, m)    v = self.f(vFences, n)    ans = -1    for i in range(1, min(m - 1, n - 1) + 1):        temp = sum((i ** 2) * (h & v) for h, v in zip(h, v))        ans = temp if temp > ans else ans    return ans if ans else -1\nclass Solution:def maximizeSquareArea(self,m:int,n:int,hFences:List[int],vFences:List[int]) -> int:    h=self.f(hFences,m)    v=self.f(vFences,n)    ans=-1    for i in range(1,min(m-1,n-1)+1):        temp=sum((i**2)*(h&v) for h,v in zip(h,v))        ans=temp if temp>ans else ans    return ans if ans else -1\nclass Solution:def maximizeSquareArea(self,m:int,n:int,hFences:List[int],vFences:List[int]) -> int:    h=self.f(hFences,m)    v=self.f(vFences,n)    ans=-1    for i in range(1,min(m-1,n-1)+1):        temp=sum((i**2)*(h&v) for h,v in zip(h,v))        ans=temp if temp>ans else ans    return ans if ans else -1\nclass Solution:def maximizeSquareArea(self,m:int,n:int,hFences:List[int],vFences:List[int]) -> int:    h=self.f(hFences,m)    v=self.f(vFences,n)    ans=-1    for i in range(1,min(m-1,n-1)+1):        temp=sum((i**2)*(h&v) for", "groundtruth": " class Solution:     def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:         h = self.f(hFences, m)         v = self.f(vFences, n)         ans = max(h & v, default=0)         return ans ** 2 % 1_000_000_007 if ans else -1      def f(self, a: List[int], mx: int) -> Set[int]:         a.extend([1, mx])         a.sort()         return set(y - x for x, y in combinations(a, 2)) "}
{"task_id": "python/42", "content": "15\n0020\n0020\n0020\n0020\n0020\nclass Solution:\ndef minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\ndis = [[inf] * 26 for _ in range(26)]\nfor i in range(26):\ndis[i][i] = 0\nfor x, y, c in zip(original, changed, cost):\nx = ord(x) - ord('a')\ny = ord(y) - ord('a')\ndis[x][y] = min(dis[x][y], c)\nfor k in range(26):\nfor i in range(26):\nfor j in range(26):\ndis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\nans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))\nreturn ans if ans < inf else -1\n\nQuestion description:\nDescription\nAn integer array nums consists of n distinct positive integers.\nWe can split nums into some number of contiguous subarrays, then let's define the value of nums being split into subarrays as the sum of the values of all the subarrays.\nGiven two integer arrays: nums and jump, where jump[i] means you can jump between nums[i] and nums[i+1] in nums for at most jump[i] times. Return the minimum value of nums being split into subarrays.\nExamples:\nInput: nums = [1,2,3,1], jump = [1,3,1,3] Output: 50 \nExplanation: The minimal value is obtained by splitting nums into [1,2,3] and [1], and then flattening [1,2,3] and [1] to [1,2,3,1]. Example:\nInput: nums = [1,2,3], jump = [1,2,3] Output: 6 \nExplanation: The minimal value is obtained by splitting nums into [1,2,3] and []. Example:\nInput:", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)          for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))         return ans if ans < inf else -1 "}
{"task_id": "python/43", "content": "[input]:\nsource=\"aabbaa\", target=\"ababaa\", original=list(\"aab\"), changed=list(\"bbb\"), cost=[10, 10]\n\n[output]:\n20", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)          for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))         return ans if ans < inf else -1 "}
{"task_id": "python/44", "content": "\n# Solution\n\nA BFS with some state compression. Since the state size is relatively small, we can just compress it into a tuple directly, i.e. the state is 8-tuples (dis[i][j] for i, j in 26 × 26; last[i][j] for i, j in 26 × 26) = (260 × 260) bits. The state space is reduced from n ^ 260 to 260 × 260.\n\ndef minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\ndis = [[inf] * 26 for _ in range(26)]\nfor i in range(26):\n    dis[i][i] = 0\nfor x, y, c in zip(original, changed, cost):\n    x = ord(x) - ord('a')\n    y = ord(y) - ord('a')\n    dis[x][y] = min(dis[x][y], c)\nfor k in range(26):\n    for i in range(26):\n        for j in range(26):\n            dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\nans = 0\nn = len(source)\nqueue = deque([(list(dis), list(dis))])\nwhile queue:\n    dis, last = queue.popleft()\n    for i in range(26):\n        dis[i][i] = 0\n        for j in range(26):\n            dis[i][j] -= dis[i][j] // 2\n    cur = reduce(lambda x, y: x + y, (dis[i][j] for i, j in 26 * 26 for x, y in zip(map(ord, source), map(ord, target)) if x == ord(source[i]) + i and y == ord(target[i]) + j))\n    if cur == 0:\n        return ans\n    while queue:\n        _, last = queue.popleft()\n        for i in range(26):\n            for j in range(26):\n                if dis[i][", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)         for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))         return ans if ans < inf else -1 "}
{"task_id": "python/45", "content": "\n# Writeup\n\nThe first step is to understand the concept of dynamic programming (dp). It is a technique to solve a problem by saving intermediate results during the calculation of the result. To write a dp code, we first need to find a key point and describe the condition for the key point. There are multiple ways to find this condition, and it’s sometimes necessary to prove some mathematical conditions of the program. So there’s usually a lot of work involved in the first round of code writing. If this is your first time writing a dp code, I suggest you not to do it, since it takes a lot of time and effort, which is not very fun.\n\nTo solve this problem, we need a dp array dp[len(source)], which means the minimum cost to convert the source string to the i-th length string in the target string. There’s obviously a recursive definition, i.e., dp[i] = min{dp[j] + cost(source[i - j.. i - 1], target[i - j.. i - 1]) | j in [i - k.. i)}.\n\nThis recursive definition is a very complicated problem, but a lot of mathematical proofs can be made. Because the definition is recursive, when we need to prove it, we need to prove by induction. We need to prove the base case (i = 0, 1, 2, …) as well as the inductive case (i in [1, 2, 3, …)). There’s a common mathematical induction pattern we use for this kind of proofs. As a summary, the mathematical induction is:\n\n1. Prove the base case first.\n2. Assume the inductive case holds (induction hypothesis, h).\n3. Use the mathematical induction hypothesis to prove the conclusion of the induction case (the conclusion of the inductive case).\n4. When the mathematical induction step is finished, the proof is complete.\n\nNow let’s analyze it step by step.\n\nProve the base case. The base case here means if i == 0, 1, 2, …, the answer should be zero since the source string and the target string are exactly the same. Here we only need to consider the cases of i == 1 and i == 2.\n\nFor i = 1, since the minimum", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = min(dis[x][y], c)             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                      continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 "}
{"task_id": "python/46", "content": "If the code does not work properly, do not output any additional information.\nDo not modify the contents of the file. If the file is modified, you will get 0.\n\nThe following is the expected output, which is output in the wrong order, so you can't directly compare the contents of the output with the expected output.\nExpected output:\n-1\nInput:\n\nsource: \"daada\"\ntarget: \"abaab\"\noriginal: [\"daad\",\"dad\",\"d\",\"d\"]\nchanged: [\"aada\",\"dad\",\"ad\",\"a\"]\ncost: [2,1,0,3]\nOutput:\n2\nInput:\n\nsource: \"ab\"\ntarget: \"ba\"\noriginal: [\"ab\",\"b\"]\nchanged: [\"ba\",\"a\"]\ncost: [2,1]\nOutput:\n0\nInput:\n\nsource: \"abc\"\ntarget: \"def\"\noriginal: [\"de\",\"c\",\"f\"]\nchanged: [\"df\",\"d\",\"a\"]\ncost: [1,3,3]\nOutput:\n6\nExplanation: In 3 operations:\n1) Select substring \"ab\" with cost 1.\n2) Select substring \"ab\" with cost 1.\n3) Select substring \"c\" with cost 3.", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = min(dis[x][y], c)             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                       continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 "}
{"task_id": "python/47", "content": "Input\nThe first and only line of input contains two strings source, target, each of length n.\nThe next n lines of input contains n strings original[i], each of length m, and all of them consist of lowercase English characters.\nThe next n lines of input contains n strings changed[i], each of length m, and all of them consist of lowercase English characters.\nThe next n lines of input contains n integers cost[i], each of which is in the inclusive range [1, 1000].\nOutput\nIf it is impossible to convert source to target, print -1. Otherwise, print a single integer, which is the minimum cost to convert the string source to the string target using any number of operations.\n\nExamples\n\ninput\n\noutput\n\n2\n2\nab\nad\n1\nbc\nac\n1\nac\nbc\n1\n\n6\n\n\ninput\n\noutput\n\n7\n7\nabbbbb\naababbb\n2\nabbbbbb\naaaaabbb\n1\naaaa\naaaa\n3\naaaaaa\nabbabb\n3\nabba\nabbba\n2\nabbb\nabbb\n4\nababa\nabbbb\n2\nababb\nababb\n1\nbb\nbb\n1\n\n4\n\nSample Explanation\nExplanation of the sample case\nIn the first example, we can do the following:\n• Convert the 1st and 3rd character of source to the 1st and 3rd characters of target, respectively, and then change source to target. The cost of this operation is 1.\n• For the 2nd operation, we can convert a to b to get ba. And for the 2nd operation, we can convert b to a to get ab. The two operations are independent. In the end, source becomes ababab. In this case, the minimum cost is 1 + 1 + 2 = 4.\n• We can check that there is no way to reduce the cost further, so our answer is 4.\nIn the second example, you can change the ab to a to get a. Then, you can change the b to b. Then, you can convert ab to abba to get the final result. The minimum cost is therefore 4.\n\ninput\n\noutput\n\n7\n7\nababbbb\nbbbbbbb\n1\nababb\nbababb\n1\nbbbb", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = min(dis[x][y], c)             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                       continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 "}
{"task_id": "python/48", "content": "Note that test cases are generated using random test cases generator.\n  # _____\nclass NeighborSum:\n  def __init__(self, grid: List[List[int]]):\n    n = len(grid)\n    self.s = [[[0, 0] for _ in range(4)] for _ in range(n * n)]\n    for i, row in enumerate(grid):\n      for j, v in enumerate(row):\n        for k in range(4):\n          x, y = i + DIRECTIONS[k][0], j + DIRECTIONS[k][1]\n          if 0 <= x < n and 0 <= y < n:\n            self.s[v][k][k // 2] += grid[x][y]\n  \n  def adjacentSum(self, value: int) -> int:\n    return self.s[value][0][0]\n  \n  def diagonalSum(self, value: int) -> int:\n    return self.s[value][1][1]\n# _____\nclass NeighborSum:\n  def __init__(self, grid: List[List[int]]):\n    self.grid = grid\n    self.cache = [[None]*4 for _ in range(len(grid))] # adjacent, top, bottom, left, right, top-left, top-right, bottom-left, bottom-right\n\n  def adjacentSum(self, value: int) -> int:\n    if self.cache[value][0] is None:\n      n = len(self.grid)\n      self.cache[value][0] = sum(self.grid[x][y] for x, y in [(i, j - 1) for i in (0, n-1) for j in (0, n-1)] if value-1 <= x < value+1 and value-1 <= y < value+1)\n    return self.cache[value][0]\n\n  def diagonalSum(self, value: int) -> int:\n    if self.cache[value][1] is None:\n      self.cache[value][1] = self.cache[value][2] = self.cache[value][3] = 0\n      n = len(self.grid)\n      for i in (0, n-1):\n        for j in (0, n-1):\n          if 0 <= i < n and 0 <= j < n", "groundtruth": "\nDIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n  "}
{"task_id": "python/49", "content": "\n# Your neighborSum object will be instantiated and called as such:\n# obj = neighborSum(grid)\n# param_1 = obj.adjacentSum(value)\n# param_2 = obj.diagonalSum(value)\n/src/leetcode/lc0495.py\nclass Solution:\n    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:\n        if len(timeSeries)==0:\n            return 0\n        else:\n            res = 0\n            curr= timeSeries[0]\n            for i in timeSeries:\n                if i <= curr:\n                    res += duration\n                else:\n                    res += i-curr\n                    curr = i\n                res += duration-min(i-curr, duration)\n            return res\n  return True\n    return False\n            \n/src/leetcode/lc1053.py\nclass Solution:\ndef prevPermOpt1(self, A: List[int]) -> List[int]:\n    index = 0\n    for i in range(len(A) - 1, 0, -1):\n        if A[i] < A[i - 1]:\n            index = i\n            break\n    i, j = index - 1, index\n    while i >= 0 and A[i] <= A[j]:\n        i -= 1\n        j -= 1\n    A[i], A[j] = A[j], A[i]\n    return A[index - 1] if j else A[index]\ndef prevPermOpt2(self, A: List[int]) -> List[int]:\n    res = list(reversed(A))\n    i, j = 0, len(res) - 1\n    while i < j:\n        if res[i] > res[j]:\n            break\n        i += 1\n        j -= 1\n    if i < j:\n        res[i], res[j] = res[j], res[i]\n              if num==1:\n                return count\n            num = num//2\n            count+=1\n        \n        return -1\n/src/leetcode/lc1584.py\nclass Solution:\n    def minCost(self, N: str) -> int:\n        num = int(N)\n        count = 0\n        \n        while num!=1:\n/src/leetcode/", "groundtruth": "\nDIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n  "}
{"task_id": "python/50", "content": "'''\nclass Solution:\n    def shortestDistanceAfterQueries(self, nums: int, queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        dist = [0] * n\n        for i in range(1,n):\n            dist[i] = dist[i-1] + (1 if nums[i-1] == 0 else 0)\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            if nums[l] == 0:\n                ans[i] = dist[r-1] - dist[l]\n            else:\n                diff = (1 if nums[l] == 0 else 0)\n                ans[i] = dist[r-1] - (dist[l-1] - diff) - 1\n        return ans'''\nProblem 477\nYou are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\n\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\n\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\n\nNote:\n\nThe number of elements in nums1 and nums2 will be in the range [1, 10000].\n1 <= m, n <= 10000\n1 <= nums1.length <= m + n\n1 <= nums2.length <= n\n-10^9 <= nums1[i], nums2[j] <= 10^9\n'''\n# solution 1\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        nums1[m:] = nums2\n        nums1.sort()\n# solution 2\nclass Solution:\n    def merge(self, nums1", "groundtruth": "\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n "}
{"task_id": "python/51", "content": "\"\"\"# -*- coding:utf-8 -*-\n\"\"\"\nGiven a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\n\nExample:\nGiven a binary tree\n          1\n         / \\\n        2   3\n       / \\     \n      4   5    \nReturn 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\n\nNote: The length of path between two nodes is represented by the number of edges between them.\n\nTags:\n  - Tree\n  - Graph\n  - DFS\n\"\"\"\n\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\n        ans = 1\n\n        def post_order(node: TreeNode) -> int:\n            # 叶子结点的边数一定是 0\n            if not node.left and not node.right:\n                return 0\n\n            max_left = 0\n            if node.left:\n                max_left = post_order(node.left)\n\n            max_right = 0\n            if node.right:\n                max_right = post_order(node.right)\n\n            nonlocal ans\n            ans = max(ans, 1 + max_left + max_right)\n            return max(1 + max_left, 1 + max_right)\n\n        post_order(root)\n        return ans - 1# -*- coding:utf-8 -*-\n\"\"\"\nGiven the root of a binary search tree and two integers low and high, return the number of nodes that lie in the range [low, high].\n\nExample 1:\n    Input: root = [18,null,20,15,27,null,35,19], low = 15, high = 27\n    Output: 2\n    Explanation: Nodes 15 and 27 satisfy the low = 15 and high = 27 constraints.\n\nExample 2:\n    Input: root = [15,7,11,9,", "groundtruth": "\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/52", "content": "\nfrom sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int) -> None:\n        self.tree = [0] * (n + 1)\n\n    def update(self, i: int, val: int) -> None:\n        while i <= len(self.tree):\n            self.tree[i] += val\n            i += i & -i\n\n    def query(self, i: int) -> int:\n        s, c = 0, 0\n        while i > 0:\n            s += self.tree[i]\n            c += (1 << (self.h(i) - 1))\n            i -= i & -i\n        return s, c\n\n    @staticmethod\n    def h(i: int) -> int:\n        return 0 if i == 0 else i.bit_length()\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i ", "groundtruth": "\nfrom sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/53", "content": "'''\nclass FenwickTree:\n    def __init__(self, N):\n        self.tree = [0] * (N + 1)\n\n    def query(self, k):\n        ret = 0\n        while k:\n            ret += self.tree[k]\n            k -= k & -k\n        return ret\n\n    def update(self, k, d):\n        while k <= len(self.tree):\n            self.tree[k] += d\n            k += k & -k\n\n\nclass Solution:\n    def numberOfAlternatingGroups(self, colors: List[int], queries: List[List[int]]) -> List[int]:\n        color_list = [1] * len(colors)\n        color_list[0] = 0\n        colors = [color_list[i] for i in range(len(colors))]\n        print(colors)\n        color_map = {}\n        color_map[0] = color_list[:len(colors) // 2]\n        color_map[1] = color_list[len(colors) // 2:]\n        tree = {}\n        for i in range(len(color_list)):\n            if i in tree:\n                tree[i].update(colors[i])\n            else:\n                tree[i] = FenwickTree(len(colors))\n                tree[i].update(colors[i])\n        result = []\n        for query in queries:\n            if query[0] == 1:\n                size = query[1]\n                count = 0\n                l = SortedList(color_map[0])\n                r = SortedList(color_map[1])\n                print(l)\n                print(r)\n                for i in range(size):\n                    l.rotate()\n                    r.rotate()\n                    count += tree[len(l) - 1].query(len(l))\n                    count += tree[len(r) - 1].query(len(r))\n                    count += len(l) * tree[len(l)].query(len(l))\n                    count += len(r) * tree[len(r)].query(len(r))\n                    print(count)\n                result.append(count)\n            else:\n                print(tree[query[2]].query(query[2]))\n                tree[query[2]].update(color_map[1][query[2]], -1)\n                tree[query[2", "groundtruth": "\nfrom sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/54", "content": "\nIf you find the description is not enough, ask for more details.\n\n/Python/0836.RectangleOverlap.py\n\"\"\"\nYou are given two axis-aligned rectangles: rec1 and rec2, where rec1[0, 1] represents the bottom-left coordinate of the first rectangle and rec1[2, 3] represents the top-right coordinate. Both rectangles are represented as a list [x1, y1, x2, y2], where (x1, y1) are the bottom-left coordinates of the first rectangle, and (x2, y2) are the top-right coordinates.\n\nReturn true if they overlap, otherwise return false.\n\n\nExample 1:\n\n\nInput: rec1 = [0,0,2,2], rec2 = [1,1,3,3]\nOutput: true\nExample 2:\n\n\nInput: rec1 = [0,0,1,1], rec2 = [1,0,2,1]\nOutput: false\n\n\nConstraints:\n\nrect1.length == 4\nrect2.length == 4\n-109 <= rec1[i], rec2[i] <= 109\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/rectangle-overlap\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\"\"\"\n\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        minX = max(rec1[0], rec2[0])\n        minY = max(rec1[1], rec2[1])\n        maxX = min(rec1[2], rec2[2])\n        maxY = min(rec1[3], rec2[3])\n        return max(maxX - minX, 0) * max(maxY - minY, 0) > 0/Python/0350.IntersectionofTwoArraysII.py\n\"\"\"\nGiven two arrays, write a function to compute their intersection.\n\nExample 1:\n\nInput: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput", "groundtruth": "\nclass Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        single=0\ndouble=0\nfor it in nums:\nif it>=10: \ndouble=double+it \nelse:\nsingle=single+it  \n        \nreturn single !=double\n "}
{"task_id": "python/55", "content": "\n'''\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        res = 0\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                tmp = s[i:j]\n                z_count = tmp.count('0')\n                o_count = tmp.count('1')\n                if o_count>= z_count**2:\n                    res+=1\n        return res\n/202101/20210125_1822.find-nth-digit.py\n'''\n1822. Sign of the Product of an Array (Easy)\n\n# In a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times.\n\n# Return the element repeated N times.\n\n \n\n# Example 1:\n\n# Input: A = [5,7,3,9,4,9,8,3,1]\n# Output: 9\n# Example 2:\n\n# Input: A = [1,2,3,4]\n# Output: 2\n \n\n# Constraints:\n\n# 1 <= A.length <= 1000\n# 0 <= A[i] <= 1000\n# There is at most one element that appears an odd number of times.\n\n'''\nclass Solution:\n    def findDuplicate(self, A: List[int]) -> int:\n        dict ={}\n        for i in A:\n            if i in dict:\n                return i\n            else:\n                dict[i] = 1\n        return None\n\nclass Solution:\n    def findDuplicate(self, A: List[int]) -> int:\n        a = sorted(A)\n        for i in range(len(A)-1):\n            if a[i] == a[i+1]:\n                return a[i]\n        return None\n                \n\n\nclass Solution:\n    def findDuplicate(self, A: List[int]) -> int:\n        A = sorted(A)\n        res = 0\n        for i in range(len(A)-1):\n            if A[i]==A[i+1]:\n                res = A[i]\n        return res\n\n\n\n\nclass Solution:\n    def findDuplicate(self, A: List", "groundtruth": "\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n    "}
{"task_id": "python/56", "content": "\nNote:\n1 <= X, Y <= 100\nX, Y, xi, yi, and ri satisfy the following restrictions:\n    1 <= X, Y, xi, yi <= 100\n    X < xi + 2 * ri\n    Y < yi + 2 * ri\ncircles contains no duplicate items.\n\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/path-crossing-in-a-grid\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\"\"\"\n\nfrom typing import List\nclass Solution:\n    def canReachCorner(self, x: int, y: int, circles: List[List[int]]) -> bool:\n        def in_circle(cx: int, cy: int, r: int, x: int, y: int) -> bool:\n            return (cx - x) * (cx - x) + (cy - y) * (cy - y) <= r * r\n        vis = [False] * len(circles)\n\n        def dfs(i):\n            if not vis[i]:\n                vis[i] = True\n                if in_circle(circles[i][0], circles[i][1], circles[i][2], 0, 0) or \\\n                   in_circle(circles[i][0], circles[i][1], circles[i][2], x, y) or \\\n                   dfs(i):\n                    return False\n                return False\n            return True\n\n        for i in range(len(circles)):\n            if not vis[i] and in_circle(circles[i][0], circles[i][1], circles[i][2], 0, 0) \\\n                    or in_circle(circles[i][0], circles[i][1], circles[i][2], x, y):\n                if dfs(i):\n                    return False\n            vis[i] = True\n        return True\n\"\"\"\nYou are given a 2D integer array ratings where ratings[i] is an integer array that represents the ratings of the ith student in a class of students. ratingsij is the rating of the jth student in the ith student's class, and is -1 if the jth student is not present in the", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and \\\n                   (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or \\\n               in_circle(x, y, r, X, Y) or \\\n               not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/57", "content": "\n# 示例\n```\n输入：xCorner = 5, yCorner = 5, circles = [[3,3,1]]\n输出：false\n解释：点 (3,3) 不在圆 (3,3,1) 内，圆的外边框是一条直线，与该点相切。\n\n输入：xCorner = 3, yCorner = 5, circles = [[1,2,2],[2,2,2],[1,3,2]]\n输出：true\n解释：这是一条可行的路径。\n\n```\n\n\n\"\"\"\n\n__author__ = 'DmitrySavitsky'\n\nclass Solution:\n    def canReachCorner(self, xCorner: int, yCorner: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n\n        # dfs 返回是否可以到达 x,y\n        def dfs(i: int) -> bool:\n            if vis[i]: return False\n            vis[i] = True\n            res = True\n            for x, y, r in circles:\n                if in_circle(x, y, r, x, y):  # 如果在圆内，返回 false\n                    return False\n                elif in_circle(xCorner, yCorner, r, x, y):  # 如果在圆外，但在矩形内，继续 dfs\n                    res &= dfs(i)\n            return res\n\n        return dfs(0)  # 0 到 x,y 的路径必然可行\n/src/main/java/com/mitchell/leetcode/editor/cn/P437PathSumIII.java\n//给定一个二叉树，它的每个结点都存放着一个整数值。 \n//\n// 找出路径和等于给定数值的路径总数。 \n//\n// 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and \\\n                   (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or \\\n               in_circle(x, y, r, X, Y) or \\\n               not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/58", "content": "\n### Sample Input 1:\n\nn = 4\nedges = [[0,2],[1,0],[1,2]]\n\nOutput: 2\n\n### Sample Input 2:\n\nn = 5\nedges = [[0,4],[1,4],[2,4],[3,4],[4,4]]\n\nOutput: -1\n\n### Analysis: \n\n### Code:\n```python\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        if visited[start]:\n            return 0\n        visited[start] = True\n        \n        for end in graph[start]:\n            if self.dfs(graph, end, visited) == n:\n                return n + 1\n        return 1\n```\n\n**Time Complexity**:\n\n**Space Complexity**:\n\n\n----\n\n## 1155. Number of Dice Rolls With Target Sum\n\nGiven an integer target and an integer array nums​​​​ where nums is unique, return the number of possible combinations that add up to target.\n\nSince the answer may be too large, return it modulo 10^9 + 7.\n\nThe answer is guaranteed to fit in a 32-bit integer.\n\nA combination of rolls of the dice is called valid if the following conditions are satisfied:\n\nThe sum of the uniques rolls of the dice (not necessarily in a contiguous block) is equal to target.\nNo two rolls are the same (in other words, each roll is unique).\n\n```\nExample 1:\n\nInput: target = 3, nums = [1,2,3,4,5,6]\nOutput: 1\nExplanation: \nYou can try the following rolls: \n1 + 1 + 1 = 3 \n1 + 1 + 2 = 4 \n", "groundtruth": "class Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/59", "content": "\nThe following is a python submission code, you can copy and paste.\nYou can submit only one submission per test case. If you submit multiple times, the most recent one will take effect.\n# Do not include the above import lines.\nimport copy\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        def dfs(graph: List[List[int]], start: int, visited: List[bool]):\n            visited[start] = True\n            for adj_node in graph[start]:\n                if not visited[adj_node]:\n                    dfs(graph, adj_node, visited)\n                    \n        graph = copy.deepcopy(edges)\n        visited = [False for i in range(len(graph))]\n        for start in range(len(graph)):\n            if not visited[start]:\n                dfs(graph, start, visited)\n                \n        for i in range(len(graph)):\n            graph[i].sort()\n            graph[i] = list(set(graph[i]))\n        for i in range(len(graph)):\n            graph[i].append(i)\n        \n        graph.sort()\n        graph = graph[::-1]\n        graph.pop(0)\n        for edge in graph:\n            for node in edge[1:]:\n                if node in edge:\n                    return edge[0]\n        return -1/leetcode/weekly/101~150/307~310/309.py\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        # 动态规划\n        dp = [0] * len(prices)\n        for i in range(len(prices)):\n            dp[i] = max(dp[i - 1] if i - 1 >= 0 else 0, dp[i - 1] - prices[i] if i - 1 >= 0 else -prices[i])\n            if dp[i] > 0:\n                dp[i] = dp[i - 1]\n        return max(0, dp[-1])/leetcode/biweekly/101~200/191~200/194.py\n# Read from the file file.txt and output the tenth line to stdout.\n\n# cat file.txt | tail -n+10 | head", "groundtruth": "class Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/60", "content": "\nIf there are multiple correct answers, return any of them.\n\nConstraints:\n\nn == values.length\n2 <= n <= 105\n0 <= edges.length <= 2 * 105\nedges[i].length == 2\n0 <= ai, bi < n\nai!= bi\nThe given edges represent a valid tree.\n0 <= values[i] <= 100\nSubtask 1: 15 points\nn <= 15\n\nSubtask 2: 10 points\nn <= 100\n\nSubtask 3: 75 points\nn <= 1000\n\nSubtask 4: 15 points\nn <= 105\n\nSubtask 5: 40 points\nn <= 105, edges.length <= 105\n\nSubtask 6: 20 points\nNo further constraints\n\ndef ______\n#     if ____ == 0:\n#         _____ = _____(_____ + _____(dfs(______)))\n#     ____ ______ == 0:\n#         _____ = max(_______, _____)\nreturn ______\n\n\ndef dfs(u, p = -1):\n    ret = ____\n    for v in ______:\n        if ______ == ______:\n            _____ = dfs(_____ + _____(dfs(v, _______)))\n    return ______\n\n\ndef ______(u, p = -1):\n    ______ = ______\n    for v in ______:\n        if ______ == ______:\n            _____ = _____(dfs(v, _______))\n    return ______\n\n\ndef ______(u, p = -1):\n    ______ = ______\n    for v in ______:\n        if ______ == ______:\n            _____ = max(_____ + _____(dfs(v, _______)))\n    return ______\nclass Solution(object):\r\n    def __init__(self):\r\n        self.primes = []\r\n        self.primes_set = set()\r\n\r\n    def countPrimes(self, n):\r\n        \"\"\"\r\n        :type n: int\r\n        :rtype: int\r\n        \"\"\"\r\n        self.count_primes(n)\r\n        return len(self.primes)\r\n\r\n\r\n    def count_primes(self, n):\r\n        if n <=", "groundtruth": "class Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v != p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp1 + nums[u], dp0)\n            \n        return dfs(0)[1]\n"}
{"task_id": "python/61", "content": "def maximumScoreAfterOperations(edges: List[List[int]], nums: List[int]) -> int:\n        # use set, which takes O(1) for both add & find\n        uf = set()\n        for v, w in edges:\n            uf.add((v, w))\n            uf.add((w, v))\n        n = len(nums)\n        uf2 = set()\n        # union find 2, add edges\n        for i in range(n):\n            uf2.add(i)\n            uf.add((i, i))\n            for j in range(i):\n                if i ^ j == 1:\n                    uf.add((i, j))\n                    uf.add((j, i))\n        \n        ans = 0\n        for i in range(n):\n            ans = max(ans, dfs(nums[i], nums[i] << 1, nums[i] << 1, n, i, uf, uf2))\n            # nums[i] << 1, to be able to subtract nums[i] << 1 later, the number should be at least 2 to prevent negative numbers\n        return ans\n                \n\nclass Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        # use set, which takes O(1) for both add & find\n        uf = set()\n        for v, w in edges:\n            uf.add((v, w))\n            uf.add((w, v))\n        n = len(nums)\n        uf2 = set()\n        # union find 2, add edges\n        for i in range(n):\n            uf2.add(i)\n            uf.add((i, i))\n            for j in range(i):\n                if i ^ j == 1:\n                    uf.add((i, j))\n                    uf.add((j, i))\n        \n        ans = 0\n        for i in range(n):\n            ans = max(ans, dfs(nums[i], nums[i] << 1, nums[i] << 1, n, i, uf, uf2))\n            # nums[i] << 1, to be able to subtract nums[i] << 1 later, the number should be at least 2 to prevent negative numbers\n       ", "groundtruth": "class Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v != p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp1 + nums[u], dp0)\n            \n        return dfs(0)[1]\n"}
{"task_id": "python/62", "content": "\n[execution time limit] 10 seconds (py3)\n\n[input] array.integer nums\n\nA non-empty array of distinct integers.\n\nGuaranteed constraints:\n1 ≤ nums.length ≤ 100,\n-1000 ≤ nums[i] ≤ 1000.\n\n[input] integer k\n\nAn integer in the range [1, nums.length].\n\nGuaranteed constraints:\n1 ≤ k ≤ nums.length.\n\n[output] integer\n\nThe maximum possible sum of elements in a balanced subsequence of nums.\n/src/main/java/com/leetcode/L213.java\npackage com.leetcode;\n\npublic class L213 {\n\n    /**\n     * https://leetcode.com/problems/house-robber-ii/\n     *\n     * @param nums\n     * @return\n     */\n    public int rob(int[] nums) {\n        int n = nums.length;\n        if (n == 1) {\n            return nums[0];\n        }\n        return Math.max(rob(nums, 0, n - 1), rob(nums, 1, n));\n    }\n\n    int rob(int[] nums, int lo, int hi) {\n        int prev = 0, cur = 0;\n        for (int i = lo; i < hi; i++) {\n            int tmp = cur;\n            cur = prev + nums[i];\n            prev = Math.max(prev, tmp);\n        }\n        return Math.max(prev, cur);\n    }\n\n}\n/src/main/java/com/leetcode/L19.java\npackage com.leetcode;\n\nimport com.lintcode.util.ListNode;\n\npublic class L19 {\n\n    /**\n     * Given a linked list, remove the n-th node from the end of list and return its head.\n     * The minimum number of nodes in list is n.\n     *\n     * @param head The linked list.\n     * @param n    The integer.\n     * @return: The head of the linked list.\n     */\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode fast = dummy;\n        ListNode slow =", "groundtruth": "class Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/63", "content": "\"\"\"\n\n\"\"\"\nExample:\nInput: nums = [1,2,3,4,5,6,7,8], k = 3\nOutput: 7\nExplanation: The K-or of nums is 7, as the following binary number:\n00000000000000000000000000000111\n\nConstraints:\n1 <= nums.length <= 105\n1 <= nums[i] <= 109\n1 <= k <= nums.length\n\"\"\"\n\"\"\"\n2039. The Time When the Network Becomes Idle\nMedium\n\nThere is an ethernet network wiring the servers at different computer sites. You are given a 2D integer array computers where computers[i] = [dataCenterI, worker1I, worker2I,..., workerNI] indicates that there is a connection between server i, where dataCenterI is the data center server at that computer, and each of the workers1 through n workerI servers are connected to the data center server. Moreover, computer 0 is always connected to dataCenter0 and there exists a path in the network such that any server is accessible from any other server.\nWhen a server is unable to reach all the other servers directly or indirectly through the network, we say the network is idle at that server. More formally, suppose you are at a server and you can reach every other server in the network through the network, or at some other server, where other server is accessible by a path that goes through the network (possibly of length 0). Then, the network is idle at the server.\nFor example, the network at servers [0,1,5] and [[0,1,2,3],[1,2,3]] is idle at servers 1 and 3.\nGiven the array computers, return an array answer, where answer[i] is the earliest time when the network is idle at server i, or -1 if it is impossible.\nAnswer should be returned in increasing order.\nThe network is assumed to be connected.\n\nExample 1:\nInput: computers = [[1,1,1],[1,1,1],[1,1,1]]\nOutput: [-1,0,0]\nExplanation: The network is idle at servers 0 and ", "groundtruth": "class Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for i in range(max(nums).bit_length()):\n            cnt1 = sum(x >> i & 1 for x in nums)\n            if cnt1 >= k:\n                ans |= 1 << i\n        return ans\n"}
{"task_id": "python/64", "content": "\"\"\"\n\n# 2021.03.21 9:03\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n        if sum1 > sum2:\n            i = 0\n            for _ in range(zero1):\n                nums1[i] = 1\n                i += 1\n        elif sum1 < sum2:\n            i = 0\n            for _ in range(zero2):\n                nums2[i] = 1\n                i += 1\n        else:\n            return -1\n        print(sum1)\n        sum1, sum2 = sum(nums1), sum(nums2)\n        if sum1 > sum2:\n            return sum1\n        else:\n            return sum2\n\nclass Solution2:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        if sum1 == sum2:\n            return -1\n\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n        if len(nums2)!= len(nums1):\n            nums2 += [1] * (len(nums1) - len(nums2))\n\n        zero1, zero2 = sum(1 for num in nums1 if num == 0), sum(1 for num in nums2 if num == 0)\n\n        if zero1 > zero2:\n            # 填充的0的个数多 所以需要多填充\n            nums2 += [1] * (zero1 - zero2)\n            for _ in range(zero2):\n                nums1[_] = 1\n        else:\n            nums1 += [1] * (zero2 - zero1)\n            for _ in range(zero1):\n                nums2[_] = 1\n        return sum(nums1)\n\n\nclass Solution3:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        if sum(nums1) == sum(", "groundtruth": "class Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n\n"}
{"task_id": "python/65", "content": "\nExample:\nInput: nums = [1,2,4], k = 5\nOutput: 3\nExplanation: Increment nums to [1,3,4] in 3 operations.\n\nInput: nums = [2,10,3,5,6], k = 1\nOutput: 5\nExplanation: Increment nums to [2,11,3,5,6] in 5 operations. The 2nd and 4th elements are 10 and 6, respectively.\n10 is greater than or equal to 1 and 6 is greater than or equal to 1.\n\n\nConstraints:\nn == nums.length\n1 <= nums.length, k <= 105\n1 <= nums[i] <= 105\n\ndef minIncrementOperations(nums: List[int], k: int) -> int:\n    tempDict = {}\n    result = 0\n    for i in nums:\n        if i in tempDict:\n            tempDict[i] += 1\n        else:\n            tempDict[i] = 1\n    for i in sorted(tempDict):\n        for j in range(i + 1, i + tempDict[i] + 1):\n            if j not in tempDict:\n                result += j - i\n                tempDict[j] = 1\n    return result\n\n\"\"\"\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def generateTrees(self, n: int) -> List[TreeNode]:\n        dp = {}\n        def helper(start, end):\n            nonlocal dp\n            if start > end:\n                return [None]\n            elif start == end:\n                return [TreeNode(start)]\n\n            ans = []\n            for i in range(start, end + 1):\n                leftNodes = helper(start, i - 1)\n                rightNodes = helper(i + 1, end)\n                for left in leftNodes:\n                    for right in rightNodes:\n                        curr = TreeNode(i)\n                        curr.left = left\n                        curr.right = right\n                        ans.append(curr)\n            if start not in dp:\n                dp[start] = ans\n            return ans", "groundtruth": "class Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n        dp1 = dp2 = dp3 = 0\n        for num in nums:\n            dp1, dp2, dp3 = min(dp1, dp2, dp3) + max(0, k - num), dp1, dp2\n        return min(dp1, dp2, dp3)\n"}
{"task_id": "python/66", "content": "\nExample 1:\nInput: edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], coins = [0,4,8,6,0,0,0], k = 3\nOutput: 20\nExplanation:\nThere is an undirected tree rooted at node 0 with 7 nodes: 0, 1, 2, 3, 4, 5, and 6. \n- The node 0 has 0 coins. The coins of its child nodes are 4 + 8 + 0 = 12 and are able to be collected with 12 - 3 = 9 points. \n- The node 1 has 4 coins. The coins of its child nodes are 6 + 0 + 0 = 6 and 0 points. The coins at nodes 4 and 5 are able to be collected with floor(6 / 2) = 3 points each. \n- The node 2 has 8 coins. The coins of its child nodes are 0 + 0 = 0 and 0 points. The coins at nodes 3 and 6 are able to be collected with floor(0 / 2) = 0 points each. \n- The node 3 has 6 coins. The coins of its child nodes are 0 + 0 = 0 and 0 points. The coins at nodes 6 and 6 are able to be collected with floor(0 / 2) = 0 points each. \n- The node 4 has 0 coins. The coins of its child nodes are 0 + 0 + 0 = 0 and 0 points. \n- The node 5 has 0 coins. The coins of its child nodes are 0 + 0 + 0 = 0 and 0 points. \n- The node 6 has 0 coins. The coins of its child nodes are 0 + 0 + 0 = 0 and 0 points. \nThe maximum points we can collect in the undirected tree is 12 + 3 + 3 + 3 + 3 + 3 + 3 = 33 points.\n\n\nExample 2:\nInput: edges = [[0,1],[1,2],[2,3],[3,4", "groundtruth": "class Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i) \n                    if j < 13: \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n"}
{"task_id": "python/67", "content": "```\n## **Solution**\n```py3\nfrom bisect import bisect_right\nfrom functools import reduce\n\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = [0] * (n * 4)\n        todo = [0] * (n * 4)\n\n        def do(o: int, l: int, r: int, add: int) -> None:\n            sum[o] += add * (r - l + 1)\n            todo[o] += add\n\n        # o=1  [l,r] 1<=l<=r<=n\n        # 把 [L,R] 加一，同时返回加一之前的区间和\n        def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:\n            if l > R or r < L:\n                return 0\n            if L <= l <= r <= R:\n                return sum[o] + todo[o] * (r - l + 1)\n            m = (l + r) // 2\n            ans = query_and_add1(o * 2, l, m, L, R) + query_and_add1(o * 2 + 1, m + 1, r, L, R)\n            do(o, l, r, query_and_add1(o * 2, l, m, L, R) - query_and_add1(o * 2 + 1, m + 1, r, L, R))\n            return ans\n\n        ans = s = 0\n        last = {}\n        for i, x in enumerate(nums, 1):\n            j = last.get(x, 0)\n            s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j\n            ans += s\n            last[x] = i\n        return ans % 1_000_000_007\n```\n# 9119. Number of Wonderful Substrings\n```py\nA wonderful string is a string where adjacent characters are chosen from a smaller set of the first 26 lower case English letters. A wonderful substring is any substring", "groundtruth": "\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = [0] * (n * 4)\n        todo = [0] * (n * 4)\n\n        def do(o: int, l: int, r: int, add: int) -> None:\n            sum[o] += add * (r - l + 1)\n            todo[o] += add\n\n        # o=1  [l,r] 1<=l<=r<=n\n        # 把 [L,R] 加一，同时返回加一之前的区间和\n        def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:\n            if L <= l and r <= R:\n                res = sum[o]\n                do(o, l, r, 1)\n                return res\n\n            m = (l + r) // 2\n            add = todo[o]\n            if add:\n                do(o * 2, l, m, add)\n                do(o * 2 + 1, m + 1, r, add)\n                todo[o] = 0\n\n            res = 0\n            if L <= m: res += query_and_add1(o * 2, l, m, L, R)\n            if m < R:  res += query_and_add1(o * 2 + 1, m + 1, r, L, R)\n            sum[o] = sum[o * 2] + sum[o * 2 + 1]\n            return res\n\n        ans = s = 0\n        last = {}\n        for i, x in enumerate(nums, 1):\n            j = last.get(x, 0)\n            s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j\n            ans += s\n            last[x] = i\n        return ans % 1_000_000_007\n"}
{"task_id": "python/68", "content": "The code above is only a framework. Programmer should use the given function stub to implement the solution.\n\nNote: Do not assume that nums is an empty list.\n'''\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        self.tree = [0] * (n * 4)\n        self.todo = [0] * (n * 4)\n        def add(o, l, r, L, R, add):\n            if L <= l <= r <= R:\n                self.todo[o] += add\n            return\n        def query_and_add1(o, l, r, L, R):\n            if L <= l <= r <= R:\n                return self.tree[o] + self.todo[o] * (r - l + 1)\n            else:\n                return 0\n\n        '''\n        # todo: O(n * 3^lg(n))\n        add(1, 0, n-1, L, R, add)\n        add(2, 0, n-1, L-1, R-1, -1)\n        add(3, 0, n-1, L+1, R+1, 1)\n        # tree = [O,L,R,R-L,L+1,R+1]\n        return (query_and_add1(1, 0, n-1, L, R) -  query_and_add1(2, 0, n-1, L, R) - query_and_add1(3, 0, n-1, L, R))\n        '''\n        def update(l, r, L, R, add):\n            if R < l or L > r:\n                return\n            if L <= l <= r <= R:\n                add(1, 0, n-1, L, R, add)\n            else:\n                mid = (l + r) // 2\n                update(l, mid, L, R, add)\n                update(mid+1, r, L, R, add)\n        update(0, n-1, L, R, add)\n        return 0\n\n\n'''\nGiven an array of integers nums, calculate the pivot index of this array.\n\nThe pivot index is the index where the sum of all the numbers", "groundtruth": "\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = [0] * (n * 4)\n        todo = [0] * (n * 4)\n\n        def do(o: int, l: int, r: int, add: int) -> None:\n            sum[o] += add * (r - l + 1)\n            todo[o] += add\n\n        # o=1  [l,r] 1<=l<=r<=n\n        # 把 [L,R] 加一，同时返回加一之前的区间和\n        def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:\n            if L <= l and r <= R:\n                res = sum[o]\n                do(o, l, r, 1)\n                return res\n\n            m = (l + r) // 2\n            add = todo[o]\n            if add:\n                do(o * 2, l, m, add)\n                do(o * 2 + 1, m + 1, r, add)\n                todo[o] = 0\n\n            res = 0\n            if L <= m: res += query_and_add1(o * 2, l, m, L, R)\n            if m < R:  res += query_and_add1(o * 2 + 1, m + 1, r, L, R)\n            sum[o] = sum[o * 2] + sum[o * 2 + 1]\n            return res\n\n        ans = s = 0\n        last = {}\n        for i, x in enumerate(nums, 1):\n            j = last.get(x, 0)\n            s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j\n            ans += s\n            last[x] = i\n        return ans % 1_000_000_007\n"}
{"task_id": "python/69", "content": "\"\"\"\nfrom collections import Counter\n\n\nclass Solution(object):\n    def minChanges(self, s: str) -> int:\n        c = Counter()\n        for ch in s:\n            c[ch] += 1\n        d = len(s) // len(c)\n        m = min(d for d, count in c.items() if not count % d)\n        return m\"\"\"\nThis problem is about implementing a basic elimination algorithm for CCB. If you've ever played scrabble or\nwords with friends (also known as Hangman), then,\n\nyou know that every time you type a letter, \nyour friends only use the ones remaining in the word. \nThat means, if a friend only has a, b, c in her word,\nand you guess a, she will tell you there's a a,\nbut if you guess b, she will only let you use b. \nAnd if you guessed a new letter,\nshe just told you to add it to the word, even if\nit's not there. Given a string, you can guess which letters I\ntyped. \n\nWrite a function to find out how many of my friends are wrong.\n\"\"\"\n# My first thought was to create a trie for the English dictionary, but that is way too slow.\n# Then I thought, instead of having a Trie, I would go with a Map<String, Set<Character>>.\n# This is called a multiset. Because each entry can have multiple entries in the set, which is like a list but not a list.\n# This takes longer though, because of the way Java's collection objects work.\n#\n# So now I realized that instead of having the entries in the multiset sorted, I would reverse the order and keep the multiset in sorted order.\n# That way I would have the set in sorted order, and the entries I would have to add would already be in sorted order.\n# This solution has time complexity of O(nlogn), and space complexity of O(n), because it contains a HashSet for each entry,\n# which has a maximum size of len(dictionary).\n# In python I would use OrderedDict, which works like the Map<String, Set<Character>> except that it keeps the entries in sorted order.\n# In python it works like Java.\nclass Solution:\n    def findNumOfValidWords(self", "groundtruth": "\nclass Solution:\n    def minChanges(self, s: str) -> int:\n        cnt = 0\n        for i in range(0, len(s), 2):\n            if len(set(s[i:i + 2])) > 1:\n                cnt += 1\n                \n        print(s)\n        return cnt\n"}
{"task_id": "python/70", "content": "\nExample 1:\nInput: nums = [3,1,4], target = 6\nOutput: 3\nExplanation: The longest subsequence is [3,1,4]. The sum of 3+1+4 is 8 which is the target.\n\nExample 2:\nInput: nums = [7,1,8,2,9,3,10,4,5,6], target = 10\nOutput: 4\nExplanation: The longest subsequence is [7,8,2,9]. The sum of 7+8+2+9 is 23 which is the target.\n\nExample 3:\nInput: nums = [2,5,3,1,3], target = 10\nOutput: -1\nExplanation: There is no subsequence that can have a sum of target = 10.\n\n\n\"\"\"\nfrom typing import List\n\n\nclass Solution:\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        max_length = -1\n        return max_length\n\n\nif __name__ == '__main__':\n    Solution().lengthOfLongestSubsequence(nums=[2,5,3,1,3], target=10)\n\"\"\"\n674. Longest Continuous Increasing Subsequence\n\nGive you an integer array nums. The value of this array changed over the time.\nReturn the length of the longest continuous increasing subsequence.\n\nExample 1:\nInput: nums = [1,3,5,4,7]\nOutput: 3\nExplanation: The longest continuous increasing subsequence is [1,3,5].\n\nExample 2:\nInput: nums = [2,2,2,2,2]\nOutput: 1\nExplanation: The longest continuous increasing subsequence is [2].\n\n\n\"\"\"\nfrom typing import List\n\n\nclass Solution:\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\n        if len(nums) == 0:\n            return 0\n        max_length = 1\n        temp_length = 1\n        for i in range(1, len(nums)):\n            if nums[i] <= nums[i - 1]:\n                if temp_length > max_length:\n                    max_length = temp_length\n               ", "groundtruth": "\nclass Solution:\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        f = [0] + [-inf] * target\n        s = 0\n        for x in nums:\n            s = min(s + x, target)\n            for j in range(s, x - 1, -1):\n                # f[j] = max(f[j], f[j - x] + 1)\n                if f[j] < f[j - x] + 1:\n                    f[j] = f[j - x] + 1\n        return f[-1] if f[-1] > 0 else -1\n"}
{"task_id": "python/71", "content": "```\n\n\n### 426\n```\nGiven the length of a long rope and two parallel horizontal lines with coordinates x = 0 and x = A, find the minimum number of cuts required to make sure that the rope is cut at most K times if we can cut the rope anywhere along the x-axis, including the endpoints.\nFor example, if the length of the rope is 4 and we can cut the rope at 0, 2, and 4 along the x-axis, 1, 2, 4, and 3 cuts are possible, and the minimum number of cuts would be 3.\n\n```\n\n\n### 430\n```\nYou are given a doubly linked list. Each node has a next and a previous pointer.\n\nAdjust the links between nodes so that they form a single-cycle doubly linked list. There are a few restrictions for these nodes:\n\nThe first node of the doubly linked list has a previous pointer that points to the last node of the doubly linked list.\nThe last node of the doubly linked list has a next pointer that points to the first node of the doubly linked list.\nYou should try to do this in O(1) time and O(1) space (or less).\n\n```\n\n\n### 431\n```\nA stream of values in stream. The values are positive integers, and one of your tasks is to determine the maximum of all possible sums of some sub-array of the array. You can choose the sub-array in O(1) O(1) time, so we define the size of the sub-array as a constant (which is why it's O(1) time). You can define an uninitialized segment of array as having sum 0.\n\nAn example of the input and the expected output are shown below:\n\nInput: stream = [1, 1, 1, 2, 1], K = 2\nOutput: 3\nExplanation: Sub-array [1, 1] would have the maximum sum of 2.\nSub-array [1, 1, 1] would have the maximum sum of 3.\nSub-array [1, 1, 1, 2] would have the maximum sum of 4.\nSub-array [1, 1, 1,", "groundtruth": "\nclass Solution:\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n        h = self.f(hFences, m)\n        v = self.f(vFences, n)\n        ans = max(h & v, default=0)\n        return ans ** 2 % 1_000_000_007 if ans else -1\n\n    def f(self, a: List[int], mx: int) -> Set[int]:\n        a.extend([1, mx])\n        a.sort()\n        return set(y - x for x, y in combinations(a, 2))\n"}
{"task_id": "python/72", "content": "\nfrom typing import List\nclass Solution:\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n        if m < 2 or n < 2:\n            return -1\n\n        area = 0\n        mod = 10**9 + 7\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                area = max(area, i*j)\n\n        hs = set(range(2, m - 1)) - set(hFences)\n        for i in hs:\n            for j in hs:\n                f1 = range(max(2, i - 1), min(m - 1, i + 1) + 1)\n                f2 = range(max(2, j - 1), min(n - 1, j + 1) + 1)\n\n                count = 0\n                for x in f1:\n                    for y in f2:\n                        if 1 < x < m and 1 < y < n:\n                            count += 1\n                area = max(area, count)\n\n        return (area % mod)\n\n\n# solution_2\n\nPlease fill in the following incomplete code according to the description. The description is as follows:\nThere is a large (m - 1) x (n - 1) rectangular field with corners at (1, 1) and (m, n) containing some horizontal and vertical fences given in arrays hFences and vFences respectively. Horizontal fences are from the coordinates (hFences[i], 1) to (hFences[i], n) and vertical fences are from the coordinates (1, vFences[i]) to (m, vFences[i]). Return the maximum area of a square field that can be formed by removing some fences (possibly none) or -1 if it is impossible to make a square field. Since the answer may be large, return it modulo 10**9 + 7. Note: The field is surrounded by two horizontal fences from the coordinates (1, 1) to (1, n) and (m, 1) to (m, n) and two vertical fences from the coordinates (1, 1) to (m, ", "groundtruth": "\nclass Solution:\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n        h = self.f(hFences, m)\n        v = self.f(vFences, n)\n        ans = max(h & v, default=0)\n        return ans ** 2 % 1_000_000_007 if ans else -1\n\n    def f(self, a: List[int], mx: int) -> Set[int]:\n        a.extend([1, mx])\n        a.sort()\n        return set(y - x for x, y in combinations(a, 2))\n"}
{"task_id": "python/73", "content": "\n### C++\nPlease fill in the following incomplete code according to the description. The description is as follows:\nYou are given two 0-indexed strings source and target, both of length n and consisting of lowercase English letters. You are also given two 0-indexed character arrays original and changed, and an integer array cost, where cost[i] represents the cost of changing the character original[i] to the character changed[i]. You start with the string source. In one operation, you can pick a character x from the string and change it to the character y at a cost of z if there exists any index j such that cost[j] == z, original[j] == x, and changed[j] == y. Return the minimum cost to convert the string source to the string target using any number of operations. If it is impossible to convert source to target, return -1. Note that there may exist indices i, j such that original[j] == original[i] and changed[j] == changed[i].\nThe incomplete code is as follows:\n\n#include <vector>\nusing namespace std;\nclass Solution {\npublic:\n    int minimumCost(string source, string target, vector<string>& original, vector<string>& changed, vector<int>& cost) {\n\n    }\n};\n\nNote:\nYou may use the C++ standard template library to solve this problem.\nYou are not allowed to use any built-in function(s) directly to solve this problem.\n/263_丑数/README.md\n题目描述\n263. 丑数\n\n### description\n\n给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。\n丑数 就是只包含质因数 2、3 和/或 5 的正整数。\n\n示例 1：\n\n输入：n = 6\n输出：true\n解释：6 = 2 × 3\n\n示例 2：\n\n输入：n = 8\n输出：true\n解释：8 = 2 × 2 × 2\n\n示例 3：\n\n输入：n = 14\n输出：false\n解释：14 不是丑数，因为它包含了另外一个质因数 7。\n\n示例 4：\n", "groundtruth": "\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        dis = [[inf] * 26 for _ in range(26)]\n        for i in range(26):\n            dis[i][i] = 0\n\n        for x, y, c in zip(original, changed, cost):\n            x = ord(x) - ord('a')\n            y = ord(y) - ord('a')\n            dis[x][y] = min(dis[x][y], c)\n\n        for k in range(26):\n            for i in range(26):\n                for j in range(26):\n                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))\n        return ans if ans < inf else -1\n"}
{"task_id": "python/74", "content": "\nConstraints:\n2 <= source.length, target.length <= 10^5\nsource and target consist of lowercase English letters.\n1 <= original.length <= 2 * 10^5\noriginal.length == changed.length\n1 <= original[i].length, changed[i].length <= 10\noriginal[i] and changed[i] consist of lowercase English letters.\n1 <= cost[i] <= 10^5\n1 <= len(original) <= source.length <= target.length <= 2 * 10^5/problems/1212 - Team Scores in Football Tournament/README.md\nYou are given an integer n. There is a list nums of length n - 1 such that there is exactly one element in nums that is equal to 1 and the rest are equal to 0.\n\nReturn a list answer of length n where answer[i] is the sum of all elements in nums after removing the element at index i (such an element is called a target element).\n \n\nExample 1:\n\nInput: nums = [1,1,1]\nOutput: [2,2,2]\nExplanation: The original array is [1,1,1].\nAfter removing the target element with index 0, [1,1] -> [1,2].\nAfter removing the target element with index 1, [1,2] -> [2,2].\nAfter removing the target element with index 2, [2,2] -> [2,2].\nHence, the answer is [2,2,2].\nExample 2:\n\nInput: nums = [0,1,1,1,1,1]\nOutput: [0,1,2,3,4,8]\nExample 3:\n\nInput: nums = [1,1,1]\nOutput: [2,2,2]\n\nConstraints:\nn == nums.length\n2 <= n <= 10^5\n1 <= nums[i] <= 10^5/problems/2481 - Minimum Total Space Wasted With K Resizing Operations/README.md\nYou are given an m x n integer matrix grid. In one operation, you must resize the grid in the following way:\n\nIf the width of grid is greater than the", "groundtruth": "\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        len_to_strs = defaultdict(set)\n        dis = defaultdict(lambda: defaultdict(lambda: inf))\n        for x, y, c in zip(original, changed, cost):\n            len_to_strs[len(x)].add(x)  \n            len_to_strs[len(y)].add(y)\n            dis[x][y] = min(dis[x][y], c)\n            dis[x][x] = 0\n            dis[y][y] = 0\n\n        for strs in len_to_strs.values():\n            for k in strs:\n                for i in strs:\n                    if dis[i][k] == inf:  \n                        continue\n                    for j in strs:\n                        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        @cache\n        def dfs(i: int) -> int:\n            if i == 0:\n                return 0\n            res = inf\n            if source[i - 1] == target[i - 1]:\n                res = dfs(i - 1) \n            for size, strs in len_to_strs.items():  \n                if i < size:\n                    continue\n                s = source[i - size: i]\n                t = target[i - size: i]\n                if s in strs and t in strs:  \n                    res = min(res, dis[s][t] + dfs(i - size))\n            return res\n        ans = dfs(len(source))\n        return ans if ans < inf else -1\n"}
{"task_id": "python/75", "content": "Note that this test has three test cases that requires a very long time and a very low memory.\n\"\"\"\n\n\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        @lru_cache(None)\n        def dfs(i: int) -> int:\n            if i == 0:\n                return 0\n            return min(\n                dfs(i - 1) + cost[j],  # 切换到前一位后进行选择\n                dfs(j + 1) + cost[k],  # 切换到当前位置后进行选择，当前位切换到前一位\n            ) if source[j] == source[k] else dfs(j + 1) + cost[k] for j, k in zip(range(i), range(i - 1, -1, -1))\n        ans = dfs(len(source))\n        return ans if ans < float('inf') else -1\n# -*- coding: utf-8 -*-\n# @Author: wuyang\n# @Date:   2020-12-30 16:00:03\n# @Last Modified by:   wuyang\n# @Last Modified time: 2020-12-30 16:00:04\n\n\n\"\"\"\nGiven two words word1 and word2, find the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:\nInsert a character\nDelete a character\nReplace a character\nExample 1:\nInput: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\nExample 2:\nInput: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution", "groundtruth": "\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        len_to_strs = defaultdict(set)\n        dis = defaultdict(lambda: defaultdict(lambda: inf))\n        for x, y, c in zip(original, changed, cost):\n            len_to_strs[len(x)].add(x)  \n            len_to_strs[len(y)].add(y)\n            dis[x][y] = min(dis[x][y], c)\n            dis[x][x] = 0\n            dis[y][y] = 0\n\n        for strs in len_to_strs.values():\n            for k in strs:\n                for i in strs:\n                    if dis[i][k] == inf:  \n                        continue\n                    for j in strs:\n                        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        @cache\n        def dfs(i: int) -> int:\n            if i == 0:\n                return 0\n            res = inf\n            if source[i - 1] == target[i - 1]:\n                res = dfs(i - 1) \n            for size, strs in len_to_strs.items():  \n                if i < size:\n                    continue\n                s = source[i - size: i]\n                t = target[i - size: i]\n                if s in strs and t in strs:  \n                    res = min(res, dis[s][t] + dfs(i - size))\n            return res\n        ans = dfs(len(source))\n        return ans if ans < inf else -1\n"}
{"task_id": "cpp/0", "content": "#include <iostream>\n#include <vector>\nusing namespace std;\nclass Solution {public:\nstatic const int mod = 1e9 + 7;\nint specialPerm(vector<int>& nums) {\nint n = nums.size();\nvector<vector<int>> f(1 << n, vector<int>(n, -1));\nfunction<int(int, int)> dfs = [&](int state, int i) {\nif (f[state][i]!= -1) return f[state][i];\nif (state == (1 << i)) return 1;\nf[state][i] = 0;\nfor (int j = 0; j < n; j++) {\nif (i == j ||!(state >> j & 1)) continue;\nif (nums[i] % nums[j]!= 0 && nums[j] % nums[i]!= 0) continue;\nf[state][i] = (f[state][i] + dfs(state ^ (1 << i), j)) % mod;\n}\nreturn f[state][i];\n};\nint res = 0;\nfor (int i = 0; i < n; i++) {\nres = (res + dfs(1 << i, i)) % mod;\n}\nreturn res;\n}\n};\n\n### Leetcode 1154: Day of the Year\n\nPlease fill in the following incomplete code according to the description. The description is as follows:\nGiven a year year and a month month and a day day, return the corresponding day of the year.For example, February 1, 2022 is the 34th day.\nThe incomplete code is as follows:\nclass Solution {public:int dayOfYear(string date) {string s = \"2021-02-24\";string t = \"2021-03-01\";int day1 = ____(stoi(s.substr(8)), stoi(s.substr(5, 2)));int day2 = ____(stoi(t.substr(8)), stoi(t.substr(5, 2)));return day1 + (stoi(date.substr(8)) - day2);}};\nGive only the completed code. Do not output any additional information.", "groundtruth": "class Solution {public:static const int mod = 1e9 + 7;int specialPerm(vector<int>& nums) {int n = nums.size();vector<vector<int>> f(1 << n, vector<int>(n, -1));function<int(int, int)> dfs = [&](int state, int i) {if (f[state][i] != -1) {return f[state][i];}if (state == (1 << i)) {return 1;}f[state][i] = 0;for (int j = 0; j < n; j++) {if (i == j || !(state >> j & 1)) {continue;}if (nums[i] % nums[j] != 0 && nums[j] % nums[i] != 0) {continue;}f[state][i] = (f[state][i] + dfs(state ^ (1 << i), j)) % mod;}return f[state][i];};int res = 0;for (int i = 0; i < n; i++) {res = (res + dfs((1 << n) - 1, i)) % mod;}return res;}};"}
{"task_id": "cpp/1", "content": "Sample 1:\nInput: cost = [3,1,3,1,3,1], time = [1,3,1,3,2,2]\nOutput: 8\nExplanation: We choose to paint the first and third walls in 1 unit of time at a cost of 3 each. We then choose to paint the second and fourth walls in 3 units of time at a cost of 1 each. We then choose to paint the fifth and sixth walls in 2 units of time at a cost of 2 each. The total cost = 3 + 3 = 6 and the total time = 1 + 3 + 1 + 3 + 2 + 2 = 11. So an optimal solution is:\nPaint wall 1 and 3 in 1 unit of time at a cost of 3.\nPaint wall 2 and 4 in 3 units of time at a cost of 1.\nPaint wall 5 and 6 in 2 units of time at a cost of 2.\nWe can show that an optimal solution can be achieved with cost <= 8 and time <= 11, but not with any less cost or time.\nConstraints:\nn == cost.size() == time.size()\n1 <= n <= 100\n1 <= cost[i], time[i] <= 100\n*/\n#include <bits/stdc++.h>\nusing namespace std;\nclass Solution {\n   public:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        int n = cost.size();\n        vector<int> f(n * 2 + 1, INT_MAX / 2);\n        f[n] = 0;\n        for (int i = 0; i < n; ++i) {\n            vector<int> g(n * 2 + 1, INT_MAX / 2);\n            for (int j = 0; j <= n * 2; ++j) {\n                // 付费____// 免费\n                if (j > 0) {\n                    g[j - 1] = min(g[j - 1], f[j]);\n                }\n            }\n            f = move(g);\n        }\n        return *min_element(f.begin() + n, f.end());\n   ", "groundtruth": "class Solution {public:int paintWalls(vector<int>& cost, vector<int>& time) {int n = cost.size();vector<int> f(n * 2 + 1, INT_MAX / 2);f[n] = 0;for (int i = 0; i < n; ++i) {vector<int> g(n * 2 + 1, INT_MAX / 2);for (int j = 0; j <= n * 2; ++j) {// 付费g[min(j + time[i], n * 2)] = min(g[min(j + time[i], n * 2)], f[j] + cost[i]);// 免费if (j > 0) {g[j - 1] = min(g[j - 1], f[j]);}}f = move(g);}return *min_element(f.begin() + n, f.end());}};"}
{"task_id": "cpp/2", "content": "\n• +321\n\n » 10 days ago, # |   0\n » 10 days ago, # |   0\n•  » » 10 days ago, # ^ |   +5 Yes, you need to look at the position of the 'a' after finding the first character not equal to 'a'.\n•  » » 10 days ago, # ^ |   +5 You need to find the first occurrence after the first non-a character which has 'a' after it. If it can't be found, then you can replace it by a z in the string.", "groundtruth": "class Solution {public:string smallestString(string s) {char target = 'a';auto it = std::find_if(s.begin(), s.end(), [target](char c) {return c != target;});int indexOfFirstNonA = std::distance(s.begin(), it);if (indexOfFirstNonA == s.length()) {return s.substr(0, s.length() - 1) + 'z';}size_t indexOfFirstA_AfterFirstNonA = s.find('a', indexOfFirstNonA);if (indexOfFirstA_AfterFirstNonA == string::npos) {indexOfFirstA_AfterFirstNonA = s.length();}string res;for (int i = 0; i < s.length(); ++i) {if (indexOfFirstNonA <= i && i < indexOfFirstA_AfterFirstNonA) {res.push_back(static_cast<char>(s[i] - 1));} else {res.push_back(s[i]);}}return res;}};"}
{"task_id": "cpp/3", "content": "\n#### Example 1\n\nInput: nums = [3,1,5,8], x = 7\nOutput: 17\nExplanation: If we perform:\n- Choose the 0th element: [3,1,5,8] -> [7,1,5,8]\n- Choose the 3rd element: [7,1,5,8] -> [7,1,5,0]\nThen we have 7 + 1 + 5 + 0 = 17.\n\n#### Example 2\n\nInput: nums = [1,2,4,2,1], x = 3\nOutput: 16\nExplanation: If we perform:\n- Choose the 1st element: [1,2,4,2,1] -> [3,2,4,2,1]\n- Choose the 3rd element: [3,2,4,2,1] -> [3,2,4,2,0]\nThen we have 3 + 2 + 4 + 2 = 16.\n\nConstraints:\n\n• n == nums.length\n• 1 <= n <= 105\n• 1 <= nums[i], x <= 109\ndef minCost(self, nums: List[int], x: int) -> int:\n", "groundtruth": "class Solution {public:long long minCost(vector<int>& nums, int x) {int n = nums.size();vector<int> f(nums);long long ans = accumulate(f.begin(), f.end(), 0LL);for (int k = 1; k < n; ++k) {for (int i = 0; i < n; ++i) {f[i] = min(f[i], nums[(i + k) % n]);}ans = min(ans, static_cast<long long>(k) * x + accumulate(f.begin(), f.end(), 0LL));}return ans;}};"}
{"task_id": "cpp/4", "content": "Sample Input 1:\nnums1 = [9,8,2], nums2 = [4,4,3], queries = [[3,7],[1,3],[4,5]]\nOutput 1:\n[-1,4,7]\nExplanation 1:\nFor the first query, there is no index such that nums1[j] >= 3 and nums2[j] >= 7. Hence the answer is -1.\nFor the second query, there are two indicies such that nums1[j] >= 1 and nums2[j] >= 3 (i.e. j = 0 and j = 2). However, it can be proven that neither nums1[0] + nums2[0] nor nums1[2] + nums2[2] are the maximum of those values, thus the answer is 4.\nFor the third query, the optimal index is 1. nums1[1] + nums2[1] is 7, and it is the maximum among the three choices.\nSample Input 2:\nnums1 = [3,2,4,6], nums2 = [5,10,8,1], queries = [[10,7],[2,4],[8,10]]\nOutput 2:\n[19,15,22]\nExplanation 2:\nFor the first query, nums1[0] + nums2[3] is 9 and 9 is the maximum value.\nFor the second query, nums1[1] + nums2[0] is 7 and nums1[2] + nums2[1] is 9. Thus the maximum sum of the values chosen is 15.\nFor the third query, there are two indices such that nums1[i] + nums2[j] is maximum among all the indices. The indices i and j are 0 and 3 respectively. We then have 3 * 5 = 15.\nRelated LeetCode Problems:\n7200. Two Week Holiday Experiences (Hard)\n7201. Find the Middle Index in Array (Easy)\n7202. Maximum Number of Balloons (Easy)\n7203. Number of Weeks for Which You Will Have Enough Funds (Easy)\n*/\n/solutions/71", "groundtruth": "class Solution {public:vector<int> maximumSumQueries(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {vector<pair<int, int>> sortedNums;vector<tuple<int, int, int>> sortedQueries;for (int i = 0; i < nums1.size(); i++) {sortedNums.emplace_back(nums1[i], nums2[i]);}sort(sortedNums.begin(), sortedNums.end(), greater<pair<int, int>>());for (int i = 0; i < queries.size(); i++) {sortedQueries.emplace_back(i, queries[i][0], queries[i][1]);}sort(sortedQueries.begin(), sortedQueries.end(), [](tuple<int, int, int> &a, tuple<int, int, int> &b) {return get<1>(a) > get<1>(b);});vector<pair<int, int>> stk;vector<int> answer(queries.size(), -1);int j = 0;for (auto &[i, x, y] : sortedQueries) {while (j < sortedNums.size() && sortedNums[j].first >= x) {auto [num1, num2] = sortedNums[j];while (!stk.empty() && stk.back().second <= num1 + num2) {stk.pop_back();}if (stk.empty() || stk.back().first < num2) {stk.emplace_back(num2, num1 + num2);}j++;}int k = lower_bound(stk.begin(), stk.end(), make_pair(y, 0)) - stk.begin();if (k < stk.size()) {answer[i] = stk[k].second;}}return answer;}};"}
{"task_id": "cpp/5", "content": "\n\"\"\"\n\n\nclass Solution(object):\n    def longestSemiRepetitiveSubstring(self, s):\n        ans = 1\n        left = 0\n        same = 0\n        n = len(s)\n        for right in range(1, n):\n            if s[right] == s[right - 1] and same == 0:\n                same = 1\n            elif s[right] == s[right - 1] and same > 0:\n                same = 1\n                left = right - 1\n            else:\n                same = 0\n            ans = max(ans, right - left + 1)\n        return ans\n/problems/557/description.txt\n\nhttps://leetcode.com/problems/reverse-words-in-a-string-iii/\nReverse Words in a String III\nMedium\n\n606\n\n1760\n\nFavorite\n\nShare\nGiven a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.\n\nExample 1:\nInput: \"Let's take LeetCode contest\"\nOutput: \"s'teL ekat edoCteeL tsetnoc\"\n\nNote: In the string, each word is separated by single space and there will not be any extra space in the string.\n\n\n\"\"\"\n\n\nclass Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def reverse(start):\n            end = start\n            while end < n:\n                if s[end]!= \" \":\n                    end += 1\n                else:\n                    break\n            if start == end:\n                end += 1\n            j = end - 1\n            while start < j:\n                s[start], s[j] = s[j], s[start]\n                start += 1\n                j -= 1\n            return end\n        s = list(s)\n        n = len(s)\n        start = 0\n        end = 0\n        while start < n:\n            if s[start]!= \" \":\n                end = reverse(start)\n            else:\n                end = start\n            start = end\n        reverse(start)\n        return \"\".join(s)/problems/128/description.txt\nhttps://leetcode.com/problems/longest-consecutive-sequence/\n\n128", "groundtruth": "class Solution {public:int longestSemiRepetitiveSubstring(string s) {int ans = 1, left = 0, same = 0, n = s.length();for (int right = 1; right < n; right++) {if (s[right] == s[right - 1] && ++same > 1) {for (left++; s[left] != s[left - 1]; left++);same = 1;}ans = max(ans, right - left + 1);}return ans;}};"}
{"task_id": "cpp/6", "content": "Note:\n1 <= nums.length <= 105\n1 <= nums[i], d <= 109\ns[i] is either 'L' or 'R'.\nYou may assume that the robots would eventually meet at some integer position and not get stuck.\n\n## Solution\n\nApproach 1: Prefix Sums\nIntuition\n\nNote: We are reversing the process of getting the answer. If we add one for every second and we are subtracting the same amount every second, the sum of all of the differences will be zero after one second (or at most one second).\n\nAlgorithm\n\nLet us define L[i] to be the position of the ith robot before we start moving. Also, let's define R[i] to be the position of the ith robot after we start moving. Then we want to find the sum of R[i] - L[i] for all i.\n\nThe first robot moves with a sign of 1 (because it is moving to the right). From this, we can restate the position change of the second robot in terms of position change of the first robot: L[1] - L[0] = R[1] - R[0]. Then we can move to the third robot in the same way:\nL[2] - L[0] = R[2] - R[1]\nL[3] - L[0] = R[3] - R[2]\n...\n\nSo in general, for the ith robot:\nL[i] - L[0] = R[i] - R[i-1]\n\nSince this is a prefix sum, and since the L[0] = -R[0] = nums[0], we can relate the positions to the current values of i.\n\nNow we need to relate the positions to the distances that the robots move in total. The positions are moving with velocity 1, and so each move needs to be divided by one second. So we have:\nL[i] / i = (R[i] - R[i-1]) / (i - 1)\n\nSo the total distance for each robot is:\ntotal = sum (i) (R[i] - R[i-1]) = sum (i) (R[i] - L[i", "groundtruth": "class Solution {public:static constexpr int mod = 1e9 + 7;int sumDistance(vector<int>& nums, string s, int d) {int n = nums.size();vector<long long> pos(n);for (int i = 0; i < n; i++) {if (s[i] == 'L') {pos[i] = (long long) nums[i] - d;} else {pos[i] = (long long) nums[i] + d;}}sort(pos.begin(), pos.end());long long res = 0;for (int i = 1; i < n; i++) {res += 1ll * (pos[i] - pos[i - 1]) * i % mod * (n - i) % mod;res %= mod;}return res;}};"}
{"task_id": "cpp/7", "content": "If you write the description, explaination, and test case wrongly, you will get \"Wrong Answer\", even though the code is correct.\n#define __ {int ans = 0;int cnt = 0;for (int i = 0; i < m; i++) {cnt = 0;for (int j = 0; j < n; j++) {cnt += (grid[i][j] << j);ans |= (grid[i][j] << j);}if (cnt > m * n / 2) {return {i};}}return {0};}\nSample 1\nInput:grid = [[0,0],[0,0]]\nOutput:[0,0]\nExplanation: There are 4 good subsets of grid:\n1. Choose rows [0] and [1]\n2. Choose rows [0]\n3. Choose rows [1]\n4. Choose no rows\nNone of these sets has length 1, so [0,0] is the first good subset.\nSample 2\nInput:grid = [[1,0],[0,1]]\nOutput:[1,0]\nExplanation:\n[1,0] has a length of 1, which is at most the half of the grid.\n[0,1] has a length of 1, which is at most the half of the grid.\nThus, [1,0] is the only good subset.\nSample 3\nInput:grid = [[0,1],[1,1]]\nOutput:[0,1]\nExplanation: Choose either row 0 or 1.\nNotice that [[0,1],[0,0]] and [[1,1],[0,0]] are not good subsets as they don't have a length of 1./algorithms/leetcode/0215. Kth Largest Element in an Array/ReadMe.md\n# 215. Kth Largest Element in an Array\nGiven an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nYou must solve it in O(n) time complexity.\nExample 1:\nInput: nums = [3,2,1,5,6,4], k = 2\nOutput: 5", "groundtruth": "class Solution {public:vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {vector<int> ans;unordered_map<int, int> mp;int m = grid.size();int n = grid[0].size();for (int j = 0; j < m; j++) {int st = 0;for (int i = 0; i < n; i++) {st |= (grid[j][i] << i);}mp[st] = j;}if (mp.count(0)) {ans.push_back(mp[0]);return ans;}for (auto [x, i]: mp) {for (auto [y, j]: mp) {if (!(x & y)) {return {min(i, j), max(i, j)};}}}return ans;}};"}
{"task_id": "cpp/8", "content": "##### Note:\n\n• 1 <= n <= 3 * 105\n• 0 <= queries.length <= 3 * 105\n• queries[i].length == 3\n• 0 <= typei, indexi, vali <= n - 1\n• 0 <= i < queries.length\n##### Constraints:\n• 1 <= n <= 3 * 105\n• 0 <= queries.length <= 3 * 105\n• queries[i].length == 3\n• 0 <= typei, indexi, vali <= n - 1\n• 0 <= i < queries.length\n• The total number of queries is in the range [1, 3 * 105]\nExample 1:\nInput: n = 3, queries = [[0,0,2],[1,1,1],[1,2,2],[1,0,1],[0,0,2],[0,1,1],[1,1,1],[0,2,1],[1,2,2],[0,1,1]]\nOutput: 14\nExplanation: The grid looks like this:\n[[0,2,0],[2,0,0],[0,1,1]]\nYou have 2 queries:\ntypei=0:\nrow 0: all positions are changed to 2. The matrix becomes: [[2,2,2],[2,0,2],[2,1,1]]\ntypei=1:\ncolumn 1: all positions are changed to 1. The matrix becomes: [[2,2,2],[2,1,2],[2,1,1]]\ntypei=0:\nrow 0: all positions are changed to 1. The matrix becomes: [[1,1,1],[1,1,2],[1,1,1]]\ntypei=1:\ncolumn 1: all positions are changed to 2. The matrix becomes: [[1,1,1],[1,2,2],[1,1,1]]\ntypei=0:\nrow 0: all positions are changed to 2. The matrix becomes: [[2,2,2],[2,2,2],[2,1,1]]\ntypei=1:\ncolumn 2: all positions are changed to 2", "groundtruth": "class Solution {public:long long matrixSumQueries(int n, vector<vector<int>> &queries) {long long ans = 0;unordered_set<int> vis[2];for (int i = queries.size() - 1; i >= 0; i--) {auto &q = queries[i];int type = q[0], index = q[1], val = q[2];if (!vis[type].count(index)) { // 后面（>i）没有对这一行/列的操作// 这一行/列还剩下 n-vis[type^1].size() 个可以填入的格子ans += (long long) (n - vis[type ^ 1].size()) * val;vis[type].insert(index);}}return ans;}};"}
{"task_id": "cpp/9", "content": "Please provide the template string and the complete code in the appropriate text boxes.\nThere are 2 problems. Each of them contains the code template. You should only provide code for the specified problem. Do not modify other parts of the code.\nThe code you complete in the template should be valid and correct. Otherwise, you will get Wrong Answer.\nIn one test, each of the two functions get() and count() should be called exactly once each.\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n\n10763\n\n#### Description\n\nYou are given a string s, a string t, two positive integers min_len and max_len, and two non-empty strings source and target. You have to answer four queries in this problem. The queries are described in the following:\nQ1: How many times does string t appear in s such that its length is in range [min_len, max_len]?\nQ2: In the answer of Q1, how many times does string source appear in the answer?\nQ3: How many times does string t appear in s such that its length is in range [min_len, max_len] and no other substring of t appears in s at the same time?\nQ4: In the answer of Q3, how many times does string source appear in the answer?\nHere, we define \"the same substring\" as one of the following:\n\n• \"the substring before or after position x of s and x is the same as the substring before or after position y of s\"\n• \"the substring before or after position x of s and x is the same as the substring before or after position y of t\"\n\nFor example, if s=\"ab\" and t=\"b\", then:\n\n• substring before or after position 0 of s is \"\"\n• substring before or after position 1 of s is \"a\", then substring before or after position 1 of t is \"\"\n• substring before or after position 1 of s is \"b\", then substring before or after position 1 of t is \"b\"\n\nSince both t and source are non-empty, there always exists a substring of t or source that appears in s, that is, the answer to this problem is positive.\n\nThe string s and t are guaranteed to have length at least one.\n\nThe input is guaranteed to be", "groundtruth": "class Solution {static constexpr int N = 23;static constexpr int M = 401;static constexpr int MOD = 1e9 + 7;int d[N][M];string num;int min_sum;int max_sum;int dfs(int i, int j, bool limit) {if (j > max_sum) {return 0;}if (i == -1) {return j >= min_sum;}if (!limit && d[i][j] != -1) {return d[i][j];}int res = 0;int up = limit ? num[i] - '0' : 9;for (int x = 0; x <= up; x++) {res = (res + dfs(i - 1, j + x, limit && x == up)) % MOD;}if (!limit) {d[i][j] = res;}return res;}int get(string num) {reverse(num.begin(), num.end());this->num = num;return dfs(num.size() - 1, 0, true);}// 求解 num - 1，先把最后一个非 0 字符减去 1，再把后面的 0 字符变为 9string sub(string num) {int i = num.size() - 1;while (num[i] == '0') {i--;}num[i]--;i++;while (i < num.size()) {num[i] = '9';i++;}return num;}public:int count(string num1, string num2, int min_sum, int max_sum) {memset(d, -1, sizeof d);this->min_sum = min_sum;this->max_sum = max_sum;return (get(num2) - get(sub(num1)) + MOD) % MOD;}};"}
{"task_id": "cpp/10", "content": "*/\n\n// Solution 1\nclass Solution {\npublic:\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\n        int n = mat.size(), m = mat[0].size();\n        unordered_map<int, pair<int, int>> mp;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                mp[mat[i][j]] = {i, j};\n            }\n        }\n\n        vector<int> rowCnt(n, 0);\n        vector<int> colCnt(m, 0);\n        for (int i = 0; i < arr.size(); ++i) {\n            auto v = mp[arr[i]];\n            ++rowCnt[v.first];\n            if (rowCnt[v.first] == m) {\n                return i;\n            }\n            ++colCnt[v.second];\n            if (colCnt[v.second] == n) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};\negin(), arr.end());\n    int l = lower_bound(arr.begin(), arr.end(), target) - arr.begin();\n    int r = upper_bound(arr.begin(), arr.end(), target) - arr.begin();\n    return r - l;\n}\n\nint main() {\n    vector<int> arr{1, 3, 3, 5, 6, 6, 6, 8, 9, 9};\n    int target = 6;\n    cout << \"No. of occurences: \" << count_element(arr, target) << \"\\n\";\n    return 0;\n}\n/2020/algorithms/Searching/CountElement_LinearSearch.cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Using Linear Search\nint count_element(vector<int> arr, int target) {\n    if (arr.empty()) {\n        return 0;\n    }\n    if (target < arr[0]) {\n        return 0;\n    }\n    if (target > arr.back()) {\n        return 0;\n    }\n\n    sort(arr.b", "groundtruth": "class Solution {public:int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {int n = mat.size();int m = mat[0].size();unordered_map<int, pair<int, int>> mp;for (int i = 0; i < n; ++i) {for (int j = 0; j < m; ++j) {mp[mat[i][j]] = {i, j};}}vector<int> rowCnt(n, 0);vector<int> colCnt(m, 0);for (int i = 0; i < arr.size(); ++i) {auto& v = mp[arr[i]];++rowCnt[v.first];if (rowCnt[v.first] == m) {return i;}++colCnt[v.second];if (colCnt[v.second] == n) {return i;}}return -1;}};"}
{"task_id": "cpp/11", "content": "Sample 1\nInput:start = [1, 10], target = [1, 6], specialRoads = [[1, 2, 2, 10, 1], [3, 2, 4, 5, 1], [1, 6, 3, 6, 1]]\nOutput:6\nDescription of input:start = [1, 10], target = [1, 6],specialRoads = [[1, 2, 2, 10, 1], [3, 2, 4, 5, 1], [1, 6, 3, 6, 1]]\nDescription of output:return6\n\nExample 2\nInput:start = [2, 2], target = [3, 4], specialRoads = [[3, 2, 4, 1, 1]]\nOutput: 5\nDescription of input:start = [2, 2], target = [3, 4], specialRoads = [[3, 2, 4, 1, 1]]\nDescription of output: return 5\n\nSolution\nWe define a distance function to return the shortest path from the start position to the target position. The distance function is a complete function and the shortest path. Here we use Dijkstra algorithm to find the shortest path.\nclass Solution {\npublic int minimumCost(int[] start, int[] target, List<List<Integer>> specialRoads) {\nint x = (start[0] << 1) | 1, y = start[1];\nx = x << 1 | 1;\ny = y << 1 | 1;\ntarget[0] = target[0] << 1 | 1;\ntarget[1] = target[1] << 1 | 1;\nHashSet<Integer> vis = new HashSet<>();\nMap<Integer, Integer> dis = new HashMap<>();\nfor(int s : vis)\ncontinue;\nList<int[]> v = new ArrayList<>();\nfor (int[] p : specialRoads)\nfor(int[] n : v) {\nif (!vis.contains(p[4]))\ndis.put(p[4], Math.min(dis.getOrDefault(p[4], Integer.MAX_VALUE),\n", "groundtruth": "class Solution {public:int minimumCost(vector<int> &start, vector<int> &target, vector <vector<int>> &specialRoads) {using LL = long long;LL t = (LL) target[0] << 32 | target[1];unordered_map<LL, int> dis = {{(LL) start[0] << 32 | start[1], 0}, {t, INT_MAX}};unordered_set<LL> vis;for (;;) {LL v = -1;int dv = -1;for (auto &[p, d]: dis)if (!vis.count(p) && (dv < 0 || d < dv))v = p, dv = d;if (v == t) return dv; // 到终点的最短路已确定vis.insert(v);int vx = v >> 32, vy = v & UINT32_MAX;// 更新到终点的最短路dis[t] = min(dis[t], dv + target[0] - vx + target[1] - vy);for (auto &r: specialRoads) {int d = dv + abs(r[0] - vx) + abs(r[1] - vy) + r[4];LL w = (LL) r[2] << 32 | r[3];if (!dis.count(w) || d < dis[w])dis[w] = d;}}}};"}
{"task_id": "cpp/12", "content": "\nSolution\n\nA string is beautiful if:It consists of the first k letters of the English lowercase alphabet.It does not contain any substring of length 2 or more which is a palindrome.You are given a beautiful string s of length n and a positive integer k.Return the lexicographically smallest string of length n, which is larger than s and is beautiful. If there is no such string, return an empty string.A string a is lexicographically larger than a string b (of the same length) if in the first position where a and b differ, a has a character strictly larger than the corresponding character in b.For example, \"abcd\" is lexicographically larger than \"abcc\" because the first position they differ is at the fourth character, and d is greater than c.\n\n# Solution by \n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\nstring smallestBeautifulString(string s, int k) {\nfor (int i = s.size() - 1; i >= 0; --i) {\nunordered_set<char> blockedCharacters;\nfor (int j = 1; j <= 2; ++j) {\nif (i - j >= 0) {\nblockedCharacters.insert(s[i - j]);\n}\n}\nfor (int j = 1; j <= 3; ++j) {\nif (s[i] - 'a' + j + 1 <= k && blockedCharacters.find(s[i] + j) == blockedCharacters.end()) {\nreturn generate(s, i, j);\n}\n}\n}\nreturn \"\";\n}\n\nstring generate(string s, int idx, int offset) {\ns[idx] += offset;\nfor (int i = idx + 1; i < s.size(); ++i) {\nunordered_set<char> blockedCharacters;\nfor (int j = 1; j <= 2; ++j) {\nif (i - j >= 0) {\nblockedCharacters.insert(s[i - j]);\n}\n}\nfor (int j = 0; j < 3; ++j) {\nif (blockedCharacters.find('a' + j) == blockedCharacters.end", "groundtruth": "class Solution {public:string smallestBeautifulString(string s, int k) {for (int i = s.length() - 1; i >= 0; --i) {unordered_set<char> blockedCharacters;for (int j = 1; j <= 2; ++j) {if (i - j >= 0) {____}}for (int j = 1; j <= 3; ++j) {if (s[i] - 'a' + j + 1 <= k && blockedCharacters.find(s[i] + j) == blockedCharacters.end()) {return generate(s, i, j);}}}return \"\";}string generate(string s, int idx, int offset) {s[idx] += offset;for (int i = idx + 1; i < s.length(); ++i) {unordered_set<char> blockedCharacters;for (int j = 1; j <= 2; ++j) {if (i - j >= 0) {blockedCharacters.insert(s[i - j]);}}for (int j = 0; j < 3; ++j) {if (____) {s[i] = 'a' + j;break;}}}return s;}};"}
{"task_id": "cpp/13", "content": "Note:\n• N = 2 * 10^5\n• A, B are permutations.\n• 1 <= A[i], B[i] <= N\n• 1 <= N <= 10000\n\nhttps://leetcode.cn/problems/finding-the-array-that-contains-t-elements-with-the-least-bit-sum/\n# 1275. Find Winner on a Tic Tac Toe Game\nDesign a Tic-tac-toe game that is played between two players on a n x n grid.The following example\nillustrates the expected game s:\n\nPlayer 1 is \"X\",\n\nPlayer 2 is \"O\",\n\nand the blank space is \".\".\n\n\nTic-tac-toe is played by two players a\nnd each player\nplaces a mark on one of the n 2 spaces in the grid. The first player X always moves first, and any\ninvalid move from player X\n(for example, using\nan already filled space)\nresult in an X win. When either player\nhas three in a row, or all n2\nspaces are filled, the game\nis over.If it is\na draw (all n 2 cells are filled)\nor a win for player X,\nthen return the player X. If there\nare no valid moves, then a\ndraw is\nreturned.\n\nGiven an array moves where each element is another array of size 2 corresponding to the row and\ncolumn\nof the grid.\n\nExample 1:\nInput: moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]\nOutput: \"A\"\nExplanation: \"A\" \nobtained\nby \"X\" \nin the below\ngrid.\n\nX.O.\nX.O\nOO.\n\nAnd \"X\" wins.\n\nNote:\n• n is a number in range [3, 9].\n• moves.length == n-1\n• moves[i].length == 2\n• 0 <= moves[i][j] < n\n• There are no repeated elements on moves.\n• moves follow the rules of tic tac toe.\n\nhttps://leetcode.cn/problems/find-winner-on-a", "groundtruth": "class Solution {public:vector<int> findThePrefixCommonArray(vector<int> &a, vector<int> &b) {int n = a.size();vector<int> ans(n);long long p = 0, q = 0;for (int i = 0; i < n; ++i) {p |= 1LL << a[i];q |= 1LL << b[i];ans[i] = __builtin_popcountll(p & q);}return ans;}};"}
{"task_id": "cpp/14", "content": "\n#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int DIRS[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\nclass Solution {\npublic:\n    int maxFish(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size(), ans = 0;\n        function<int(int, int)> dfs = [&](int x, int y) -> int {\n            if (grid[x][y] == 0)\n                return 0;\n            int sum = grid[x][y];\n            grid[x][y] = 0;\n            // 标记成访问过\n            for (auto& d: DIRS) // 四方向移动\n                ans = max(ans, dfs(x + d[0], y + d[1]));\n            return sum;\n        };\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                ans = max(ans, dfs(i, j));\n        return ans;\n    }\n};\n\n#include <iostream>\n#include <vector>\nusing namespace std;\nconstexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\nclass Solution {\npublic:\n    int maxFish(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size(), ans = 0;\n        auto dfs = [&](int x, int y) -> int {\n            if (grid[x][y] == 0) return 0;\n            int sum = grid[x][y];\n            grid[x][y] = 0;\n            for (auto& d : dirs) {\n                ans = max(ans, dfs(x + d[0], y + d[1]));\n            }\n            return sum;\n        };\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                ans = max(ans, dfs(i, j));\n        return ans;\n    }\n};s[0] - 1); // 左边界设为", "groundtruth": "class Solution {static constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};public:int findMaxFish(vector<vector<int>> &grid) {int m = grid.size(), n = grid[0].size(), ans = 0;function<int(int, int)> dfs = [&](int x, int y) -> int {if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0)return 0;int sum = grid[x][y];grid[x][y] = 0; // 标记成访问过for (auto &d: dirs) // 四方向移动sum += dfs(x + d[0], y + d[1]);return sum;};for (int i = 0; i < m; ++i)for (int j = 0; j < n; ++j)ans = max(ans, dfs(i, j));return ans;}};"}
{"task_id": "cpp/15", "content": "Please submit only the solution code for this question via this form. Do not submit any other files. For this question, you need to fill in your answer only in this one file named \"main.cpp\", and then compress it as \"main.zip\" and submit it via the form.", "groundtruth": "// 树状数组模板class BIT {vector<int> tree;public:BIT(int n) : tree(n) {}// 将下标 i 上的数加一void inc(int i) {while (i < tree.size()) {++tree[i];i += i & -i;}}// 返回闭区间 [1, i] 的元素和int sum(int x) {int res = 0;while (x > 0) {res += tree[x];x &= x - 1;}return res;}// 返回闭区间 [left, right] 的元素和int query(int left, int right) {return sum(right) - sum(left - 1);}};class Solution {public:long long countOperationsToEmptyArray(vector<int> &nums) {int n = nums.size(), id[n];iota(id, id + n, 0);sort(id, id + n, [&](int i, int j) {return nums[i] < nums[j];});long long ans = n; // 先把 n 计入答案BIT t(n + 1); // 下标从 1 开始int pre = 1; // 上一个最小值的位置，初始为 1for (int k = 0; k < n; ++k) {int i = id[k] + 1; // 下标从 1 开始if (i >= pre) // 从 pre 移动到 i，跳过已经删除的数ans += i - pre - t.query(pre, i);else // 从 pre 移动到 n，再从 1 移动到 i，跳过已经删除的数ans += n - pre + i - k + t.query(i, pre - 1);t.inc(i); // 删除 ipre = i;}return ans;}};"}
{"task_id": "cpp/16", "content": "Please fill in the main function in the incomplete code according to the description. The description is as follows:\nclass Solution {public:vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x) {const int BIAS = 50;vector<int> cnt(BIAS * 2 + 1, 0), ans(nums.size() - k + 1);for (int i = 0; i < k - 1; ++i) // 先往窗口内添加 k-1 个数{int j = nums[i] + BIAS;cnt[j]++;}// 窗口有恰好 k 个数for (int i = k - 1; i < nums.size(); ++i) {int j = nums[i] + BIAS;cnt[j]++;int left = x;for (int j = 0; j < BIAS; ++j) { // 暴力枚举负数范围____if (left <= 0) { // 找到美丽值____ans[i - k + 1] = j - BIAS;break;}cnt[j]--;}// 出去窗口}return ans;}};\nMain function is as follows:\n#include <cstdio>\n#include <vector>\nusing namespace std;\nclass Solution {public:vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x) {const int BIAS = 50;int cnt[BIAS * 2 + 1]{}, n = nums.size();for (int i = 0; i < k - 1; ++i) { // 先往窗口内添加 k-1 个数____}for (int i = k - 1; i < n; ++i) { // 窗口有恰好 k 个数for (int j = 0; j < BIAS; ++j) {// 暴力枚举负数范围____}cnt[j]--; // 出去窗口}return vector<int>(ans.begin(), ans.begin() + n - k + 1);}}\nint main() {return 0;}\n/*\n// test case\n5\n0 0 0 0 0\n8\n1\n10\n-1\n-3\n-2\n-", "groundtruth": "class Solution {public:vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x) {const int BIAS = 50;int cnt[BIAS * 2 + 1]{}, n = nums.size();for (int i = 0; i < k - 1; ++i) // 先往窗口内添加 k-1 个数++cnt[nums[i] + BIAS];vector<int> ans(n - k + 1);for (int i = k - 1; i < n; ++i) {++cnt[nums[i] + BIAS]; // 进入窗口（保证窗口有恰好 k 个数）int left = x;for (int j = 0; j < BIAS; ++j) { // 暴力枚举负数范围 [-50,-1]left -= cnt[j];if (left <= 0) { // 找到美丽值ans[i - k + 1] = j - BIAS;break;}}--cnt[nums[i - k + 1] + BIAS]; // 离开窗口}return ans;}};"}
{"task_id": "cpp/17", "content": "\n```\n#include <bits/stdc++.h>\nusing namespace std;\n//int gcd(int a, int b) {return b == 0? a : gcd(b, a%b);}\nclass Solution { public:\n  int minOperations(vector<int>& nums) {\n    int n = nums.size(), gcd_all = 0, cnt1 = 0;\n    for (auto x : nums) {\n      gcd_all = gcd(gcd_all, x);\n    }\n    if (gcd_all > 1) return -1;\n    if (cnt1) return n - cnt1;\n    int min_size = n;\n    for (int i = 0; i < n; ++i) {\n      int g = 0;\n      for (int j = i; j < n; ++j) {\n        g = gcd(g, nums[j]);\n        if (g == 1) { // 这里本来是 j-i+1，把 +1 提出来合并到 return 中\n          min_size = min(min_size, n - cnt1);\n          break;\n        }\n      }\n    }\n    return min_size + n - 1;\n  }\n};\n\nint main(int argc, char const *argv[])\n{\n  /* code */\n  Solution s;\n  vector<int> nums = {2,8,2};\n  printf(\"%d\\n\", s.minOperations(nums));\n  return 0;\n}\n\n```\n\n\n\n---\n\n\n\n### 1742. 盒子中小球的最大数量\n\n给你 n 个盒子的编号（编号从 1 到 n），每个盒子都有一个 不同的 颜 色，其中，颜色编号从 1 到 n 。每个盒子都有一个小球。\n\n你的手 能从一个盒子中取出一个小球，并把它 放回到另一盒子中。你的目标是把所有小球放入盒子里，直到没有盒子为止。\n\n给你一个数组盒子，盒子里的每个元素 isBox[i] 表示第 i 个盒子的颜色。同时给你一个二维数组 queries ，其中 queries[i] = [colori, colorj] 表示从第 color", "groundtruth": "class Solution {public:int minOperations(vector<int> &nums) {int n = nums.size(), gcd_all = 0, cnt1 = 0;for (int x: nums) {gcd_all = gcd(gcd_all, x);cnt1 += x == 1;}if (gcd_all > 1) return -1;if (cnt1) return n - cnt1;int min_size = n;for (int i = 0; i < n; ++i) {int g = 0;for (int j = i; j < n; ++j) {g = gcd(g, nums[j]);if (g == 1) {// 这里本来是 j-i+1，把 +1 提出来合并到 return 中min_size = min(min_size, j - i);break;}}}return min_size + n - 1;}};"}
{"task_id": "cpp/18", "content": "Example 1:\nInput:nums = [1,2,3,4,5,10], divisors = [2,3,5]\nOutput:5\nExplanation:\nFor divisors[0] = 2, there are [1] index with value of nums[1] = 2 that is divisible by 2.\nFor divisors[1] = 3, there are [0,1,4] indices with value of nums[0] = 1, nums[1] = 2, nums[4] = 5 that are divisible by 3.\nFor divisors[2] = 5, there are [3] index with value of nums[3] = 4 that is divisible by 5.\nThe divisibility score for each number is [1, 1, 0, 0, 1]. So we should return 5 as the answer.\nExample 2:\nInput:nums = [2,4,5,9,10], divisors = [2,3,5,7]\nOutput:10\nExplanation:\nFor divisors[0] = 2, there is [1] index with value of nums[1] = 4 that's divisible by 2.\nFor divisors[1] = 3, there are [2] indices with value of nums[2] = 5, nums[5] = 10 that are divisible by 3.\nFor divisors[2] = 5, there are [1, 4] indices with value of nums[1] = 4, nums[4] = 5 that are divisible by 5.\nFor divisors[3] = 7, there is [0] index with value of nums[0] = 2 that's divisible by 7.\nThe divisibility score for each number is [1, 1, 1, 0]. So we should return 10 as the answer.\n\n\nDefinition of vector:\nclass vector {\npublic:\n    int size();\n    int get(int index);\n    void set(int index, int val);\n    vector(vector &v);\n    vector(int size);\n    void push_back(int val);\n    void pop_back();\n    void printAll();\n   ", "groundtruth": "class Solution {public:int maxDivScore(vector<int>& nums, vector<int>& divisors) {int cnt = -1, ans = 0;for (int i = 0; i < divisors.size(); i++) {int tmp = 0;for (int j = 0; j < nums.size(); j++) {if (nums[j] % divisors[i] == 0) {tmp++;}}if (tmp > cnt || (tmp == cnt && divisors[i] < ans)) {ans = divisors[i];cnt = tmp;}}return ans;}};"}
{"task_id": "cpp/19", "content": "#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\n/*\r\n * @lc app=leetcode.cn id=129 lang=cpp\r\n *\r\n * [129] 求根到叶子节点数字之和\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    vector<int> digits;\r\n    int pathSum(TreeNode* root) {\r\n        sum = 0;\r\n        helper(root);\r\n        return sum;\r\n    }\r\n    void helper(TreeNode* root) {\r\n        if (root->left == NULL && root->right == NULL) {\r\n            for(int i=0; i<digits.size(); i++) {\r\n                sum += digits[i];\r\n            }\r\n            return;\r\n        }\r\n        int a = root->val;\r\n        if (root->left) {\r\n            digits.push_back(a*10 + 1);\r\n            helper(root->left);\r\n            digits.pop_back();\r\n        }\r\n        if (root->right) {\r\n            digits.push_back(a*10 + 2);\r\n            helper(root->right);\r\n            digits.pop_back();\r\n        }\r\n    }\r\n    int sum;\r\n};\r\n// @lc code=end\r\n\r\n#include <iostream>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <fstream>\n#include <unistd.h>\nusing namespace std;\n\nvoid usage() {\n    cout << \"请输入正确的命令(eg: bsort 1.txt 2.txt)\" << endl;\n}\n\nvoid readFromFiles(string file1, string file2, vector<int>& nums, string& method) {\n    ifstream input1;\n    ifstream input2;\n    input1.open(file1);\n    input2.open(file2);\n    string temp;\n    while(getline(input1, temp)) {\n        nums.push_back(stoi(temp));\n    }\n    getline(input2, method);\n}\n\nvoid output", "groundtruth": "class Solution {public:int addMinimum(string word) {int n = word.size();vector<int> d(n + 1);for (int i = 1; i <= n; i++) {d[i] = d[i - 1] + 2;if (i > 1 && word[i - 1] > word[i - 2]) {d[i] = d[i - 1] - 1;}}return d[n];}};"}
{"task_id": "cpp/20", "content": "Please fill in only the following incomplete code:\nclass Solution {public:int minimumTotalPrice(int n, vector<vector<int>> &edges, vector<int> &price, vector<vector<int>> &trips) {vector<vector<int>> next(n);for (auto &edge : edges) {next[edge[0]].push_back(edge[1]);next[edge[1]].push_back(edge[0]);}vector<int> count(n);function<bool(int, int, int)> dfs = [&](int node, int parent, int end) -> bool {if (node == end) {count[node]++;return true;}for (int child : next[node]) {if (child == parent) {continue;}if (dfs(child, node, end)) {count[node]++;return true;}}return false;};for (auto &trip: trips) {dfs(trip[0], -1, trip[1]);}function<pair<int, int>(int, int)> dp = [&](int node, int parent) -> pair<int, int> {pair<int, int> res = {1, price[node]};for (int child : next[node]) {if (child == parent) {continue;}auto [x, y] = dp(child, node);res.first += x; res.second += x * y;}res.second /= 2;return res;};auto [x, y] = dp(0, -1);return min(x, y);}};\n*/\n\nclass Solution {\npublic:\n\tint minimumTotalPrice(int n, vector<vector<int>> &edges, vector<int> &price, vector<vector<int>> &trips) {\n\t\tvector<vector<int>> next(n);\n\t\tfor (auto &edge : edges) {\n\t\t\tnext[edge[0]].push_back(edge[1]);\n\t\t\tnext[edge[1]].push_back(edge[0]);\n\t\t}\n\n\t\tvector<int> count(n);\n\t\tfunction<bool(int, int, int)> dfs = [&](int node, int parent, int end) -> bool {\n\t\t\tif (node == end) {\n\t\t\t\tcount[node]++;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfor (int child : next[node]) {\n\t\t\t", "groundtruth": "class Solution {public:int minimumTotalPrice(int n, vector<vector<int>> &edges, vector<int> &price, vector<vector<int>> &trips) {vector<vector<int>> next(n);for (auto &edge : edges) {next[edge[0]].push_back(edge[1]);next[edge[1]].push_back(edge[0]);}vector<int> count(n);function<bool(int, int, int)> dfs = [&](int node, int parent, int end) -> bool {if (node == end) {count[node]++;return true;}for (int child : next[node]) {if (child == parent) {continue;}if (dfs(child, node, end)) {count[node]++;return true;}}return false;};for (auto &trip: trips) {dfs(trip[0], -1, trip[1]);}function<pair<int, int>(int, int)> dp = [&](int node, int parent) -> pair<int, int> {pair<int, int> res = {price[node] * count[node], price[node] * count[node] / 2};for (int child : next[node]) {if (child == parent) {continue;}auto [x, y] = dp(child, node);res.first += min(x, y); // node 没有减半，因此可以取子树的两种情况的最小值res.second += x; // node 减半，只能取子树没有减半的情况}return res;};auto [x, y] = dp(0, -1);return min(x, y);}};"}
{"task_id": "cpp/21", "content": "Example:Input: nums = [1,2,3,4,5]Output: [2,5,11,22,39]Explanation: The prefixes are [1], [1, 2], [1, 2, 3], [1, 2, 3, 4], [1, 2, 3, 4, 5]. The conversion arrays are [0, 0], [1, 1], [2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4, 4]. The scores are 0, 0, 2, 5, 11.Example:Input: nums = [1,4,2,5,3]Output: [1,5,7,12,14]Explanation: The prefixes are [1], [1, 4], [1, 4, 2], [1, 4, 2, 5], [1, 4, 2, 5, 3]. The conversion arrays are [0, 0], [1, 1], [2, 2, 1], [3, 3, 3, 2], [4, 4, 4, 4, 3]. The scores are 0, 0, 1, 2, 3.\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n7", "groundtruth": "class Solution {public:vector<long long> findPrefixScore(vector<int>& nums) {vector<long long> ans;int tmp = nums[0];ans.push_back(nums[0] * 2);for (int i = 1; i < nums.size(); ++i) {if (nums[i] > tmp) tmp = nums[i];ans.push_back(nums[i] + tmp + ans[i - 1]);}return ans;}};"}
{"task_id": "cpp/22", "content": "\n• 广告\n• 抄袭\n• 版权\n• 政治\n• 色情\n• 无意义\n• 其他\n\n156\n105\n\n+ 订阅\n\n客服QQ 2623471963\n\n回答TA\n\n来学点编程代码\n\n回答TA\n\n点赞TA\n\n### 289. 冗余连接\n\nhttps://leetcode-cn.com/problems/redundant-connection/solution/c-bing-cha-ji-yi-zhan-liao-li-jie-by-jerr__-2/\n\nIn this problem, a tree is an undirected graph that is connected and has no cycles.\n\nThe given input is a graph that started as a tree with N nodes (with distinct values 1, 2,..., N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed. The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [u, v] with u < v, that represents an undirected edge connecting nodes u and v.\n\nReturn an edge that can be removed so that the resulting graph is a tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. The answer edge [u, v] should be in the same format, with u < v.\n\nExample 1:\nInput: [[1,2], [1,3], [2,3]]\nOutput: [2,3]\nExplanation: The given undirected graph will be like this:\n1\n/ \\\n2 - 3\n\nExample 2:\nInput: [[1,2], [2,3], [3,4], [1,4], [1,5]]\nOutput: [1,4]\nExplanation: The given undirected graph will be like this:\n5 - 1 - 2\n|    |\n4   3\n\nNote:\nThe size of the input 2D-array will be between 3 and 1000.\nEvery integer represented in the 2D-array will be between 1 and N, where N is", "groundtruth": "class Solution {public:TreeNode* replaceValueInTree(TreeNode* root) {vector<TreeNode*> q = {root};root->val = 0;while (!q.empty()) {vector<TreeNode*> q2;int sum = 0;for (auto fa : q) {if (fa->left) {q2.push_back(fa->left);sum += fa->left->val;}if (fa->right) {q2.push_back(fa->right);sum += fa->right->val;}}for (auto fa : q) {int child_sum = (fa->left ? fa->left->val : 0) +(fa->right ? fa->right->val : 0);if (fa->left) {fa->left->val = sum - child_sum;}if (fa->right) {fa->right->val = sum - child_sum;}}q = move(q2);}return root;}};"}
{"task_id": "cpp/23", "content": "\"\"\"/01091-shortest-path-in-binary-matrix/solution.py\n\"\"\"\n1091. Shortest Path in Binary Matrix\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/\n\nIn an N by N square grid, each cell is either empty (0) or blocked (1).\nA clear path from top-left to bottom-right has length k if and only if it is composed of cells C_1, C_2,..., C_k such that:\n\nAdjacent cells C_i and C_{i+1} are connected 8-directionally (ie., they are different and share an edge or corner)\nC_1 is at location (0, 0) (ie. has value grid[0][0])\nC_k is at location (N-1, N-1) (ie. has value grid[N-1][N-1])\nIf C_i is located at (r, c), then grid[r][c] is empty (ie. grid[r][c] == 0).\nReturn the length of the shortest such clear path from top-left to bottom-right.  If such a path does not exist, return -1.\n\nExample 1:\n\nInput: [[0,1],[1,0]]\nOutput: 2\nExample 2:\n\nInput: [[0,0,0],[1,1,0],[1,1,0]]\nOutput: 4\nNote:\n\n1 <= grid.length == grid[0].length <= 100\ngrid[r][c] is 0 or 1\n\"\"\"\n\nclass Solution:\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\n        if grid[0][0] == 1:\n            return -1\n        N = len(grid)\n        m = [[0] * N for _ in range(N)]\n        m[0][0] = 1\n        for k in range(1, N * N):\n            if m[k // N - 1][k % N - 1]:\n                for dx, dy in [(-1, -1), (-1, 0), (-1, 1), (0, 1), (1, ", "groundtruth": "class Graph {public:using pii = pair<int, int>;Graph(int n, vector<vector<int>>& edges) {this->graph = vector<vector<pii>>(n);for (auto &vec : edges) {int x = vec[0];int y = vec[1];int cost = vec[2];graph[x].emplace_back(y, cost);}}void addEdge(vector<int> edge) {int x = edge[0];int y = edge[1];int cost = edge[2];graph[x].emplace_back(y, cost);}int shortestPath(int node1, int node2) {priority_queue<pii, vector<pii>, greater<pii>> pq;vector<int> dist(graph.size(), INT_MAX);dist[node1] = 0;pq.emplace(0, node1);while (!pq.empty()) {auto [cost, cur] = pq.top();pq.pop();if (cur == node2) {return cost;}for (auto [next, ncost] : graph[cur]) {if (dist[next] > cost + ncost) {dist[next] = cost + ncost;pq.emplace(cost + ncost, next);}}}return -1;}private:vector<vector<pii>> graph;};"}
{"task_id": "cpp/24", "content": "\n## 参考答案\n\nclass Solution { public: vector<long long> distance(vector<int> &nums) { int n = nums.size(); unordered_map<int, vector<int>> groups; for (int i = 0; i < n; ++i) groups[nums[i]].push_back(i);\n\nvector<long long> ans(n); long long s[n + 1]; s[0] = 0; for (auto &[_, a] : groups) { int m = a.size(); for (int i = 0; i < m; ++i) s[i + 1] = s[i] + a[i];\n\nfor (int i = 0; i < m; ++i) { long long target = a[i]; long long right = s[m] - s[i] - target * (m - i); ans[a[i]] += target * (m - i) - right; }} return ans; } };", "groundtruth": "class Solution {public:vector<long long> distance(vector<int> &nums) {int n = nums.size();unordered_map<int, vector<int>> groups;for (int i = 0; i < n; ++i)groups[nums[i]].push_back(i); // 相同元素分到同一组，记录下标vector<long long> ans(n);long long s[n + 1];s[0] = 0;for (auto &[_, a]: groups) {int m = a.size();for (int i = 0; i < m; ++i)s[i + 1] = s[i] + a[i]; // 前缀和for (int i = 0; i < m; ++i) {long long target = a[i];long long left = target * i - s[i]; // 蓝色面积long long right = s[m] - s[i] - target * (m - i); // 绿色面积ans[target] = left + right;}}return ans;}};"}
{"task_id": "cpp/25", "content": "##### Sample Input\n-1 1\n##### Sample Output\n1\n##### Hint\n\nThere is one pair, [0, 1].\n\n## Problem Description\n\nYou are given a 0-indexed string s that consists of digits only and one special character. This character appears only once in the string.The special character and the digits in s cannot be rearranged and must remain fixed.We will call an arrangement of s good if it meets all the following criteria:The first occurrence of the special character in the arrangement must be at the very beginning of the arrangement,andits length (i.e. the number of digits before it) is no greater than the length of the entire string.You must rearrange the digits in the rest of the arrangement such that the special character is between two digits.The arrangement is bad if the following conditions are not satisfied:All digits in the arrangement are different,i.e. no two digits are the same.The absolute difference between the first digit and the last digit of the arrangement does not exceed 1.Return the lexicographically largest good arrangement of the given string s, or return an empty string if no such arrangement exists.A string a is lexicographically larger than a string b (of the same length) if in the first position where a and b differ, string a has a character whose ASCII value is larger than the corresponding character in b.If there is no such position, then a is lexicographically larger than b.Note that the special character in s must not be moved even if no good arrangement of s exists.\n##### Example 1\nInput\n\"1002\"\nOutput\n\"10200\"\n##### Example 2\nInput\n\"2021\"\nOutput\n\"\"\n##### Example 3\nInput\n\"99100012\"\nOutput\n\"99100021\"\n##### Example 4\nInput\n\"10\"\nOutput\n\"10\"\n##### Hint\n\nIf we add a special character to the front of a string, we will create the largest possible good arrangement.\n\n## Problem Description\n\nYou are given an integer num representing a positive integer.Return the sum of its digits in different ways.\nIn the first way, split num into digits whose absolute value is less than 1024.Sum", "groundtruth": "class Solution {public:int minimizeMax(vector<int> &nums, int p) {sort(nums.begin(), nums.end());int left = -1, right = nums.back() - nums[0]; // 开区间while (left + 1 < right) { // 开区间int mid = left + (right - left) / 2, cnt = 0;for (int i = 0; i < nums.size() - 1; ++i)if (nums[i + 1] - nums[i] <= mid) { // 都选++cnt;++i;}(cnt >= p ? right : left) = mid;}return right;}};"}
{"task_id": "cpp/26", "content": "Example 1:\nInput: grid = [[4,3,2,1],[3,2,1,1],[1,1,2,1]]\nOutput: 2\nExplanation:\nYou can choose the cell (0, 0), which is at the top-left corner. Then, you can visit the bottom-right corner (m-1, n-1) of the matrix. \nExample 2:\nInput: grid = [[4,4,4,4],[4,4,4,4],[4,4,4,4],[4,4,4,4]]\nOutput: -1\nExplanation:\nThere is no valid path from the top-left corner to the bottom-right corner.\nNote:\n1. m == grid.length\n2. n == grid[i].length\n3. 1 <= m, n <= 100\n4. 1 <= grid[i][j] <= 100\n */\n\n/*\n * Given a 0-indexed m x n integer matrix grid. Your initial position is at the top-left cell (0, 0).\n *  Starting from the cell (i, j), you can move to one of the following cells:\n *  Cells (i, k) with j < k <= grid[i][j] + j (rightward movement), or\n *  Cells (k, j) with i < k <= grid[i][j] + i (downward movement).\n *  Return the minimum number of cells you need to visit to reach the bottom-right cell (m - 1, n - 1). If there is no valid path, return -1.\n * \n * Example 1:\n * Input: grid = [[4,3,2,1],[3,2,1,1],[1,1,2,1]]\n * Output: 2\n * Explanation:\n * You can choose the cell (0, 0), which is at the top-left corner. Then, you can visit the bottom-right corner (m-1, n-1) of the matrix.\n * \n * Example 2:\n * Input: grid = [[4,4,4,4],[4,4,4,4],[4,4,4,4],[4,4,4,4]]\n * Output:", "groundtruth": "class Solution {public:int minimumVisitedCells(vector<vector<int>>& grid) {int m = grid.size(), n = grid[0].size();vector<vector<int>> dist(m, vector<int>(n, -1));dist[0][0] = 1;vector<priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>>> row(m), col(n);auto update = [](int& x, int y) {if (x == -1 || y < x) {x = y;}};for (int i = 0; i < m; ++i) {for (int j = 0; j < n; ++j) {while (!row[i].empty() && row[i].top().second + grid[i][row[i].top().second] < j) {row[i].pop();}if (!row[i].empty()) {update(dist[i][j], dist[i][row[i].top().second] + 1);}while (!col[j].empty() && col[j].top().second + grid[col[j].top().second][j] < i) {col[j].pop();}if (!col[j].empty()) {update(dist[i][j], dist[col[j].top().second][j] + 1);}if (dist[i][j] != -1) {row[i].emplace(dist[i][j], j);col[j].emplace(dist[i][j], i);}}}return dist[m - 1][n - 1];}};"}
{"task_id": "cpp/27", "content": "Give the following code:\nint main() {int n; while (cin >> n) {vector<int> nums(n);for (int i = 0; i < n; ++i) cin >> nums[i]; Solution solution; auto ans = solution.findMatrix(nums);if (ans.empty()) {cout << \"No solution!\" << endl;continue;}for (int j = 0; j < ans.size(); ++j) {for (int k = 0; k < ans[j].size(); ++k) {cout << setw(8) << ans[j][k];}cout << endl;}cout << endl;}}}\nPlease fill in the blanks above the line by the description below, or you cannot pass the test.\na.ans.empty() b. ans[i][j] c. ans[j][i] d. ans[i][i] e. ans[i][j] == 1 f. nums.empty() g. nums[i]\nWrite these words in your code above.\nExample:\nThere is an input:\n3\n2 2 4\n4 3 1\n2\n3 3\nThen the output will be:\nNo solution!\nNo solution!\n2 2 4\n3 1 2\n4 3 2\n3 1 2\n4 3 2\n3 3\n3 1\n3 2\n2 2 2\n4 4\n3 3 3 3 3 3\n5 1 1 1 1\n3 3 3\n\n### Exercise 4:\n\nPlease fill in the incomplete code according to the description. The description is as follows:\nYou are given a string s that consists of upper case English letters and '.' characters.Suppose that the characters in the string following the dot character are English letters.Consider the letter before the dot character as a person's first name and the letters after the dot character as the person's last name.Return the total number of different persons that satisfy these conditions.Note that you don't need to consider the cases that all letters are lower cased or all letters are upper cased.\nThe incomplete code is as follows:\nclass Solution {public:int numUniqueEmails(vector<string> &emails) {set<string> unique;unordered_map<", "groundtruth": "class Solution {public:vector<vector<int>> findMatrix(vector<int> &nums) {unordered_map<int, int> cnt;for (int x: nums) ++cnt[x];vector<vector<int>> ans;while (!cnt.empty()) {vector<int> row;for (auto it = cnt.begin(); it != cnt.end();) {row.push_back(it->first);if (--it->second == 0) it = cnt.erase(it);else ++it;}ans.push_back(row);}return ans;}};"}
{"task_id": "cpp/28", "content": "The incomplete code of the first line contains a blank, and there is a blank after each for-loop.The incomplete code of the last line contains a blank.The blank is required, so that you can compile and run your code successfully.\nThere is a blank in the middle of each for-loop.There are blanks in each for-loop.\n\n*/\n\n/*\n\nThe above content is the description of the question of the 2019 UC Berkeley Software Challenge. The following code is my completed code.\n\n*/\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nclass Solution { public:int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {int ans = 0;int n = reward1.size();vector<int> diffs(n);for (int i = 0; i < n; i++) { diffs[i] = reward1[i] - reward2[i]; }sort(diffs.begin(), diffs.end());for (int i = 1; i <= k; i++) {ans += diffs[diffs.size() - i];}return ans;}}\n\n/*\n\nThe above code can be compiled and run successfully.\nHowever, it is a brute-force method. I did not consider it in the completion of the question.\nFor the same question, I used a brute-force method to complete the solution of the question.\nThe code is as follows:\n\nclass Solution { public:int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {int ans = 0;int n = reward1.size();vector<int> sums;for (int i = 0; i < n; i++) { vector<int> sums; sums.push_back(reward1[i] + reward2[i]); for (int j = 0; j < n; j++) { if (j!= i) sums.push_back(reward1[j] + reward2[j]); } int sum = 0; for (int sum : sums) { sum += sum; if (k == 1) { ans = max(ans, sum); } else { ans = max(", "groundtruth": "class Solution {public:int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {int ans = 0;int n = reward1.size();vector<int> diffs(n);for (int i = 0; i < n; i++) {ans += reward2[i];diffs[i] = reward1[i] - reward2[i];}sort(diffs.begin(), diffs.end());for (int i = 1; i <= k; i++) {ans += diffs[n - i];}return ans;}};"}
{"task_id": "cpp/29", "content": "Note: If any of the characters in the function name or code is changed, a wrong solution may be submitted for credit.\nSample Input 1:\n4 0 1 2\nSample Output 1:\n3 2 1 0\nSample Input 2:\n4 3 0 1\nSample Output 2:\n-1 -1 1 3\n\nclass Solution {\npublic int[] minReverseOperations(int n, int p, int[] banned, int k) {\nSet ban = new HashSet();\nfor (int i: banned) ban.add(i);\nSet<Integer>[] sets = new Set[2];\nfor (int i = 0; i < n; i++) {\nsets[i % 2] = new TreeSet();\nsets[i % 2].add(i);\nsets[0] = new TreeSet();\nsets[0].add(n);\nsets[1] = new TreeSet();\nsets[1].add(n);\n}\nint[] ans = new int[n];\nans[p] = -1;\nQueue<Integer> q = new LinkedList();\nq.add(p);\nfor (int step = 0;!q.isEmpty(); step++) {\nList<Integer> nq = new LinkedList();\nfor (int i: q) {\nans[i] = step;\nint mn = max(i - k + 1, k - i - 1);\nint mx = min(i + k - 1, n - k);\nfor (Set set: sets) {\nint lo = Math.max(mn, (int)set.floor(mn) + 1);\nint hi = Math.min(mx, (int)set.ceiling(mx) - 1);\nfor (int j = lo; j <= hi; j++) {\nif (!ban.contains(j)) nq.add(j);\n}\n}\n}\nq = nq;\n}\nreturn ans;\n}\n}class Solution:\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\n        boxTypes = sorted(boxTypes, key=lambda x:(x[1]), reverse=True)\n        res = 0\n        for box in", "groundtruth": "class Solution {public:vector<int> minReverseOperations(int n, int p, vector<int> &banned, int k) {unordered_set<int> ban{banned.begin(), banned.end()};set<int> sets[2];for (int i = 0; i < n; ++i)if (i != p && !ban.count(i))sets[i % 2].insert(i);sets[0].insert(n);sets[1].insert(n); // 哨兵vector<int> ans(n, -1);vector<int> q = {p};for (int step = 0; !q.empty(); ++step) {vector<int> nq;for (int i: q) {ans[i] = step;// 从 mn 到 mx 的所有位置都可以翻转到int mn = max(i - k + 1, k - i - 1);int mx = min(i + k - 1, n * 2 - k - i - 1);auto &s = sets[mn % 2];for (auto it = s.lower_bound(mn); *it <= mx; it = s.erase(it))nq.push_back(*it);}q = move(nq);}return ans;}};"}