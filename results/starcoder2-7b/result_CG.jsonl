{"task_id": "java/0", "content": "\n\"\"\"\n\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        # graph initalization\n        edges_graph = [[0] * n for _ in range(n)]\n        # count of incoming edges for each node\n        in_edges = [0] * n\n\n        for u, v in edges:\n            in_edges[v] += 1\n            edges_graph[u][v] = 1\n\n        # print(edges_graph)\n        # print(in_edges)\n\n        # for loop till find a leaf node (node with no edge in/out)\n        # in_edges will keep track of the in edge for each node\n        # if one node's in edge == 0, then it is a leaf node and\n        # it can be our champion\n        champion = -1\n        for i in range(n):\n            if in_edges[i] == 0:\n                if champion == -1:\n                    champion = i\n                else:\n                    return -1\n        return champion\n/leetcode/2510_Maximum_Beauty_of_Gardens.py\n\"\"\"\n\nGiven an integer array flowers and an integer numBer of flowers in a \nfenced off garden, return the maximum beauty of a  fenced off area that can \nbe painted with numBer blooms.\n\nThe beauty of a fenced off area is the minimum number of flowers that needs \nto be bloom at the same time in order to cover the fenced off area with blooms. \nIf the fence can be covered with one or more than one blooms, the fenced off \narea is considered as  covered, and  the beauty of a fenced off area is the \nminimum number of flowers that needs to be bloom at the same time in order to \ncover the fenced off area with blooms.\n\nAn array of length n and integer n is a fence if the flooring of the array \nis as below:\n\nfloor(arr[i]) = floor(arr[i+1]) = 1\nfloor(arr[i])!= floor(arr[i+1]) = 0 \n\nA fenced off area is the  number of elements in flowers that have either floor", "groundtruth": "class Solution {    public int findChampion(int n, int[][] edges) {        int[] degree = new int[n];        for (int[] e : edges) {            degree[e[1]]++;        }        int champion = -1;        for (int i = 0; i < n; i++) {            if (degree[i] == 0) {                if (champion == -1) {                    champion = i;                } else {                    return -1;                }            }        }        return champion;    }}"}
{"task_id": "java/1", "content": "\n## Solution\n\nThe only line in the incomplete code that needs to be filled is:\nreturn ____ ;\nBecause it needs to return the maximum score you can obtain after performing these operations on the tree any number of times so that it remains healthy, in each DFS, if the node has only one child, the maximum value it can obtain is the current value, otherwise, it will calculate the minimum value of all values except for the current value to calculate the loss.\n\n\n### Code\n\nclass Solution {    public long maximumScoreAfterOperations(int[][] edges, int[] values) {        List<Integer>[] g = new ArrayList[values.length];        Arrays.setAll(g, e -> new ArrayList<>());        g[0].add(-1);         for (int[] e : edges) {            int x = e[0], y = e[1];            g[x].add(y);            g[y].add(x);        }        long ans = 0;        for (int v : values) {            ans += v;        }        return dfs(0, -1, g, values, new long[1]) + ans;    }    private long dfs(int x, int fa, List<Integer>[] g, int[] values, long[] ansmx) {        if (g[x].size() == 1) {             ansmx[0] = Math.max(ansmx[0], values[x]);             return values[x];        }        long loss = 0;         for (int y : g[x]) {            if (y!= fa) {                loss += dfs(y, x, g, values, ansmx);             }        }        ansmx[0] = Math.max(ansmx[0], loss);         return Math.min(values[x], loss);     }}\n\nNote: this code passed the test, but is it written for educational purposes? I am not sure, for now I have not considered it. I know the code that passed the test in the test, so I believe that it passes the test when submitted by other users as well.\n\n### Solution\n\nThe only line in the incomplete code that needs to be filled is:\nreturn ____ ;\nBecause it needs to return the maximum score you can obtain after performing these operations on the tree any number of times so that it remains healthy", "groundtruth": "class Solution {    public long maximumScoreAfterOperations(int[][] edges, int[] values) {        List<Integer>[] g = new ArrayList[values.length];        Arrays.setAll(g, e -> new ArrayList<>());        g[0].add(-1);         for (int[] e : edges) {            int x = e[0], y = e[1];            g[x].add(y);            g[y].add(x);        }        long ans = 0;        for (int v : values) {            ans += v;        }        return ans - dfs(0, -1, g, values);    }    private long dfs(int x, int fa, List<Integer>[] g, int[] values) {        if (g[x].size() == 1) {             return values[x];        }        long loss = 0;         for (int y : g[x]) {            if (y != fa) {                loss += dfs(y, x, g, values);             }        }        return Math.min(values[x], loss);     }}"}
{"task_id": "java/2", "content": "''' and None\nundefined\nundefined\n/challenges/medium/binary-search/Missing_Elements.py\n\n'''\nhttps://leetcode.com/problems/missing-elements-in-range\n\nEasy (71.33%)\n\nContributors:\nLeetcoder\n\nGiven a sorted integer array arr, two integers l and r are given. The objective is to remove those elements in the given range [l,r] and add the removed elements between [l,r] inclusive.\n\nThe returned array must be sorted and should have the same size as arr.\n\nExample 1:\nInput: arr = [1,4,5,7,10,11], l = 3, r = 8\nOutput: [1,1,2,3,4,5,7,8]\nExplanation:\n1 2 3 4 5 6 7 8\n-----------\n1 4 5 7 10 11\n-------------\n1 1 2 3 4 5 7 8\n\nExample 2:\nInput: arr = [2,3,10,11,12,14], l = 2, r = 9\nOutput: [2,3,4,5,6,7,8,9,10,11,12,13,14]\nExplanation:\n2 3 4 5 6 7 8 9 10 11 12 13 14\n-------------\n2 3 10 11 12 14\n------------------\n2 3 4 5 6 7 8 9 10 11 12 13 14\n''' and None\ndef MissingRanges(A, low, high):\n    start, result = A[0], []\n    for num in A[1:] + [high + 1]:\n        if num > low:\n            if start + 1!= num:\n                result.append(str(start + 1) + ('' if start + 1 == num - 1 else '->' + str(num - 1)))\n            start = num\n            low = num + 1\n    return result\n\narr = [1,4,5,7,10,1", "groundtruth": "class Solution {    public String triangleType(int[] nums) {        Arrays.sort(nums);        int x = nums[0];        int y = nums[1];        int z = nums[2];        if (x + y <= z) { // 排序后，只需比较 x+y 和 z            return 'none';        }        if (x == z) { // 排序了，说明 y 也和 x z 相等            return 'equilateral';        }        if (x == y || y == z) {            return 'isosceles';        }        return 'scalene';    }}"}
{"task_id": "java/3", "content": " */\npublic class _1883_Minimum_Sum_of_Distance_between_Buildings {\n\tpublic int minSumOfDistances(int[][] grid) {\n\t\tif (grid == null || grid.length < 1 || grid[0].length < 1) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tint n = grid.length, m = grid[0].length;\n\t\tint[] prefix = new int[n + 1];\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t\tif (grid[i][j] == 1) {\n\t\t\t\t\tprefix[i + 1] += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i > 0) {\n\t\t\t\tprefix[i + 1] += prefix[i];\n\t\t\t}\n\t\t\tcount += prefix[i + 1];\n\t\t}\n\t\tint[] suffix = new int[n + 1];\n\t\tfor (int i = n - 1; i >= 0; --i) {\n\t\t\tif (grid[i][0] == 1) {\n\t\t\t\tsuffix[i] = 1;\n\t\t\t}\n\t\t\tsuffix[i] += suffix[i + 1];\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (grid[i][0]!= 1) {\n\t\t\t\tint left = prefix[i];\n\t\t\t\tint right = count - left;\n\t\t\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t\t\tif (grid[i][j]!= 1) {\n\t\t\t\t\t\tint dis1 = i;\n\t\t\t\t\t\tint dis2 = 0;\n\t\t\t\t\t\tfor (int k = i; k >= 0; --k) {\n\t\t\t\t\t\t\tif (grid[k][j] == 1) {\n\t\t\t\t\t\t\t\tdis1 = i - k;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int k = i; k < n; ++k) {\n\t\t\t\t\t\t\tif (grid[k][j] == 1) {\n\t\t\t\t\t\t\t\tdis2 = k - i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t", "groundtruth": "class Solution {    public int numberOfPairs(int[][] points) {        int pairs = 0;        Arrays.sort(points, (a, b) -> {            if (a[0] != b[0]) {                return a[0] - b[0];            } else {                return b[1] - a[1];            }        });        int n = points.length;        for (int i = 0; i < n; i++) {            for (int j = i + 1; j < n; j++) {                if (points[i][1] >= points[j][1] && isGood(points, i, j)) {                    pairs++;                }            }        }        return pairs;    }    public boolean isGood(int[][] points, int index1, int index2) {        int n = points.length;        for (int i = 0; i < n; i++) {            if (i == index1 || i == index2) {                continue;            }            if (points[i][0] >= points[index1][0] && points[i][0] <= points[index2][0] && points[i][1] >= points[index2][1] && points[i][1] <= points[index1][1]) {                return false;            }        }        return true;    }}"}
{"task_id": "java/4", "content": "           break;\n            }\n        }\n        // 打印最多能组成的金条数量\n        System.out.println(res);\n        in.close();\n    }\n}/*\n题目描述\n有 n 个整数，分别表示成绩，请你帮忙排序。\n输入描述:\n输入包含多组数据。\n每组数据第一行包含一个整数 n(1≤n≤100)，第二行包含 n 个整数，中间用空格隔开。\n输出描述:\n对于每组数据，输出排序后的整数，中间用空格隔开。\n示例1\n输入\n复制\n3\n3 1 2\n输出\n复制\n1 2 3\n */\nimport java.util.*;\n\npublic class Main2 {\n    public static void main(String[] args) {\n        // 创建输入\n        Scanner in = new Scanner(System.in);\n        // 创建结果变量res，初始为0\n        int res = 0;\n        // 创建结果集合result\n        ArrayList<Integer> result = new ArrayList<>();\n        // 输入数据个数n\n        int n = in.nextInt();\n        // 输入数据\n        int[] nums = new int[n];\n        for(int i = 0;i<n;i++){\n            nums[i]=in.nextInt();\n        }\n        // 将数据nums排序\n        Arrays.sort(nums);\n        // 遍历nums\n        for(int j:nums){\n            if(result.size()==0){\n                res += j;\n                result.add(j);\n            }else if (result.get(result.size() - 1) + j <= 100) {\n                res += j;\n                result.add(j);\n            } else {\n                // 打印数组元素\n                for (int r: result) {\n                    System.out.print(r + \" \");\n                }\n     /*\n题目描述\n给定一个包含 n 个整数的数组，每一个整数取值范围在 0 到 10000。\n统计个数相同的整数对的个数，例如(x,y) 和 (y,x)，共  // 创建输入\n        Scanner in = new Scanner(System.in);\n        // 输入\n        int n = in.nextInt();\n        // 输入数组\n        int[] nums = new int[n];\n        // ", "groundtruth": "class Solution {    public long maximumSubarraySum(int[] nums, int k) {        long ans = Long.MIN_VALUE;        long sum = 0;        Map<Integer, Long> minS = new HashMap<>();        for (int x : nums) {            long s1 = minS.getOrDefault(x - k, Long.MAX_VALUE / 2);            long s2 = minS.getOrDefault(x + k, Long.MAX_VALUE / 2);            ans = Math.max(ans, sum + x - Math.min(s1, s2));            minS.merge(x, sum, Math::min);            sum += x;        }        return ans > Long.MIN_VALUE / 4 ? ans : 0;    }}"}
{"task_id": "java/5", "content": "You may assume that n will fit in 32-bit integer.\n\n样例\nExample 1:\nInput: \"0011111100000\"\nOutput: 17\nExplanation: There are 10 substrings of size 0: \"0011111100000\"0000, \"0011111100000\"0000, … \"0011111100000\"00000. There are 1 substrings of size 1: \"1111111111\". There are 2 substrings of size 2: \"1111111111\", \"1111111111\". The remaining 16 substrings have size > 2.\nExample 2:\nInput: \"11110110000\"\nOutput: 7\nExplanation: Each of the seven substrings is one of \"11110110000\"00, \"11110110000\"01, \"11110110000\"10, \"11110110000\"11, \"11110110000\"20, \"11110110000\"21, or \"11110110000\"30. The remaining substrings are not valid.\n\n注意事项\n1.n<=10^5\n2.S[i] = {'0', '1'}\n\n解答\n1. n <= 10^5，可以先遍历两遍，把所有 0 的坐标放到数组 a，这个数组的长度是 s.length() + 1。s.length() 肯定会小于 100000，所以不会超过 int 的范围，所以这个方法是 O(n) 的。\n2. 对 i 从 0 开始枚举，找到第一个等于 '0' 的位置 a[i]，然后从这里开始往后枚举，把所有满足条件的结果加到答案 ans 里面", "groundtruth": "class Solution {    public int numberOfSubstrings(String S) {        char[] s = S.toCharArray();        int n = s.length;        int m = 0;        int[] a = new int[n + 1];        for (int i = 0; i < n; i++) {            if (s[i] == '0') {                a[m++] = i;            }        }        int tot1 = n - m;        a[m] = n; // 哨兵        int ans = 0;        int i = 0; // >= left 的第一个 0 的下标是 a[i]        for (int left = 0; left < n; left++) {            if (s[left] == '1') {                ans += a[i] - left; // 不含 0 的子串个数            }            for (int k = i; k < m; k++) {                int cnt0 = k - i + 1;                if (cnt0 * cnt0 > tot1) {                    break;                }                int cnt1 = a[k] - left - (k - i);                ans += Math.max(a[k + 1] - a[k] - Math.max(cnt0 * cnt0 - cnt1, 0), 0);            }            if (s[left] == '0') {                i++; // 这个 0 后面不会再枚举到了            }        }        return ans;    }}"}
{"task_id": "java/6", "content": "\npublic class LeetCode1933 {\n    public static void main(String[] args) {\n        Solution solution = new LeetCode1933().new Solution();\n        System.out.println(solution.canReachCorner(4, 6,\n                new int[][] {{1, 3, 3}, {3, 5, 3}, {3, 2, 1}, {4, 4, 3}, {4, 0, 2}, {2, 4, 2}}));\n        System.out.println(solution.canReachCorner(2, 2,\n                new int[][] {{1, 1, 1}, {1, 0, 2}, {1, 0, 1}}));\n        System.out.println(solution.canReachCorner(2, 3,\n                new int[][] {{1, 1, 1}, {1, 0, 2}, {2, 0, 1}}));\n        System.out.println(solution.canReachCorner(3, 6,\n                new int[][] {{2, 1, 1}, {2, 1, 1}, {2, 1, 1}}));\n        System.out.println(solution.canReachCorner(3, 6,\n                new int[][] {{2, 1, 1}, {2, 2, 2}, {2, 3, 1}}));\n    }\n\n    class Solution {\n        public boolean canReachCorner(int X, int Y, int[][] circles) {\n            boolean[] vis = new boolean[circles.length];\n            for (int i = 0; i < circles.length; i++) {\n                long x = circles[i][0], y = circles[i][1], r = circles[i][2];\n                if (inCircle(x, y, r, 0, 0) || // 圆 i 包含矩形左下角\n                    inCircle(x, y, r, X, Y) || // 圆 i 包含矩形右上角\n                    // 圆 i 是否与矩形上边界/左边界相交相切\n                   !vis[i] && (x <= X && Math.abs(y - Y) <= r ||\n                            y <= Y && x <= r ||\n                            y > Y && inCircle(x,", "groundtruth": "class Solution {\n    public boolean canReachCorner(int X, int Y, int[][] circles) {\n        boolean[] vis = new boolean[circles.length];\n        for (int i = 0; i < circles.length; i++) {\n            long x = circles[i][0], y = circles[i][1], r = circles[i][2];\n            if (inCircle(x, y, r, 0, 0) || // 圆 i 包含矩形左下角\n                inCircle(x, y, r, X, Y) || // 圆 i 包含矩形右上角\n                // 圆 i 是否与矩形上边界/左边界相交相切\n                !vis[i] && (x <= X && Math.abs(y - Y) <= r ||\n                            y <= Y && x <= r ||\n                            y > Y && inCircle(x, y, r, 0, Y)) && dfs(i, X, Y, circles, vis)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n    private boolean inCircle(long ox, long oy, long r, long x, long y) {\n        return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r;\n    }\n\n    private boolean dfs(int i, int X, int Y, int[][] circles, boolean[] vis) {\n        long x1 = circles[i][0], y1 = circles[i][1], r1 = circles[i][2];\n        // 圆 i 是否与矩形右边界/下边界相交相切\n        if (y1 <= Y && Math.abs(x1 - X) <= r1 ||\n            x1 <= X && y1 <= r1 ||\n            x1 > X && inCircle(x1, y1, r1, X, 0)) {\n            return true;\n        }\n        vis[i] = true;\n        for (int j = 0; j < circles.length; j++) {\n            long x2 = circles[j][0], y2 = circles[j][1], r2 = circles[j][2];\n            // 在两圆相交相切的前提下，点 A 是否严格在矩形内\n            if (!vis[j] &&\n                (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) &&\n                x1 * r2 + x2 * r1 < (r1 + r2) * X &&\n                y1 * r2 + y2 * r1 < (r1 + r2) * Y &&\n                dfs(j, X, Y, circles, vis)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"task_id": "java/7", "content": "\nExample 1:\n\nInput: n=1, m=1\nOutput: 0\nExplanation: Since x=1 and y=1 both are greater than 1, the output is 0.\nExample 2:\n\nInput: n=1, m=3\nOutput: 2\nExplanation: If x=1, y is 1, 2 or 3, the output is 2.\nExample 3:\n\nInput: n=6, m=4\nOutput: 18\nExplanation: If x=1, y is 1, 2 or 3, the output is 3, if x=2, y is 1, 2 or 3, the output is 6, if x=3, y is 1, 2 or 3, the output is 9, if x=4, y is 1, 2 or 3, the output is 12, if x=5, y is 1, 2 or 3, the output is 15, if x=6, y is 1, 2 or 3, the output is 18.\n\nConstraints:\n\n1 <= n, m <= 10^5\n\n\n## Analysis\n\nWhen we fix the number of flowers in a certain direction, the rest of flowers must be in the opposite direction.\n\nTherefore the rest of flowers in the same direction of Alice must be 1, 2,..., floor(n/2).\n\nSimilarly, the rest of flowers in the same direction of Bob must be 1, 2,..., floor(m/2).\n\nFor example, when n=6, m=4, the number of flowers in a clockwise direction can be (1, 2), (1, 3), (2, 3), (1, 4), (2, 4), (3, 4) and the number of flowers in an anti-clockwise direction can be (1, 2), (1, 3), (2, 3), (1, 4), (2, 4), (3, 4), (1, 5), (2, 5), (3, 5) and the pairs (x, y) are all valid.\n\n## Code\n\nfrom functools import reduce", "groundtruth": "class Solution {\n    public long flowerGame(int n, int m) {\n        long a = ((long)n/2) * ((long)m-((long)m/2));\n        long b = ((long)m/2) * ((long)n-((long)n/2));\n        return a + b;\n    }\n}\n"}
{"task_id": "java/8", "content": "*/\nclass Solution {\npublic:\n    int minOrAfterOperations(vector<int>& nums, int k) {\n        const int N = nums.size();\n        int ans = 0, mask = 0;\n        for (int b = 29; b >= 0; b--) {\n            mask |= 1 << b;\n            int cnt = 0; // 合并的次数\n            int and = -1; // -1 的二进制全为 1\n            for (int x : nums) {\n                and &= x & mask;\n                if (and!= 0) {\n                    cnt++; // 合并\n                } else {\n                    and = -1;\n                }\n            }\n            if (cnt > k) {\n                ans |= 1 << b;\n                mask ^= 1 << b;\n            }\n        }\n        return ans;\n    }\n};\n\n/*\nGiven an array of integers nums, a 0-indexed prefix sum array is a split of nums where S[0] = nums[0], and for all i > 0, S[i] = S[i - 1] + nums[i].\n\nReturn true if the given array has a partition that satisfies all of the following conditions:\n\nThe length of the partition is at least 2.\n\nFor all i and j in the partition, i < j, the number nums[j] - nums[i] is divisible by 3.\n\nFor any index k not in the partition, nums[k] is divisible by 3.\n\nOtherwise, return false.\n*/\nbool isDivisible(int x) {\n    for (int i = 0; i <= 10; i++) {\n        if (x % 3 == 0) {\n            return true;\n        }\n        x += 10;\n    }\n    return false;\n}\n\nclass Solution {\npublic:\n    bool isDivisibleBy3(vector<int>& A) {\n        int sum = 0;\n        for (auto& e : A) {\n            sum += e;\n        }\n        return isDivisible(sum);\n    }\n};\n\n/*\nOn a 0-indexed aluminium rod of length n, there is a 0-indexed array rodCost of length n where rodCost[i] is the cost of rearranging the rod to make it straight", "groundtruth": "class Solution {\n    public int minOrAfterOperations(int[] nums, int k) {\n        int ans = 0;\n        int mask = 0;\n        for (int b = 29; b >= 0; b--) {\n            mask |= 1 << b;\n            int cnt = 0; // 操作次数\n            int and = -1; // -1 的二进制全为 1\n            for (int x : nums) {\n                and &= x & mask;\n                if (and != 0) {\n                    cnt++; // 合并 x，操作次数加一\n                } else {\n                    and = -1; // 准备合并下一段\n                }\n            }\n            if (cnt > k) {\n                ans |= 1 << b; // 答案的这个比特位必须是 1\n                mask ^= 1 << b; // 后面不考虑这个比特位\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/9", "content": "package com.algorithm.graph;\n\nimport java.util.Arrays;\nimport java.util.LinkedList;\n\npublic class DirectedGraph {\n    private final int vertexNum;\n    private final int edgeNum;\n    private LinkedList<Edge>[] adj;\n    public int[] inDegree;\n    private String vertexNames[];\n    //通过下标遍历链表\n    public void initializeInDegree(){\n        this.inDegree=new int[vertexNum];\n        Arrays.fill(inDegree,0);\n        for (int i = 0; i < edgeNum; i++) {\n            inDegree[adj[i].get(0).getTail()]++;\n        }\n    }\n    public int getVertexNum() {\n        return vertexNum;\n    }\n\n    public int getEdgeNum() {\n        return edgeNum;\n    }\n\n    public DirectedGraph(String[] vertexNames, int vertexNum, int edgeNum) {\n        this.vertexNum = vertexNum;\n        this.edgeNum = edgeNum;\n        this.vertexNames = vertexNames;\n        //构造邻接表\n        adj = new LinkedList[vertexNum];\n        for (int i = 0; i < vertexNum; i++) {\n            adj[i] = new LinkedList<>();\n        }\n    }\n    //邻接表添加边\n    public void addEdge(int head, int tail) {\n        adj[head].add(new Edge(head,tail));\n    }\n    //返回邻接表的头结点的链表\n    public LinkedList<Edge> getAdj(int head){\n        return adj[head];\n    }\n    @Override\n    public String toString() {\n        StringBuilder stringBuilder = new StringBuilder();\n        for (int i = 0; i < vertexNum; i++) {\n            stringBuilder.append(vertexNames[i] + \": \");\n            for (Edge edge : adj[i]) {\n                stringBuilder.append(vertexNames[edge.getTail()] + \", \");\n            }\n            stringBuilder.delete(stringBuilder.length() - 2, stringBuilder.length());\n            stringBuilder.append(\"\\n\");\n        }\n        return stringBuilder.toString();\n    }\n}\npublic class MyHashMap {\n\n    private final int DEFAULT_INITIAL_CAPACITY = 16;\n    private final float DEFAULT_LOAD_FACTOR = 0.75f;\n    public Node[] buckets;\n    public float loadFactor;\n\n    public MyHashMap() {\n        buckets = new Node[DEFAULT_INITIAL_", "groundtruth": "class Solution {\n    public int[] countOfPairs(int n, int x, int y) {\n        int w[][] = new int[n + 1][n + 1];\n        int INF = Integer.MAX_VALUE / 2;\n        //初始化 邻接矩阵。\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                w[i][j] = (i == j ? 0 : INF);\n        //额外的捷径的权值是1。但不能是自身到自身，因为自身到自身的权值本来就是0.\n        if (x != y) {\n            w[x][y] = 1;\n            w[y][x] = 1;\n        }\n        //建图，前后相邻 权值都是1。\n        for (int i = 1; i < n; i++) {\n            w[i][i + 1] = 1;\n            w[i + 1][i] = 1;\n        }\n        //佛洛依德算法\n        for (int p = 1; p <= n; p++)\n            for (int st = 1; st <= n; st++)\n                for (int end = 1; end <= n; end++)\n                    w[st][end] = Math.min(w[st][end], w[st][p] + w[p][end]);\n        //先用下标从0开始的数组来求结果。\n        int[] res = new int[n + 1];\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                if (w[i][j] != INF)\n                    res[w[i][j]]++;\n        //最终再遍历一次把求得的结果放到 下标从1开始的result数组。\n        int[] result  = new int[n];\n        for (int i = 0; i < n; i++)\n            result[i] = res[i + 1];\n        return result;\n    }\n}\n"}
{"task_id": "java/10", "content": "*/\nclass Solution {\n\tpublic int[] countOfPairs(int n, int x, int y) {\n\t\tint w[][] = new int[n + 1][n + 1];\n\t\tint INF = Integer.MAX_VALUE / 2;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tw[i][j] = (i == j? 0 : INF);\n\t\t\t}\n\t\t}\n\t\tif (x!= y) {\n\t\t\tw[x][y] = 1;\n\t\t\tw[y][x] = 1;\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tw[i][i + 1] = 1;\n\t\t\tw[i + 1][i] = 1;\n\t\t}\n\t\tfor (int p = 1; p <= n; p++) {\n\t\t\tfor (int st = 1; st <= n; st++) {\n\t\t\t\tfor (int end = 1; end <= n; end++) {\n\t\t\t\t\tif (w[st][p] + w[p][end] < w[st][end]) {\n\t\t\t\t\t\tw[st][end] = w[st][p] + w[p][end];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res[] = new int[n + 1];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (w[i][j]!= INF) {\n\t\t\t\t\tres[w[i][j]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint result[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tresult[i] = res[i + 1];\n\t\t}\n\t\treturn result;\n\t}\n}/1914. Cyclically Rotating a Grid.java\nYou are given an m x n integer matrix grid, where m and n are both even integers, and an integer k.\n\nThe matrix is rotated k times in the clockwise direction.\n\nReturn the result of", "groundtruth": "class Solution {\n    public int[] countOfPairs(int n, int x, int y) {\n        int w[][] = new int[n + 1][n + 1];\n        int INF = Integer.MAX_VALUE / 2;\n        \n        //初始化 邻接矩阵。\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                w[i][j] = (i == j ? 0 : INF);\n\n        //额外的捷径的权值是1。但不能是自身到自身，因为自身到自身的权值本来就是0.\n        if (x != y) {\n            w[x][y] = 1;\n            w[y][x] = 1;\n        }\n\n        //建图，前后相邻 权值都是1。\n        for (int i = 1; i < n; i++) {\n            w[i][i + 1] = 1;\n            w[i + 1][i] = 1;\n        }\n\n        //佛洛依德算法\n        for (int p = 1; p <= n; p++)\n            for (int st = 1; st <= n; st++)\n                for (int end = 1; end <= n; end++)\n                    w[st][end] = Math.min(w[st][end], w[st][p] + w[p][end]);\n\n        //先用下标从0开始的数组来求结果。\n        int[] res = new int[n + 1];\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                if (w[i][j] != INF)\n                    res[w[i][j]]++;\n\n        //最终再遍历一次把求得的结果放到 下标从1开始的result数组。\n        int[] result  = new int[n];\n        for (int i = 0; i < n; i++)\n            result[i] = res[i + 1];\n\n        return result;\n    }\n}\n"}
{"task_id": "java/11", "content": "\nExample 1:\nInput: nums = [2,3,5,9]\nOutput: true\nExplanation: We can sort the array in one operation.\nSwap 9 and 5, nums becomes [2, 3, 5, 9].\nSwap 9 and 3, nums becomes [2, 3, 5, 9].\n\nExample 2:\nInput: nums = [1,3,2,2,2]\nOutput: false\nExplanation: One swap is not enough to make all the numbers have the same number of set bits.\n\nExample 3:\nInput: nums = [1]\nOutput: true\nExplanation: There is nothing to sort, every element has a single set bit.\n\nConstraints:\n1 <= nums.length <= 1000\n1 <= nums[i] <= 109\n */\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\nbool canSortArray(vector<int> &nums) {\n  int cnt = 0;\n  int max = 0;\n  for (int num : nums) {\n    if (cnt == 0 || cnt == ___) {\n      cnt = ____;\n      max = num;\n    } else {\n      cnt = ___;\n      max = ____;\n    }\n    if (num < max) {\n      return false;\n    }\n  }\n  return true;\n}\n};\n\nint main() {\n  Solution s;\n  vector<int> v;\n  bool res;\n  v = {2, 3, 5, 9};\n  res = s.canSortArray(v);\n  cout << (res? \"true\" : \"false\") << endl;\n  v = {1, 3, 2, 2, 2};\n  res = s.canSortArray(v);\n  cout << (res? \"true\" : \"false\") << endl;\n  v = {1};\n  res = s.canSortArray(v);\n  cout << (res? \"true\" : \"false\") << endl;\n}/*\nQuestion:\nGiven a 01 matrix M, find the longest line of consecutive one in the matrix. The line could be horizontal, vertical, diagonal or anti-diagonal.\nYou need to return the length of the longest line which", "groundtruth": "class Solution {\n    public boolean canSortArray(int[] nums) {\n        int lastCnt = 0;\n        int lastGroupMax = 0;\n        int curGroupMax = 0;\n        for (int num : nums) {\n            int curCnt = Integer.bitCount(num);\n            if (curCnt == lastCnt) {\n                curGroupMax = Math.max(curGroupMax, num);\n            } else {\n                lastCnt = curCnt;\n                lastGroupMax = curGroupMax;\n                curGroupMax = num;\n            }\n            if (num < lastGroupMax) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "java/12", "content": "*/\nclass Solution {\n    public int minimumArrayLength(int[] nums) {\n        int m = Integer.MAX_VALUE;\n        for (int x : nums) {\n            m = Math.min(m, x);\n        }\n\n        for (int x : nums) {\n            if (x % m > 0) {\n                return 1;\n            }\n        }\n\n        int cnt = 0;\n        for (int x : nums) {\n            if (x == m) {\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n}\n/Algorithm/LeetCode/[Easy] 1185. Day of the Week.java\nclass Solution {\n    private int getDayNum(String[] day, String s) {\n        for (int i = 0; i < day.length; i++) {\n            if (day[i].equals(s)) {\n                return i;\n            }\n        }\n        \n        return -1;\n    }\n\n    public String dayOfTheWeek(int day, int month, int year) {\n        int[] monthDay = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n        String[] dayOfWeek = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n        String[] mName = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\n        int diff = 0;\n        for (int i = 1970; i < year; i++) {\n            diff += 365 + ((i % 4 == 0) && (i % 100!= 0) || (i % 400 == 0));\n        }\n\n        if ((year % 4 == 0) && (year % 100!= 0) || (year % 400 == 0)) {\n            if (month == 1) {\n                diff += day - 1;\n            } else {\n                diff += monthDay[month - 1] + (month > 2? 1 : 0) + day - 1;\n            }\n        } else {\n            if (month == ", "groundtruth": "class Solution {\n    public int minimumArrayLength(int[] nums) {\n        int m = Integer.MAX_VALUE;\n        for (int x : nums) {\n            m = Math.min(m, x);\n        }\n\n        for (int x : nums) {\n            if (x % m > 0) {\n                return 1;\n            }\n        }\n\n        int cnt = 0;\n        for (int x : nums) {\n            if (x == m) {\n                cnt++;\n            }\n        }\n        return (cnt + 1) / 2;\n    }\n}\n"}
{"task_id": "java/13", "content": "\nExample 1:\n\nInput: nums = [3,4,1,6,7,5], k = 3, dist = 3\nOutput: 18\nExplanation: The optimal solution is to divide the array into [3,4,1], [6,7,5] and [6,7,5] with costs of 3, 11 and 12 respectively.\nExample 2:\n\nInput: nums = [5,3,2,4,1], k = 3, dist = 3\nOutput: 6\nExplanation: The optimal solution is to divide the array into [5,3,2], [4,1] and [4,1] with costs of 5, 6 and 5 respectively.\nExample 3:\n\nInput: nums = [5,1,1,1,1], k = 1, dist = 2\nOutput: 8\nExplanation: The optimal solution is to divide the array into [5], [1,1,1,1] with costs of 5 and 4 respectively.\n \n\nConstraints:\n\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^9\n1 <= k, dist <= min(10^5, nums.length - 1)\n*/\n/0401-0500/0468_Validate_IP_Address/Validate_IP_Address.cpp\n/*\nFor a given string, the task is to check whether it is a valid IP Address or not.\n\nExamples:\n\nInput : 0.1.23.45\nOutput: 16345\n(First valid ip address)\n\nInput : 255.12213.1.4.0\nOutput: -1\n(Not valid ip address, due to trailing 0)\n\nInput : 11111111111111111111111.1.255.255\nOutput: 11111111111111111111111\n(First valid ip address)\n\nInput : 256.12213.1.4\nOutput: -1\n(", "groundtruth": "class Solution {\n    public long minimumCost(int[] nums, int k, int dist) {\n        k--;\n        sumL = nums[0];\n        for (int i = 1; i < dist + 2; i++) {\n            sumL += nums[i];\n            L.merge(nums[i], 1, Integer::sum);\n        }\n        sizeL = dist + 1;\n        while (sizeL > k) {\n            l2r();\n        }\n\n        long ans = sumL;\n        for (int i = dist + 2; i < nums.length; i++) {\n            // 移除 out\n            int out = nums[i - dist - 1];\n            if (L.containsKey(out)) {\n                sumL -= out;\n                sizeL--;\n                removeOne(L, out);\n            } else {\n                removeOne(R, out);\n            }\n\n            // 添加 in\n            int in = nums[i];\n            if (in < L.lastKey()) {\n                sumL += in;\n                sizeL++;\n                L.merge(in, 1, Integer::sum);\n            } else {\n                R.merge(in, 1, Integer::sum);\n            }\n\n            // 维护大小\n            if (sizeL == k - 1) {\n                r2l();\n            } else if (sizeL == k + 1) {\n                l2r();\n            }\n\n            ans = Math.min(ans, sumL);\n        }\n        return ans;\n    }\n\n    private long sumL;\n    private int sizeL;\n    private final TreeMap<Integer, Integer> L = new TreeMap<>();\n    private final TreeMap<Integer, Integer> R = new TreeMap<>();\n\n    private void l2r() {\n        int x = L.lastKey();\n        removeOne(L, x);\n        sumL -= x;\n        sizeL--;\n        R.merge(x, 1, Integer::sum);\n    }\n\n    private void r2l() {\n        int x = R.firstKey();\n        removeOne(R, x);\n        sumL += x;\n        sizeL++;\n        L.merge(x, 1, Integer::sum);\n    }\n\n    private void removeOne(Map<Integer, Integer> m, int x) {\n        int cnt = m.get(x);\n        if (cnt > 1) {\n            m.put(x, cnt - 1);\n        } else {\n            m.remove(x);\n        }\n    }\n}\n"}
{"task_id": "java/14", "content": "*/\nclass Solution {\n    private static char[] text;\n    private static int[] pi;\n    public int[] beautifulIndices(String s, String a, String b, int k) {\n        text = s.toCharArray();\n        char[] patternA = a.toCharArray();\n        List<Integer> posA = kmp(patternA);\n        char[] patternB = b.toCharArray();\n        List<Integer> posB = kmp(patternB);\n\n        List<Integer> res = new ArrayList<>();\n        for (int i : posA) {\n            int bi = lowerBound(posB, i - k);\n            if (bi < posB.size() && posB.get(bi) - i <= k ||\n                    bi > 0 && i - posB.get(bi - 1) <= k) {\n                res.add(i);\n            }\n        }\n        int[] result = new int[res.size()];\n        for (int i = 0; i < res.size(); i++) {\n            result[i] = res.get(i);\n        }\n        return result;\n    }\n\n    private static void initPi(char[] pattern) {\n        int m = pattern.length;\n        pi = new int[m];\n        int c = 0;\n        for (int i = 1; i < m; i++) {\n            char v = pattern[i];\n            while (c > 0 && pattern[c]!= v) {\n                c = pi[c - 1];\n            }\n            if (pattern[c] == v) {\n                c++;\n            }\n            pi[i] = c;\n        }\n    }\n\n    private static List<Integer> kmp(char[] pattern) {\n        List<Integer> res = new ArrayList<>();\n        initPi(pattern);\n        int c = 0;\n        for (int i = 0; i < text.length; i++) {\n            char v = text[i];\n            while (c > 0 && pattern[c]!= v) {\n                c = pi[c - 1];\n            }\n            if (pattern[c] == v) {\n                c++;\n            }\n            if (c == pattern.length) {\n                res.add(i - pattern.length + 1);\n                c = pi[c - 1];\n            }\n        }\n        return res;\n    }\n\n    private static int lowerBound(List<Integer>", "groundtruth": "class Solution {\n    public List<Integer> beautifulIndices(String s, String a, String b, int k) {\n        char[] text = s.toCharArray();\n        List<Integer> posA = kmp(text, a.toCharArray());\n        List<Integer> posB = kmp(text, b.toCharArray());\n\n        List<Integer> ans = new ArrayList<>();\n        for (int i : posA) {\n            int bi = lowerBound(posB, i);\n            if (bi < posB.size() && posB.get(bi) - i <= k ||\n                bi > 0 && i - posB.get(bi - 1) <= k) {\n                ans.add(i);\n            }\n        }\n        return ans;\n    }\n\n    private List<Integer> kmp(char[] text, char[] pattern) {\n        int m = pattern.length;\n        int[] pi = new int[m];\n        int c = 0;\n        for (int i = 1; i < m; i++) {\n            char v = pattern[i];\n            while (c > 0 && pattern[c] != v) {\n                c = pi[c - 1];\n            }\n            if (pattern[c] == v) {\n                c++;\n            }\n            pi[i] = c;\n        }\n\n        List<Integer> res = new ArrayList<>();\n        c = 0;\n        for (int i = 0; i < text.length; i++) {\n            char v = text[i];\n            while (c > 0 && pattern[c] != v) {\n                c = pi[c - 1];\n            }\n            if (pattern[c] == v) {\n                c++;\n            }\n            if (c == m) {\n                res.add(i - m + 1);\n                c = pi[c - 1];\n            }\n        }\n        return res;\n    }\n\n    // 开区间写法\n    private int lowerBound(List<Integer> nums, int target) {\n        int left = -1, right = nums.size(); // 开区间 (left, right)\n        while (left + 1 < right) { // 区间不为空\n            // 循环不变量：\n            // nums[left] < target\n            // nums[right] >= target\n            int mid = (left + right) >>> 1;\n            if (nums.get(mid) < target) {\n                left = mid; // 范围缩小到 (mid, right)\n            } else {\n                right = mid; // 范围缩小到 (left, mid)\n            }\n        }\n        return right;\n    }\n}\n"}
{"task_id": "java/15", "content": "\n```\n\n- [ ] code\n\n# 503. 下一个更大元素 II\n\n[题目](https://leetcode.cn/problems/next-greater-element-ii/) / [题解](https://github.com/Annerdeandert/CodingInterviews/blob/main/%E6%B1%87%E6%80%BB%E9%A2%98%E7%9B%AE/%E5%85%B6%E5%AE%83%E9%A2%98%E7%9B%AE.md#503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-ii) / [题解](https://github.com/Annerdeandert/CodingInterviews/blob/main/503.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20II.md)\n\n```markdown\n\n给定一个循环数组 (last index is next to first index) nums = [1,2,1], \n打印出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一次出现的数字，这意味着你应该循环访问数组，直到你找到下一个元素大于你的数字或者到达数组的最后一个元素。如果不存在更大的元素，输出 -1。\n\n示例 1: 输入: nums = [1,2,1]\n输出: [2,-1,2]\n解释: 第一个 1 的下一个更大的数是 2；\n数字 2 找不到下一个更大的数； \n第二个 1 的下一个最大的数需要循环访问数组接近 10 次，然后得到 2。\n\n说明: 循环数组是指数组最后一个数字的下", "groundtruth": "class Solution {\n    public long findMaximumNumber(long k, int x) {\n        this.x = x;\n        long left = 0;\n        long right = (k + 1) << x;\n        while (left + 1 < right) {\n            long mid = (left + right) >>> 1;\n            if (countDigitOne(mid) <= k) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n\n    private int x;\n    private long num;\n    private long memo[][];\n\n    private long countDigitOne(long num) {\n        this.num = num;\n        int m = 64 - Long.numberOfLeadingZeros(num);\n        memo = new long[m][m + 1];\n        for (long[] row : memo) {\n            Arrays.fill(row, -1);\n        }\n        return dfs(m - 1, 0, true);\n    }\n\n    private long dfs(int i, int cnt1, boolean isLimit) {\n        if (i < 0) return cnt1;\n        if (!isLimit && memo[i][cnt1] != -1) return memo[i][cnt1];\n        int up = isLimit ? (int) (num >> i & 1) : 1;\n        long res = 0;\n        for (int d = 0; d <= up; d++) {\n            res += dfs(i - 1, cnt1 + (d == 1 && (i + 1) % x == 0 ? 1 : 0), isLimit && d == up);\n        }\n        if (!isLimit) memo[i][cnt1] = res;\n        return res;\n    }\n}\n"}
{"task_id": "java/16", "content": "\nFor example, if the given n is 2, the output should be [\"01\",\"10\"].\nIf the given n is 4, the output should be [\"0011\",\"0101\",\"1010\",\"1100\",\"0010\",\"0111\",\"1101\",\"1000\",\"0100\",\"1001\"].f (x.charAt(i)!= y.charAt(j)) {\n                i--;\n                j--;\n            } else {\n                s.append(x.charAt(i));\n                i--;\n                j--;\n            }\n        }\n        return s.toString();\n    }\n}/src/main/java/com/github/sd4324530/interview/leetcode/LC_541_0001.java\npackage com.github.sd4324530.interview.leetcode;\n\nimport java.util.Arrays;\n\n/*\nGiven a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string.\n\nIf there are fewer than k characters left, reverse all of them.\nIf there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.\n\nReturn the final reversed string.\n\nExample 1:\nInput: s = \"abcdefg\", k = 2\nOutput: \"bacdfeg\"\n\nExample 2:\nInput: s = \"abcd\", k = 2\nOutput: \"bacd\"\n\nConstraints:\n    1 <= s.length <= 104\n    s consists of only lowercase English letters.\n    1 <= k <= 104\n*/\npublic class LC_541_0001 {\n    public String reverseStr(String s, int k) {\n        char[] chars = s.toCharArray();\n        int l = 0, r = 2 * k - 1;\n        while (l < s.length()) {\n            r = Math.min(r, s.length() - 1);\n            int i = l, j = r;\n            while (i < j) {\n                swap(chars, i, j);\n                i++;\n                j--;\n            }\n            l = l + 2 *", "groundtruth": "class Solution {\n    public List<String> validStrings(int n) {\n        List<String> ans = new ArrayList<>();\n        int mask = (1 << n) - 1;\n        for (int i = 0; i < (1 << n); i++) {\n            int x = mask ^ i;\n            if (((x >> 1) & x) == 0) {\n                ans.add(Integer.toBinaryString((1 << n) | i).substring(1));\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/17", "content": "/**\n * @param {number} n\n * @param {number} k\n * @return {string[]}\n */\nvar getPermutation = function(n, k) {\n    const s = new Array(n);\n    for(let i = 0; i < n; i++) {\n        s[i] = i + 1;\n    }\n    let r = k - 1;\n    let c = 1;\n    let ans = \"\";\n    while(r > 0){\n        if(r >= c){\n            ans += s.shift();\n            r -= c;\n            c *= n;\n        }\n        else {\n            ans += s[r / (c/n) | 0];\n            r %= c;\n            c /= n;\n        }\n    }\n    return ans;\n};/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * class NestedInteger {\n *   public:\n *     // Constructor initializes an empty nested list.\n *     NestedInteger();\n *\n *     // Constructor initializes a single integer.\n *     NestedInteger(int value);\n *\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     bool isInteger() const;\n *\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\n *     // The result is undefined if this NestedInteger holds a nested list\n *     int getInteger() const;\n *\n *     // Set this NestedInteger to hold a single integer.\n *     void setInteger(int value);\n *\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\n *     void add(const NestedInteger &ni);\n *\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\n *     // The result is undefined if this NestedInteger holds a single integer\n *     const vector<NestedInteger> &getList() const;\n * };\n */\nclass Solution {\npublic:\n    int depthSumInverse(vector<NestedInteger>& nestedList) {\n        vector<vector<int> > sum(nestedList.size() + 1);\n        sum.back().push_back(0);\n        for(int i = nestedList.size", "groundtruth": "class Solution {\n    public int numberOfSubmatrices(char[][] grid) {\n        int ans = 0;\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][][] sum = new int[m + 1][n + 1][2];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                sum[i + 1][j + 1][0] = sum[i + 1][j][0] + sum[i][j + 1][0] - sum[i][j][0];\n                sum[i + 1][j + 1][1] = sum[i + 1][j][1] + sum[i][j + 1][1] - sum[i][j][1];\n                if (grid[i][j] != '.') {\n                    sum[i + 1][j + 1][grid[i][j] & 1]++;\n                }\n                if (sum[i + 1][j + 1][0] > 0 && sum[i + 1][j + 1][0] == sum[i + 1][j + 1][1]) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/18", "content": "Please write the code in the following format:\npublic int function(int[] args) {\n    // complete the function\n}\n*/\n\npublic int minimumCost(String target, String[] words, int[] costs) {\n    char[] t = target.toCharArray();\n    int n = t.length;\n\n    final int MOD = 1_070_777_777;\n    final int BASE = (int) 8e8 + new Random().nextInt((int) 1e8); // 随机 base，防止 hack\n    int[] powBase = new int[n + 1]; // powBase[i] = base^i\n    int[] preHash = new int[n + 1]; // 前缀哈希值 preHash[i] = hash(target[0] 到 target[i-1])\n    powBase[0] = 1;\n    for (int i = 0; i < n; i++) {\n        powBase[i + 1] = (int) ((long) powBase[i] * BASE % MOD);\n        preHash[i + 1] = (int) (((long) preHash[i] * BASE + t[i]) % MOD);\n    }\n\n    Map<Integer, Map<Integer, Integer>> minCost = new TreeMap<>(); // 长度 -> 哈希值 -> 最小成本\n    for (int i = 0; i < words.length; i++) {\n        long h = 0;\n        for (char b : words[i].toCharArray()) {\n            h = (h * BASE + b) % MOD;\n        }\n        minCost.computeIfAbsent(words[i].length(), k -> new HashMap<>())\n              .merge((int) h, costs[i], Integer::min);\n    }\n\n    int[] f = new int[n + 1];\n    Arrays.fill(f, Integer.MAX_VALUE);\n    f[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        for (Map.Entry<Integer, Map<Integer, Integer>> e : minCost.entrySet()) {\n            int len = e.getKey();\n            if (len > i) {\n                break;\n            }\n            int subHash = (int) (((preHash[i] - (long) preHash[i - len] * powBase[", "groundtruth": "class Solution {\n    public int minimumCost(String target, String[] words, int[] costs) {\n        char[] t = target.toCharArray();\n        int n = t.length;\n\n        final int MOD = 1_070_777_777;\n        final int BASE = (int) 8e8 + new Random().nextInt((int) 1e8);\n        int[] powBase = new int[n + 1];\n        int[] preHash = new int[n + 1];\n        powBase[0] = 1;\n        for (int i = 0; i < n; i++) {\n            powBase[i + 1] = (int) ((long) powBase[i] * BASE % MOD);\n            preHash[i + 1] = (int) (((long) preHash[i] * BASE + t[i]) % MOD);\n        }\n\n        Map<Integer, Map<Integer, Integer>> minCost = new TreeMap<>();\n        for (int i = 0; i < words.length; i++) {\n            long h = 0;\n            for (char b : words[i].toCharArray()) {\n                h = (h * BASE + b) % MOD;\n            }\n            minCost.computeIfAbsent(words[i].length(), k -> new HashMap<>())\n                   .merge((int) h, costs[i], Integer::min);\n        }\n\n        int[] f = new int[n + 1];\n        Arrays.fill(f, Integer.MAX_VALUE / 2);\n        f[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            for (Map.Entry<Integer, Map<Integer, Integer>> e : minCost.entrySet()) {\n                int len = e.getKey();\n                if (len > i) {\n                    break;\n                }\n                int subHash = (int) (((preHash[i] - (long) preHash[i - len] * powBase[len]) % MOD + MOD) % MOD);\n                f[i] = Math.min(f[i], f[i - len] + e.getValue().getOrDefault(subHash, Integer.MAX_VALUE / 2));\n            }\n        }\n        return f[n] == Integer.MAX_VALUE / 2 ? -1 : f[n];\n    }\n}\n"}
{"task_id": "java/19", "content": "Example 1:\nInput:\nnums = [1,2,3]\n2 -> 1 -> 3 -> null\nOutput: 2 -> 1 -> null\nExplanation:\nThe value 3 exists in nums and should be removed.\nTherefore, 1 -> 3 -> null is returned.\nExample 2:\nInput:\nnums = [2,3]\n5 -> 2 -> 3 -> 3 -> null\nOutput: 5 -> 3 -> null\nExplanation:\nThe value 3 exists in nums and should be removed.\nTherefore, 5 -> 2 -> 3 -> null is returned.\n\n*/\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc modifiedList(nums []int, head *ListNode) *ListNode {\n\tset := make(map[int]bool)\n\tfor i := 0; i < len(nums); i++ {\n\t\tset[nums[i]] = true\n\t}\n\tdummy := &ListNode{Next: head}\n\tcur := dummy\n\tfor cur.Next!= nil {\n\t\tif set[cur.Next.Val] {\n\t\t\tcur.Next = cur.Next.Next\n\t\t} else {\n\t\t\tcur = cur.Next\n\t\t}\n\t}\n\treturn dummy.Next\n}\n/go/leetcode/438_find-all-anagrams-in-a-string/main.go\npackage main\n\n/*\nGiven a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.\n\nThe order of output does not matter.\n\nExample 1:\n\nInput:\ns: \"cbaebabacd\" p: \"abc\"\n\nOutput:\n[0, 6]\n\nExplanation:\nThe substring with start index = 0 is \"cba\", which is an anagram of \"abc\".\nThe substring with start index = 6 is \"bac\", which is an anagram of \"abc\".\nExample 2:\n\nInput:\ns: \"abab\" p: \"ab\"", "groundtruth": "class Solution {\n    public ListNode modifiedList(int[] nums, ListNode head) {\n        Set<Integer> set = new HashSet<>(nums.length); // 预分配空间\n        for (int x : nums) {\n            set.add(x);\n        }\n        ListNode dummy = new ListNode(0, head);\n        ListNode cur = dummy;\n        while (cur.next != null) {\n            if (set.contains(cur.next.val)) {\n                cur.next = cur.next.next; // 删除\n            } else {\n                cur = cur.next; // 向后移动\n            }\n        }\n        return dummy.next;\n    }\n}\n"}
{"task_id": "java/20", "content": "The time limit is 1 second for judging, and 2 second for submitting.\n/LeetCode/src/main/java/com/hujiang/leetcode/Solution_778_SwimInRisingWater.java\npackage com.hujiang.leetcode;\n\nimport java.util.Arrays;\n\n/**\n * 778. Swim in Rising Water\n *\n * On an N x N grid, each square grid[i][j] represents the elevation at that point (i,j).\n * Now rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim.\n *\n * You start at the top left square (0, 0). What is the least time until you can reach the bottom right square (N-1, N-1)?\n *\n * Example 1:\n *\n * Input: [[0,2],[1,3]]\n * Output: 3\n * Explanation:\n * At time 0, you are in grid location (0, 0).\n * You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.\n * You cannot reach point (1, 1) until time 3.\n * When the depth of water is 3, we can swim anywhere inside the grid.\n *\n * Example 2:\n *\n * Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]\n * Output: 16\n * Explanation:\n *  0  1  2  3  4\n * 24 23 22 21  5\n * 12 13 14 15 16\n * 11 17 18 19 20\n * 10  9  8  7  ", "groundtruth": "class Solution {\n    public int minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {\n        int[][][][] dp = new int[m][n][m][n];\n        for (int i1 = 0; i1 < m; i1++) {\n            for (int j1 = 0; j1 < n; j1++) {\n                for (int i2 = 0; i2 < m; i2++) {\n                    Arrays.fill(dp[i1][j1][i2], Integer.MAX_VALUE);\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[i][j][i][j] = 0;\n            }\n        }\n        for (int rowCount = 1; rowCount <= m; rowCount++) {\n            for (int colCount = 1; colCount <= n; colCount++) {\n                for (int i1 = 0, i2 = rowCount - 1; i2 < m; i1++, i2++) {\n                    for (int j1 = 0, j2 = colCount - 1; j2 < n; j1++, j2++) {\n                        for (int midRow = i1; midRow < i2; midRow++) {\n                            dp[i1][j1][i2][j2] = Math.min(dp[i1][j1][i2][j2], horizontalCut[midRow] + dp[i1][j1][midRow][j2] + dp[midRow + 1][j1][i2][j2]);\n                        }\n                        for (int midCol = j1; midCol < j2; midCol++) {\n                            dp[i1][j1][i2][j2] = Math.min(dp[i1][j1][i2][j2], verticalCut[midCol] + dp[i1][j1][i2][midCol] + dp[i1][midCol + 1][i2][j2]);\n                        }\n                    }\n                }\n            }\n        }\n        return dp[0][0][m - 1][n - 1];\n    }\n}\n"}
{"task_id": "java/21", "content": "\nTestcase 1:\nInput:\ns = \"z\"\nOutput:\ntrue\n\nTestcase 2:\nInput:\ns = \"zaybck\"\nOutput:\nfalse\n*/\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool doesAliceWin(string s) {\n        bool result = false;\n        for (auto c : s) {\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n    string s;\n    cin >> s;\n    cout << solution.doesAliceWin(s) << endl;\n    return 0;\n}\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* cloneGraph(TreeNode* node) {\n        if (!node) {\n            return node;\n        }\n\n        unordered_map<TreeNode*, TreeNode*> map;\n        stack<TreeNode*> st;\n        st.push(node);\n        map[node] = new TreeNode(node->val);\n        while (!st.empty()) {\n            auto curr = st.top();\n            st.pop();\n\n            for (auto child : curr->children) {\n                if (map.count(child) == 0) {\n                    st.push(child);\n                    map[child] = new TreeNode(child->val);\n                }\n                map[curr]->children.push_back(map[child]);\n            }\n        }\n\n        return map[node];\n    }\n};\n\nint main() {\n    TreeNode *a = new TreeNode(1);\n    TreeNode *b = new TreeNode(2);\n    TreeNode *c = new TreeNode(3);\n    TreeNode *d = new TreeNode(4);\n    a->", "groundtruth": "class Solution {\n    public boolean doesAliceWin(String s) {\n        for (char c : s.toCharArray()) {\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"task_id": "java/22", "content": "'''\n\nclass Solution:\n    def maxOperations(self, s: str) -> int:\n        cnt = 0\n        res = 0\n        for i in s:\n            if i == '1':\n                cnt += 1\n            if i == '0' and cnt:\n                res += cnt\n                cnt -= 1\n        return res\n\n/leetcode_java/src/main/java/com/fzd/leetcode/string/LC1528.java\npackage com.fzd.leetcode.string;\n\n/**\n * https://leetcode-cn.com/problems/shuffle-string/\n *\n * @author D228\n */\npublic class LC1528 {\n    public String restoreString(String s, int[] indices) {\n        char[] arr = s.toCharArray();\n        for (int i = 0; i < s.length(); i++) {\n            arr[indices[i]] = s.charAt(i);\n        }\n        return new String(arr);\n    }\n}\n/leetcode_python/string/LC392_Is_Subsequence.py\n'''\nLC392. Is Subsequence\nhttps://leetcode-cn.com/problems/is-subsequence/\n'''\n\nclass Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        i = 0\n        j = 0\n        l = len(s)\n        if not l:\n            return True\n        while j < len(t):\n            if s[i] == t[j]:\n                i += 1\n                if i >= l:\n                    break\n            j += 1\n        if i >= l:\n            return True\n        else:\n            return False\n\n\nclass Solution2(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n                j += 1\n            else:\n                j += 1\n        return i == len(s)\n\n\ns = Solution2()\nprint(s.isSubsequence(\"b\", \"c\"))\n\n'''", "groundtruth": "class Solution {\n    public int maxOperations(String S) {\n        char[] s = S.toCharArray();\n        int ans = 0;\n        int cnt1 = 0;\n        for (int i = 0; i < s.length; i++) {\n            if (s[i] == '1') {\n                cnt1++;\n            } else if (i > 0 && s[i - 1] == '1') {\n                ans += cnt1;\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/23", "content": "*/\n//https://zxi.mytechroad.com/blog/dynamic-programming/leetcode-1896-minimum-operations-to-reinitialize-a-permutation/\nclass Solution {\n    public long minimumOperations(int[] nums, int[] target) {\n        long s = target[0] - nums[0];\n        long ans = Math.abs(s);\n        for (int i = 1; i < nums.length; i++) {\n            int k = (target[i] - target[i - 1]) - (nums[i] - nums[i - 1]);\n            if (k > 0) {\n                ans += s >= 0? 1: 0;\n            } else {\n                ans -= s <= 0? k : Math.min(k + s, 0);\n            }\n            s += k;\n        }\n        return ans;\n    }\n}\n\n/*\n744. Minimum Length Words To Close The Sentence\nYou are given a sentence, shuffled such that each word is separated by a single space. This sentence may contain words that are repeated, and may contain punctuation such as \".\" and \",\" and may include numbers.\nFind the minimum length word in the sentence that contains every word in the original sentence.\nYou must minimize the length of the result.\nFor example:\nInput: sentence = \"the quick brown fox jumps over the lazy dog\"\nOutput: \"fox\"\nExplanation: \"fox\" is the shortest word that contains every word in the sentence.\nInput: sentence = \"this apple is sweet, this apple is sour\"\nOutput: \"this\"\nExplanation: \"this\" is the shortest word that contains every word in the sentence.\nNote:\nsentence.length <= 1000\nsentence consists only of lowercase and uppercase English letters, spaces and punctuation marks.\nsentence does not have leading or trailing spaces.\nAll the words in sentence are separated by a single space.\nEach word in sentence is also a valid English word.\n*/\n//https://leetcode.com/problems/minimum-length-words-to-close-the-sentence/discuss/111752/C%2B%2BJava-Prefix-Suffix-and-Greedy\nclass Solution {\n    public String shortestWord(String sentence) {\n        String[] words = sentence.split(\" \");\n        boolean", "groundtruth": "class Solution {\n    public long minimumOperations(int[] nums, int[] target) {\n        long s = target[0] - nums[0];\n        long ans = Math.abs(s);\n        for (int i = 1; i < nums.length; i++) {\n            int k = (target[i] - target[i - 1]) - (nums[i] - nums[i - 1]);\n            if (k > 0) {\n                ans += s >= 0 ? k : Math.max(k + s, 0);\n            } else {\n                ans -= s <= 0 ? k : Math.min(k + s, 0);\n            }\n            s += k;\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/24", "content": "Note:\n1.The number of special numbers in the range [l, r] must be returned.\n2.Time limit: 2 seconds\n3.Memory limit: 64 MB\n4.l and r are integers with 1 <= l <= r <= 10000000000.\n5.The sum of the lengths of l and r won't exceed 1000.\n6.When dealing with numbers with 0 or 1 decimal place, you may have some problems with the accuracy of calculation and rounding to the nearest integer. For the time being, please ignore this problem.\n'''\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        PI = [0] * (r + 1)\n        for i in range(2, r + 1):\n            if PI[i] == 0:  # i 是质数\n                PI[i] = PI[i - 1] + 1\n                for j in range(i * i, r + 1, i):\n                    PI[j] = -1  # 标记 i 的倍数为合数\n            else:\n                PI[i] = PI[i - 1]\n        return r - l + 1 - PI[r] - PI[l - 1]\n\n\nprint(Solution().nonSpecialCount(5, 10))/*\n给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。\n两个相邻元素间的距离为 1 。\n */\npackage 第二周.第七题;\n\nclass Solution1 {\n    public int[][] updateMatrix(int[][] matrix) {\n        int row = matrix.length;\n        int col = matrix[0].length;\n        int[][] res = new int[row][col];\n        //找到所有0点\n        for(int i = 0; i<row; i++){\n            for(int j = 0; j<col; j++){\n                if(matrix[i][j] == 0){\n                    update(matrix, res, i, j);\n                }\n            }\n        }\n        return res;\n    }\n\n    //搜索所有的0点到0的距离\n    private void update(int[][] matrix, int[][] res, int i, int j){\n       ", "groundtruth": "class Solution {\n    private static final int MX = 31622;\n    private static final int[] PI = new int[MX + 1];\n\n    static {\n        for (int i = 2; i <= MX; i++) {\n            if (PI[i] == 0) { // i 是质数\n                PI[i] = PI[i - 1] + 1;\n                for (int j = i * i; j <= MX; j += i) {\n                    PI[j] = -1; // 标记 i 的倍数为合数\n                }\n            } else {\n                PI[i] = PI[i - 1];\n            }\n        }\n    }\n\n    public int nonSpecialCount(int l, int r) {\n        return r - l + 1 - (PI[(int) Math.sqrt(r)] - PI[(int) Math.sqrt(l - 1)]);\n    }\n}\n"}
{"task_id": "python/0", "content": "\"\"\"\n\n\nimport numpy as np\n\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i in range(n):\n            for j in range(n):\n                for k in range(4):\n                    di, dj = DIRS[k]\n                    if 0 <= i + di < n and 0 <= j + dj < n:\n                        s[grid[i][j]][k // 2] += grid[i + di][j + dj]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n\n\nclass neighborSum1:\n    def __init__(self, grid):\n        self.grid = grid\n        self.n = len(grid)\n        self.s = [[0, 0] for _ in range(self.n * self.n)]\n        for i in range(self.n):\n            for j in range(self.n):\n                for k in range(4):\n                    di, dj = DIRS[k]\n                    if 0 <= i + di < self.n and 0 <= j + dj < self.n:\n                        self.s[self.grid[i][j]][k // 2] += self.grid[i + di][j + dj]\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n\n\"\"\"\nThis problem requires using a 2-Dimensional array, but not directly using the built-in matrix class in Python.\n\"\"\"\nclass neighborSum2:\n\n    DIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\n    def __init__(self, grid):\n        self.n = len(grid)\n        s = [[0 for _ in range(self.n)] for _ in range(self.n", "groundtruth": " DIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n    "}
{"task_id": "python/1", "content": "'''\n\nclass NeighborSum:\n\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n\n\nclass NeighborSum:\n    def __init__(self, grid):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value):\n        return self.s[value][0]\n\n    def diagonalSum(self, value):\n        return self.s[value][1]\n\ngrid = [[44,41,35,17,68,84,86,59,87,57,27,8,5,79,24,28],\n [42,29,46,93,26,73,7,62,9,85,36,84,84,91,77,7],\n [98,87,56,98,79,47,55,11,30,49,97,63,78,19,77,67],\n [74,70,18,13,74,21", "groundtruth": " DIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n "}
{"task_id": "python/2", "content": "'''\nfrom typing import List\n\n\nclass Solution:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(Solution.DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    @property\n    def DIRS(self):\n        return ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n\n\nif __name__ == \"__main__\":\n    n = 2\n    # n = 3\n    grid = [[0, 1, 2],\n            [1, 2, 3],\n            [2, 3, 4]]\n\n    # grid = [[2, 0, 5],\n    #         [1, 1, 5],\n    #         [0, 2, 4]]\n\n    grid = [[2, 0, 3],\n            [1, 1, 4],\n            [0, 4, 4]]\n\n    obj = Solution(grid)\n    print(obj.adjacentSum(0))\n    print(obj.diagonalSum(0))\n    print(obj.adjacentSum(1))\n    print(obj.diagonalSum(1))\n    print(obj.adjacentSum(2))\n    print(obj.diagonalSum(2))\n    print(obj.adjacentSum(4))\n    print(obj.diagonalSum(4))\n    print(obj.adjacentSum(5))\n    print(obj.diagonalSum(5))\n    print(obj.adjacentSum(3))\n    print(obj.diagonalSum(3))\n/leetcodes/797_all_paths_from", "groundtruth": " DIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n  "}
{"task_id": "python/3", "content": "/Algorithms/1001-2000/1017. Convert to Base -2/1017. Convert to Base -2.py\nclass Solution:\n    def baseNeg2(self, n: int) -> str:\n        if n == 0:\n            return '0'\n        base = 2\n        ans = []\n        while n!= 0:\n            if n % base == 0:\n                ans.append('0')\n            else:\n                ans.append('1')\n                n = (n - n % base) / base - 1\n        return ''.join(ans[::-1])\n/Algorithms/1001-2000/1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold/1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold.py\nfrom typing import List\nimport math\n\nclass Solution:\n    def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:\n        res = 0\n        tmp = 0\n        l = 0\n        s = 0\n        for r in range(len(arr)):\n            s += arr[r]\n            tmp += arr[r]\n            if r - l + 1 >= k:\n                while tmp < threshold * k:\n                    tmp -= arr[l]\n                    l += 1\n            if r - l + 1 == k:\n                res += 1\n            if s >= threshold * k and r - l + 1 == k:\n                res += math.factorial(k) // (math.factorial(k // 2) * math.factorial(k - k // 2))\n        return res\n\n# Test on Cases\nif __name__ == '__main__':\n    solution = Solution()\n\n    print(\"---LC Example---\")\n    arr = [2,2,2,2,5,5,5,8]\n    k = 3\n    threshold = 4\n    testResult = solution.numOfSubarrays(arr, k, threshold)\n    print(\"Test result of for arr: \" + str(arr) + \" k: \" + str(k) + \" and threshold: \" + str(threshold) + \" is matching \" + str(testResult))\n\n    print(\"---LC Example---\")", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n  "}
{"task_id": "python/4", "content": "For example, the following is the correct code to fill in:\nfrom collections import deque\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y]!= i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n'''\ndef shortestDistanceAfterQueries(n, queries):\n    g = [[i + 1] for i in range(n - 1)]\n    vis = [-1] * (n - 1)\n\n    def bfs(i):\n        q = deque([0])\n        for step in count(1):\n            tmp = q\n            q = []\n            for x in tmp:\n                for y in g[x]:\n                    if y == n - 1:\n                        return step\n                    if vis[y]!= i:\n                        vis[y] = i\n                        q.append(y)\n        return -1\n\n    ans = [0] * len(queries)\n    for i, (l, r) in enumerate(queries):\n        g[l].append(r)\n        ans[i] = bfs(i)\n    return ans\n\n\nn = 5\nqueries = [[1, 2], [0, 3], [0, 2], [2, 3], [2, 4], [1, 4], [1, 3], [2, 1], [4, 3]]\nprint(shortestDistanceAfterQueries(n, queries))/leetcode/problems/1680.py\n'''\n1680. Concatenation of Consecutive Binary Numbers\nUser Accepted:\n2634\nUser Tried:", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n "}
{"task_id": "python/5", "content": "\nInput: n = 6, queries = [[0,1],[0,3],[3,2],[2,4],[5,0],[4,0]]\nOutput: [1,2,3,2,1,0]\nExplanation: After making changes, the graph becomes the following.\nThe shortest path from 0 to 5 is 0 --> 1 --> 3 --> 2 --> 4 --> 0, so the answer is 3.\n\nHint: #\n\"\"\"\n\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y]!= i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [bfs(i) for i in range(len(queries))]\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i + len(queries))\n        return ans\n/Coding/Coding_python/1671. Minimum Number of Removals to Make Mountain Array.py\n\"\"\"\n[1671] Minimum Number of Removals to Make Mountain Array\n\nA mountain array is a non-empty array with the following properties:\nThe array size is at least 2.\nEvery element is an integer, and these integers are unique.\nValues of the array must be increasing and decreasing.\nIn other words, there is at least one i such that a1 < a2 <... < a(i - 1) < a(i) > a(i + 1) >... > a(n - 1).\nGiven an integer array mountains, return the minimum number of elements you need to remove to make the remaining array a mountain array. If there is no way to remove elements to make the array a mountain array, return ", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n "}
{"task_id": "python/6", "content": "\"\"\"\n\nimport collections\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt]!= rt:\n                rt = fa[rt]\n            while fa[x]!= rt:\n                fa[x], x = fr, ________\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n\n\"\"\"\n请你设计一个可以计数的动态集合。\n实现 CountingBST 类：\n CountingBST() 初始化空计数 BST 树。\n int count(int minValue, int maxValue) 向 BST 树中插入节点[minValue, maxValue] 后，返回小于等于 maxVal 且大于等于 minVal 的元素个数。\n 给定插入操作为 insert(root, val)，返回插入该值的节点后，小于等于 val 的元素的个数。\n 提示：\n 树的总节点数不会超过 5000。\n 每次调用 count 方法的次数不会超过 1000。\n 0 <= minValue <= maxValue <= 105\n 1 <= val <= 105\n 所有 CountingBST.count 方法中的操作都是非递归的。\n\"\"\"\nimport heapq\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def count(self, node, low, high) -> int:\n        if not node: return 0\n\n        count = 0\n        if node.val > low:\n            count = self.count(node.left, low, high) + 1\n        elif node.val == low:\n            count = 1 + self.count(node.left", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/7", "content": "The above code is wrong, as the method does not complete the function of the shortest path after the query.\n/LeetCode/Binary_Tree_Inorder_Traversal.py\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\n@author: LiYang\n@file: Binary_Tree_Inorder_Traversal.py\n@time: 2021/11/29 11:34\n@desc:\n\"\"\"\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n# recursion\nclass Solution:\n    def inorderTraversal(self, root: TreeNode):\n        res, self.ret = [], []\n\n        def dfs(node: TreeNode) -> None:\n            if not node: return\n\n            dfs(node.left)\n            self.ret.append(node.val)\n            dfs(node.right)\n\n        dfs(root)\n        return self.ret\n\n\n# iteration\nclass Solution:\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\n        stack, res = [], []\n\n        while stack or root:\n            if root:\n                stack.append(root)\n                root = root.left\n            else:\n                node = stack.pop()\n                res.append(node.val)\n                root = node.right\n\n        return res\n\n\n# 迭代器\nclass Solution:\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\n        stack, res = [], []\n\n        while stack or root:\n            if root:\n                stack.append(root)\n                root = root.left\n            else:\n                node = stack.pop()\n                res.append(node.val)\n                root = node.right\n\n        return res\n\n\"\"\"\n给定一个二叉树的根节点 root ，返回它的 中序 遍历。\n\n提示：\n\n树中节点数目在范围 [0, 100] 内\n-100 <= Node.val <= 100\n进阶: 递归算法很简单，你可以通过迭代算法完成吗？\n\"\"\"/LeetCode/Longest_Palindromic_Subsequence.py\n#!/usr/bin/env python\n# -*- coding:", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/8", "content": "\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt]!= rt:\n                rt = fa[rt]\n            while fa[x]!= rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n/0036. 有效的数独.py\n给定一个 9x9 的数独问题单。\n请你验证该数独是否唯一。\n\n说明：\n\n一个有效的数独（部分已被填充）不一定是可解的。\n只需要根据以上规则，验证已经填入的数字是否有效即可。\n空格位不应被附加为要验证的数字。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/valid-sudoku\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\nclass Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n\n        s = {str(i) for i in range(10)}\n        for i in board:\n            x, y, z = set(), set(), set()\n            for j in i:\n                if j!= '.' and j in x:\n                    return False\n                x.add(j)\n            for j in range(9):\n                if board[j][y]!= '.' and board[j][y] in y:\n                    return False\n                y.add(board[j][y])\n            for j in range(3):\n                for k in range(3):\n                    if board[j * 3 + k // 3][(y // 3)", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/9", "content": "\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n\n        if len(nums) == 0 or len(nums) == 1:\n            return len(nums)\n        slow_index = 0\n        while slow_index < len(nums):\n            fast_index = slow_index\n            while fast_index+1<len(nums) and nums[fast_index] == nums[fast_index+1]:\n                fast_index += 1\n            nums[slow_index] = nums[fast_index]\n            slow_index += 1\n\n        return slow_index\nclass Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n    int max_aght_index){\n            st.pop();\n        }\n        st.push(height_index);\n    }\n    return max_area;\n    }\n};\nrea = 0;\n    stack<int>st;\n    st.push(-1);\n    for (int i = 0;i<heights.size();i++){\n        while(st.size()>1 && heights[i]<heights[st.top()]){\n            int height_index = st.top();\n            st.pop();\n            max_area = max(max_area, heights[height_index]*(i-st.top()-1));\n\n        }\n        st.push(i);\n    }\n    while (st.size()>1){\n        int height_index = st.top();\n        st.pop();\n        max_area = max(max_area, heights[height_index]*(heights.size()-st.top()-1));\n    }\n    return max_area;\n    }\n};\n\nclass Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n    int max_area = 0;\n    stack<int>st;\n    for (int height_index=0;height_index<heights.size();height_index++){\n        while(st.size()>0 && heights[height_index]<heights[st.top()]){\n            int height_index = st.top();\n            st.pop();\n            max_area = max(max_area, heights[height_index]*(height_index-st.top()-1));\n        }\n        st.push(height_index);", "groundtruth": " from sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/10", "content": "\"\"\"\n/leetcode/python/1824.py\n\"\"\"\nAn integer array is called a wiggle array when the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A wiggle subarray is any subarray which is a wiggle array.\nGiven an integer array nums, return the longest wiggle subarray.\nA subarray is a contiguous non-empty sequence of elements within an array.\nExample 1:\nInput: nums = [1,7,4,9,2,5]\nOutput: 6\nExplanation: The longest wiggle subarray is [1,7,4,9,2,5].\nExample 2:\nInput: nums = [1,17,5,10,13,15,10,5,16,8]\nOutput: 7\nExplanation: There are several subarrays with length 7.\nOne is [1,17,5,10,13,15,10,5].\nExample 3:\nInput: nums = [1,2,3,4,5,6,7,8,9]\nOutput: 2\nConstraints:\n1 <= nums.length <= 1000\n0 <= nums[i] <= 1000\nAccepted\n117,429\nSubmissions\n329,388\n\"\"\"\n\n\nclass Solution:\n    def longestWiggleSubarray(self, nums: List[int]) -> int:\n        dp = [0 for _ in range(len(nums))]\n        return max(dp)\n\n\nclass Solution:\n    def longestWiggleSubarray(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n <= 1:\n            return n\n        dp = [[0, 0] for _ in range(n)]\n        dp[0][0], dp[0][1] = 1, 1\n        ans = 1\n        for i in range(1, n):\n            if nums[i] > nums[i - 1]:\n                dp[i][0] = dp[i - 1][0]\n                dp[i][1] = max(dp[i][1], dp[i -", "groundtruth": " from sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/11", "content": "\"\"\"\n\nfrom sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i", "groundtruth": " from sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/12", "content": "'''\n\n\nclass Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        single=0\n        double=0\n        for it in nums:\n            if it>=10: \n                double+=it\n            else:\n                single+=it\n        \n        return single!=double\n\nif __name__ == '__main__':\n    nums = [5,3,3,4,3,8,4,7,2,4]\n    print(Solution().canAliceWin(nums))# -*- coding: utf-8 -*-\n# Time:  O(nlogn)\n# Space: O(n)\n\"\"\"\nhttps://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/\n\n给定从 1 到 n 编号的 n 名小伙伴，为使牛奶传递运行得更快，可以进行数次传递。其中，编号为 1 的小伙伴，\n每次传递牛奶时将编号为 2 到 n 的小伙伴的编号为偶数的位移一个位置，而编号为 2 到 n 的小伙伴每次传递\n牛奶时将编号为 1 到 n-1 的小伙伴的编号为奇数的位移一个位置。给定小伙伴的总数 n 和小伙伴编号，确定\n编号为 1 的小伙伴在数 k 轮传递中最终传递的牛奶编号。\n\n示例 1：\n    输入：n = 5, k = 2\n    输出：3\n\n示例 2：\n    输入：n = 6, k = 2\n    输出：5\n\n限制：\n1 <= k <= n <= 109\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\"\"\"\n\n\nclass Solution:\n    def findTheWinner(self, n: int, k: int) -> int:\n        # nums = [i for i in range(", "groundtruth": " class Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        single=0\n        double=0\n        for it in nums:\n            if it>=10: \n                double=double+it \n            else:\n                single=single+it  \n        \n        return single !=double\n "}
{"task_id": "python/13", "content": "\"\"\"\n\n\nMX = 31622\npi = [0] * (MX + 1)\nfor i in range(2, MX + 1):\n    if pi[i] == 0:  # i 是质数\n        pi[i] = 0\n        for j in range(i * i, MX + 1, i):\n            pi[j] = -1  # 标记 i 的倍数为合数\n    else:\n        pi[i] = pi[i - 1]\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        return r - l + 1 - (pi[isqrt(r)] - pi[isqrt(l - 1)])nst char * s)\n{\n\tunsigned int p = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (m1[i][j])\n\t\t\t\tp += a[i] * b[j];\n\t\tp += c[i];\n\t\tif (s[i]!= tolower(c[i]) - 'a' + 'A')\n\t\t\treturn 0;\n\t\ta[i] = p;\n\t\tp = 0;\n\t}\n\treturn 1;\n}\n\nint main()\n{\n\tcin >> n >> m1;\n\tcout << m1.is_square() << endl;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tcin >> m1[i][j];\n\tcin >> a >> b;\n\tcin >> c;\n\tcin >> s;\n\tcout << cryptanalyse(m1, a, b, c, s) << endl;\n\treturn 0;\n}/*\n解题报告\n本题与大作业中的问题相同，请参考大作业解答\n*/\n\n#include <iostream>\n#include <Matrix.h>\n\nusing namespace std;\nusing Matrix = cstlib::Matrix<double>;\n\nMatrix m1;\nMatrix a;\nMatrix b;\nMatrix c;\n", "groundtruth": " MX = 31622\npi = [0] * (MX + 1)\nfor i in range(2, MX + 1):\n    if pi[i] == 0:  # i 是质数\n        pi[i] = pi[i - 1] + 1\n        for j in range(i * i, MX + 1, i):\n            pi[j] = -1  # 标记 i 的倍数为合数\n    else:\n        pi[i] = pi[i - 1]\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        return r - l + 1 - (pi[isqrt(r)] - pi[isqrt(l - 1)])\n"}
{"task_id": "python/14", "content": "\n\"\"\"\n\n\nl, r = map(int, input().split())\n\nMX = 31622\npi = [0] * (MX + 1)\nfor i in range(2, MX + 1):\n    if pi[i] == 0:  # i 是质数\n        pi[i] = pi[i - 1] + 1\n        for j in range(i * i, MX + 1, i):\n            pi[j] = -1  # 标记 i 的倍数为合数\n    else:\n        pi[i] = pi[i - 1]\n\ndef nonSpecialCount(l, r):\n    return r - l - pi[-1]\n\nprint(nonSpecialCount(l, r))\n# encoding:utf-8\n\n# 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。\n# 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。\n# 示例:\n# 给定 nums = [2, 7, 11, 15], target = 9\n# 因为 nums[0] + nums[1] = 2 + 7 = 9\n# 所以返回 [0, 1]\n#\n# https://leetcode-cn.com/problems/two-sum\n\nclass Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        for idx, i in enumerate(nums):\n            for j in nums[idx+1:]:\n                if i+j == target:\n                    return [idx, nums.index(j)+idx+1]\n            else:\n                pass\n\n\n\"\"\"\n给定一个整数数组，判断是否存在重复元素。\n\n如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。\n\n示例 1:\n\n输入: [1,2,3,1]\n输出: true\n示例 2:\n\n输入: [1,2,3,4]\n输出: false\n示例 3:\n\n输入: [1,1,1,3,3", "groundtruth": " MX = 31622\npi = [0] * (MX + 1)\nfor i in range(2, MX + 1):\n    if pi[i] == 0:  # i 是质数\n        pi[i] = pi[i - 1] + 1\n        for j in range(i * i, MX + 1, i):\n            pi[j] = -1  # 标记 i 的倍数为合数\n    else:\n        pi[i] = pi[i - 1]\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        return r - l + 1 - (pi[isqrt(r)] - pi[isqrt(l - 1)])\n "}
{"task_id": "python/15", "content": "*/\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n\nclass Solution {\npublic:\n    int numberOfSubstrings(string s) {\n        int n = s.size();\n        int zero = 0, one = 0, ans = 0;\n        vector<int> pre(2);\n        pre[0] = 0;\n        pre[1] = n;\n        for (char c : s) {\n            ans += min(min(pre[0], pre[1] - pre[0]), zero * zero - one);\n            if (c == '0')\n                zero++;\n            else {\n                one++;\n                ans++;\n            }\n            if (c == '1')\n                ans++;\n            pre[c - '0']++;\n        }\n        return ans;\n    }\n};\n\n\nint main() {\n\n    std::cout << \"Hello, World!\" << std::endl;\n    return 0;\n}\n/*\n * @lc app=leetcode.cn id=189 lang=cpp\n *\n * [189] 旋转数组\n *\n * https://leetcode-cn.com/problems/rotate-array/description/\n *\n * algorithms\n * Easy (42.42%)\n * Likes:    685\n * Dislikes: 0\n * Total Accepted:    180.6K\n * Total Submissions: 426.9K\n * Testcase Example:  '[1,2,3,4,5,6,7]\\n3'\n *\n * 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。\n *\n * 示例 1:\n *\n * 输入: [1,2,3,4,5,6,7] 和 k = 3\n * 输出: [5,6,7,1,2,3,4]\n * 解释:\n * 向右旋转 1 步: [7,1,2,3,4,5,6]\n * 向右旋转 2 步: [6,7,1,2,3,4,5]\n * 向右旋转 3 步: [5,6,7,1,2", "groundtruth": " class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n "}
{"task_id": "python/16", "content": "Example 1:\nInput: s = \"00110011\"\nOutput: 9\nExplanation: There are 9 substring in total with dominant ones: \"0\", \"00\", \"000\", \"0000\", \"01\", \"010\", \"0100\", \"1\", and \"100\".\nExample 2:\nInput: s = \"10101\"\nOutput: 4\nExplanation: There are 4 substring in total with dominant ones: \"00101\", \"1\", \"10\", and \"101\".\n \n\nConstraints:\n\n1 <= s.length <= 105\ns[i] is either '0' or '1'.\n'''\nimport collections\nclass Solution(object):\n    def numberOfSubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        cnt = collections.Counter()\n        ans, rk = 0, 0\n        for c in s:\n            cnt[c] += 1\n            while cnt['0'] - cnt['1'] > rk:\n                cnt[s[rk]] -= 1\n                rk += 1\n            ans += rk\n        return ans\n\n\nclass Solution1(object):\n    def numberOfSubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        res = 0\n        cnt0 = cnt1 = 0\n        for c in s:\n            if c == '0':\n                cnt0 += 1\n            elif c == '1':\n                cnt1 += 1\n            if cnt0 >= cnt1:\n                res += cnt0\n            else:\n                cnt0 = cnt1 = 0\n        return res\n'''\n48. Rotate Image\nMedium\n\n2241\n\n267\n\nAdd to List\n\nShare\nYou are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n\n \n\nExample 1:\n\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7", "groundtruth": " class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n    "}
{"task_id": "python/17", "content": "'''\nclass Solution(object):\n    def numberOfSubstrings(self, s):\n        n = len(s)\n        s, idx = [i for i, b in enumerate(s) if b == '0'], 0\n        s.append(n)\n        ans = 0\n        for l in range(n):\n            a = s[idx] - l\n            tot1 = n - a - 1\n            for i in range(idx, len(s) - 1):\n                k = i + 1\n                cnt0, cnt1 = k - i, s[k] - l - (k - i)\n                if cnt0*cnt0 > tot1:\n                    break\n                ans += cnt1\n            if s[idx] <= l:\n                idx += 1\n\n        return ans\n\n\n\n\nprint(Solution().numberOfSubstrings(\"11010\"))     else:\n#             print(\"0\")\n#     else:\n#         print(\"1\")\n#     n=n>>1/面试算法练习题/字节跳动面试练习题/剑指offer/剑指 Offer 62. 圆圈中最后剩下的数字/剑指 Offer 62. 圆圈中最后剩下的数字.py\n# class Solution(object):\n#     def lastRemaining(self, n, m):\n#         \"\"\"\n#         :type n: int\n#         :type m: int\n#         :rtype: int\n#         \"\"\"\n#         f=[0]*n\n#         l=0\n#         for i in range(n):\n#             f[i]=i\n#         while len(f)!=1:\n#             num=m\n#             for i in range(l,n):\n#                 if num==0:\n#                     del f[i]\n#                     if i==n-1:\n#                         l=0\n#                     else:\n#                         l=i+1\n#                     break\n#                 else:\n#                     num-=1\n#\n#             n-=1\n#         return f[0]\nclass Solution(object):\n    def lastRemaining(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: int\n        \"\"\"\n        a=0\n        for i in", "groundtruth": " class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n    "}
{"task_id": "python/18", "content": "'''\n\n\n# coding=utf-8\n\n\nclass Solution(object):\n    def canReachCorner(self, X, Y, circles):\n        \"\"\"\n        :type X: int\n        :type Y: int\n        :type circles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        def in_circle(ox, oy, r, x, y):\n            return (x - ox) ** 2 + (y - oy) ** 2 <= r ** 2\n        \n        vis = [False] * len(circles)\n        def dfs(i):\n            x1, y1, r1 = circles[i]\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                if not vis[j] and \\\n                   (x1 - x2) ** 2 + (y1 - y2) ** 2 <= (r1 + r2) ** 2 and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n        for i, (x, y, r) in enumerate(circles):\n            if in_circle(x, y, r, 0, 0) or \\\n               in_circle(x, y, r, X, Y) or \\\n               not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n\nX = 3\nY = 3\ncircles = [[0,1,2],[1,0,1],[1,2,3],[2,2,1],[3,1,2],[2,3,3],[2,4,2],[4,3,1],[3,4,3],[4,", "groundtruth": " class Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and \\\n                   (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or \\\n               in_circle(x, y, r, X, Y) or \\\n               not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n    "}
{"task_id": "python/19", "content": "\nExample 1:\n\nInput: X = 2, Y = 2, circles = [[1,1,1],[1,1,1]]\nOutput: false\n\nExample 2:\n\nInput: X = 2, Y = 2, circles = [[1,1,1],[1,1,1],[0,0,1]]\nOutput: true\nExplanation: The circle at [1,1,1] is in the middle of the rectangle, while the circle at [0,0,1] is in the middle of the rectangle but touches the side.\nNote:\n\n1 <= X,Y <= 100\n1 <= circles.length <= 100\ncircles[i].length == 3\n1 <= x_i, y_i, r_i <= 100\n*/\n\nclass Solution {\npublic:\n    bool in_circle(int ox, int oy, int r, int x, int y) {\n        return ((ox - x) * (ox - x) + (oy - y) * (oy - y)) <= r * r;\n    }\n    bool dfs(int i, vector<int> &x, vector<int> &y, vector<int> &r, vector<bool> &vis) {\n        if (x[i] <= 2 && abs(y[i] - 2) <= r[i]) return true;\n        vis[i] = true;\n        for (int j = 0; j < (int)x.size(); j++) {\n            if (!vis[j]) {\n                if ((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) <= (r[i] + r[j]) * (r[i] + r[j]) && y[i] * r[j] + y[j] * r[i] < (r[i] + r[j]) * 2 && dfs(j, x, y, r, vis))\n                    return true;\n            }\n        }\n        return false;\n    }\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        vector<int> x(circles.size(), 0", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or                x1 <= X and y1 <= r1 or                x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and                    (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and                    x1 * r2 + x2 * r1 < (r1 + r2) * X and                    y1 * r2 + y2 * r1 < (r1 + r2) * Y and                    dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or                in_circle(x, y, r, X, Y) or                not vis[i] and (x <= X and abs(y - Y) <= r or                                y <= Y and x <= r or                                y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/20", "content": "Constraints:\n\nn == circles.length\n1 <= n <= 50\n1 <= X, Y <= 50\n1 <= circles[i][0], circles[i][1] <= 50\n1 <= circles[i][2] <= 50\n'''\nfrom typing import List\n\n\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            if y1 <= Y and abs(x1 - X) <= r1:\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                if not vis[j] and                    (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and                    x1 * r2 + x2 * r1 < (r1 + r2) * X and                    y1 * r2 + y2 * r1 < (r1 + r2) * Y and                    dfs(j):\n                    return True\n            return False\n\n        vis = [False] * len(circles)\n        for i, (x, y, r) in enumerate(circles):\n            if in_circle(x, y, r, 0, 0) or                in_circle(x, y, r, X, Y) or                not vis[i] and (x <= X and abs(x - X) <= r or                                y <= Y and abs(y - Y) <= r or                                y > Y and in_circle(x, y, r, X, Y)) and dfs(i):\n                return False\n        return True\n\n\nSolution().canReachCorner(4, 21, [[30,", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or                x1 <= X and y1 <= r1 or                x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and                    (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and                    x1 * r2 + x2 * r1 < (r1 + r2) * X and                    y1 * r2 + y2 * r1 < (r1 + r2) * Y and                    dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or                in_circle(x, y, r, X, Y) or                not vis[i] and (x <= X and abs(y - Y) <= r or                                y <= Y and x <= r or                                y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/21", "content": "\nThe code should run in time complexity O(n * n)\n\nThe example is as follows:\nInput: grid = [[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1]]\nOutput: 0\nExplanation: The graph looks like this:\n1 /--1--0\n1 /--1--0\n1 /--1--0\n1 /--1--0\nEach number represents the corresponding team number.\nTeams 0 and 1 are the only two teams with no team stronger than them, so team 0 wins in the tournament.\n\nclass Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        def check(i):\n            for j in range(n):\n                if i == j:\n                    continue\n                elif grid[i][j] == 1 and grid[j][i] == 0:\n                    continue\n                else:\n                    return False\n            return True\n        n = len(grid)\n        for i in range(n):\n            if check(i):\n                return i\n'''\n\nclass Solution:\n    def findChampion(self, grid):\n        n = len(grid)\n\n        def check(i):\n            for j in range(n):\n                if i == j:\n                    continue\n                elif grid[i][j] == 1 and grid[j][i] == 0:\n                    return False\n            return True\n        for i in range(n):\n            if check(i):\n                return i\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    # Output: 0\n    # Explanation: The graph looks like this:\n    # 1 /--1--0\n    # 1 /--1--0\n    # 1 /--1--0\n    # 1 /--1--0\n    # Each number represents the corresponding team number.\n    # Teams 0 and 1 are the only two teams with no team stronger than them, so team 0 wins in the tournament.\n\n    grid = [[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1]]\n    print(sol.findChampion(grid))/LeetCode/Python/1000~1999/1232_Check_", "groundtruth": "\nclass Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        def check(i):\n            for j in range(n):\n                if i == j:\n                    continue\n                elif grid[i][j] == 1 and grid[j][i] == 0:\n                    continue\n                else:\n                    return False\n            return True\n        n = len(grid)\n        for i in range(n):\n            if check(i):\n                return i\n"}
{"task_id": "python/22", "content": "'''\n\n\nclass Solution(object):\n    def findChampion(self, n, edges):\n        graph = defaultdict(list)\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n\n        for i in range(n):\n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n\n            if count == n:\n                return i\n\n        return -1\n\n    def dfs(self, graph, start, visited):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n/lc_005_longest_palindromic_substring.py\n'''\nhttps://leetcode.com/problems/longest-palindromic-substring/description/\n\nGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\n\nExample 1:\n\nInput: \"babad\"\nOutput: \"bab\"\nNote: \"aba\" is also a valid answer.\n\nExample 2:\n\nInput: \"cbbd\"\nOutput: \"bb\"\n'''\n\n# dp solution\nclass Solution:\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        if s is None or len(s) == 0:\n            return \"\"\n        \n        self.maxLength = 1\n        result = s[0]\n        isPalin = [[False] * len(s) for _ in range(len(s))]\n        \n        for i in range(len(s)):\n            isPalin[i][i] = True\n            if i + 1 < len(s) and s[i] == s[i+1]:\n                self.maxLength = 2\n                result = s[i:i+2]\n                isPalin[i][i+1] = True\n                \n        for length in range(3, len(s)+1):\n            for start in range(len(s) - length + 1):\n                end = start + length -1\n                if s[start] == s[end] and isPalin[start+1][end-1]:\n                   ", "groundtruth": "\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/23", "content": "```\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n```# [449. 序列化和反序列化二叉搜索树](https://leetcode-cn.com/problems/serialize-and-deserialize-bst/)\n## 题目描述\n```\n序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。\n请设计一个算法来实现二叉搜索树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉搜索树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。\n提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉搜索树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。\n\n示例 1：\n输入：root = [2,1,3]\n输出：[2,1,3]\n示例 2：\n输入：root = []\n输出：[]\n\n提示：\n树中结点数在范围 [0, 104] 内\n0 <= Node.val <= 104\n题目数据 保证 输入的树是一棵二叉搜索树。\n```\n```python\nclass Codec:\n    def serialize(self, root: TreeNode) -> str:\n        \"\"\"Encodes a", "groundtruth": "\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/24", "content": "\nExample:\nInput: edges = [[0,1],[1,2]], values = [5,3,2]\nOutput: 10\nExplanation: An optimal path is 0 -> 2 -> 1.\n\nInput: edges = [[1,0],[1,2],[1,3]], values = [5,3,2,4]\nOutput: 12\nExplanation: An optimal path is 0 -> 1 -> 3 -> 1 -> 0.\n'''\nclass Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        path = {i: [] for i in range(len(nums))}\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v!= p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp0 + nums[u], dp1)\n            \n        return dfs(0)[1]/*\nOn an infinite plane, a robot initially stands at (0, 0) and faces north.  The robot can receive one of three instructions:\n\n\"G\": go straight 1 unit;\n\"L\": turn 90 degrees to the left;\n\"R\": turn 90 degress to the right.\nThe robot performs the instructions given in order, and repeats them forever.\n\nReturn true if and only if there exists a circle in the plane such that the robot never leaves the circle.\n\n \n\nExample 1:\n\nInput: instructions = \"GGLLGG\"\nOutput: true\nExplanation: \nThe robot moves from (0,0) to (0,2), turns 180 degrees, and then returns to (0,0).\nWhen repeating these instructions, the robot remains in the circle of radius 2 centered at the origin.\nExample 2:\n\nInput: instructions = \"GG\"\nOutput: false\nExplanation: \nThe robot moves north in", "groundtruth": "\nclass Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v != p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp1 + nums[u], dp0)\n            \n        return dfs(0)[1]\n"}
{"task_id": "python/25", "content": "\nConstraints:\nn == nums.length\n1 <= n <= 105\n1 <= nums[i] <= 106\n\nExample 1:\nInput: nums = [2,3,2,1]\nOutput: 6\nExplanation: There are 4 balanced subsequences: [3], [2], [2], and [1,2]. The sums of elements in each subsequence are 3, 2, 2, and 3, respectively. The maximum sum is 6. \n\nExample 2:\nInput: nums = [1,2,3,4,5]\nOutput: 15\nExplanation: The subsequence with indices [3,4,5] is the only one balanced. The sum of elements in the subsequence is 15.\n\nExample 3:\nInput: nums = [10,20,20,30,15]\nOutput: 70\nExplanation: The subsequence with indices [0,3,4] is the only one balanced. The sum of elements in the subsequence is 70.\n\nExample 4:\nInput: nums = [1,100,100,99,100]\nOutput: 200\nExplanation: The subsequence with indices [0,3,4] is the only one balanced. The sum of elements in the subsequence is 200.\n\nExample 5:\nInput: nums = [1,1,1,1,1]\nOutput: 5\nExplanation: Each subsequence is balanced, so the answer is 5.\n\n\"\"\"\n\n/problems/maximum-subarray-sum-after-one-operation.py\n\"\"\"\nhttps://leetcode.com/problems/maximum-subarray-sum-after-one-operation/\n\n(This problem is an interactive problem.)\nYou are given an array of integers nums. You can choose a subsequence of nums that makes the sum of all the integers in this subsequence greater than or equal to x. After that, you can delete some elements from this subsequence. You want the maximum possible subsequence sum after the operation.\nNote that you can delete any number of elements from the subsequence (including 0).\nIn one operation, you can choose either remove or delete any number of", "groundtruth": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/26", "content": "\nThe time complexity must be O(n*log(n)). The memory usage must be O(n).\n'''\n\n'''\nApproach: \n\n- If we do a normal range sum query, we'll have to store all elements which makes the cost O(n^2).\n- Instead, we'll use BIT to reduce it down to O(nlogn)\n- Let's say we are calculating the cost of i=2,4,6,8,10\n  - If you look at the element 2, it has a dependency on all previous (1) elements \n  - Let's say x1 = nums[1] - 1 and x2 = nums[2] - 2. In this case x1=0, x2=0, but what if we change the index x2 to nums[2] - 3 \n  - In this case the dependency has changed! so 5,6,7,8,9,10. Hence nums[j] - j will keep changing\n  - The way to handle this is to store the elements of nums[j]-j. This will make sure that we're not changing the dependencies based on the value\n- If you look at the cost of 5, in terms of x1 and x2, if the value was 0 at first, it has 2 new dependencies\n  - so 5 has 2 more dependencies in total\n- This is the way we will keep track of the dependencies. We will store the unique elements which are the dependencies \n  - in the sorted order and let's say [0,1,2,4] for the first few elements\n- As we're updating the tree, we'll also keep adding all dependencies of all x in the pre-set tree\n- We have a function pre_max which tells us the maximum of the pre-set tree in the range that we are querying. \n- The algorithm can be summarised as follows:\n\nPre-processing: \n- We will store all the unique elements in the sorted order as b, \n- Now we'll go in reverse order, and update each index j by adding the elements that it depends on. \n  - Eg: 1 depends on 0, 2 depends on 1, 3 depends on 2. Hence b=[0,1,2,3]\n\nQuery: \n- Take the index x and find the first", "groundtruth": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/27", "content": "\"\"\"\n\nimport math\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Tree(object):\n    def __init__(self):\n        self.root = None\n\n    def insert(self, node):\n        if self.root is None:\n            self.root = node\n        else:\n            cur = self.root\n            while cur is not None:\n                parent = cur\n                if node.val < cur.val:\n                    cur = cur.left\n                else:\n                    cur = cur.right\n            node.parent = parent\n            if node.val < parent.val:\n                parent.left = node\n            else:\n                parent.right = node\n        return self.root\n\n    def insertNode(self,val):\n        tmpNode = TreeNode(val)\n        self.root = self.insert(tmpNode)\n\n    def printTree(self):\n        print(self.root.val)\n        self.printTreeHelper(self.root)\n\n    def printTreeHelper(self, root):\n        if root is not None:\n            self.printTreeHelper(root.left)\n            print(root.val)\n            self.printTreeHelper(root.right)\n\n    def printTreeInorder(self):\n        self.printTreeInorderHelper(self.root)\n\n    def printTreeInorderHelper(self, node):\n        if node is not None:\n            self.printTreeInorderHelper(node.left)\n            print(node.val)\n            self.printTreeInorderHelper(node.right)\n\n    def printTreePreorder(self):\n        self.printTreePreorderHelper(self.root)\n\n    def printTreePreorderHelper(self, node):\n        if node is not None:\n            print(node.val)\n            self.printTreePreorderHelper(node.left)\n            self.printTreePreorderHelper(node.right)\n\n    def printTreePostorder(self):\n        self.printTreePostorderHelper(self.root)\n\n    def printTreePostorderHelper(self, node):\n        if node is not None:\n            self.printTreePostorderHelper(node.left)\n            self.printTreePostorderHelper(node.right)\n            print(node.val)\n\n    def deleteTree(self):\n        if self.root is None:\n            return\n        self.root = None\n\n    def deleteNode", "groundtruth": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/28", "content": "'''\n\n\nclass Solution:\n    def findKOr(self, nums: list, k: int) -> int:\n        ans = 0\n        for i in range(max(nums).bit_length()):\n            cnt1 = 0\n            for n in nums:\n                if n & (1 << i)!= 0:\n                    cnt1 += 1\n            if cnt1 >= k:\n                ans |= 1 << i\n        return ans'''\nQuestion\nGiven an array arr of size n, the task is to divide the array into two parts so that sum of the elements of both parts is same.\nInput:\nThe first line of input contains an integer T denoting the number of test cases. Then T test cases follow. Each test case contains an integer n denoting the size of the array. Then the next line contains array elements.\nOutput:\nFor each test case print the required output. If there is no possible output, then print \"not possible\" (without quotes).\n\nConstraints:\n1<= T <=100\n1<= n <=100\n1<= A[i] <=1000\n\nExample:\nInput:\n2\n3\n5 2 6\n4\n1 1 1 1\n\nOutput:\nyes\nnot possible\nExplanation:\nFor input 1: Sum of the two parts is 5+6 = 11 and 5+2 = 7.\n\nFor input 2: There is no two parts with the same sum.\n\nNote:The input array is stored using one-dimensional array.\n'''\n#code\n\n'''\nMethod 1: Iterative\nThe idea is to add elements of input array arr[] to a variable sum while traversing it. When there is an odd number of elements at this point then we have encountered an element with odd frequency and we return false as we can't add/subtract any elements to achieve equal frequency of both arrays. Otherwise, we initialize currSum and currFreq variables with sum and 1 respectively. For each index, we add/subtract its value based on its frequency and compare the current sum with sum/2. If difference between current sum and sum/2 is 0, then the input array has a subset of elements such that the sum of all subset elements is equal to the sum/2. Otherwise, we continue with the next index.\n\nAlgorithm:\n\nInitialize", "groundtruth": "\nclass Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for i in range(max(nums).bit_length()):\n            cnt1 = sum(x >> i & 1 for x in nums)\n            if cnt1 >= k:\n                ans |= 1 << i\n        return ans\n"}
{"task_id": "python/29", "content": "Note: The number of zeroes of both arrays should be the same. You do not need to replace all the zeroes with the same number. It is possible to replace some zeroes with the same number.\n\n\"\"\"\n\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = 0\n        zero2 = 0\n\n        for n in nums1:\n            if n == 0: zero1 += 1\n        for n in nums2:\n            if n == 0: zero2 += 1\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n# Write your MySQL query statement below\n\nSELECT name, (SELECT COUNT(*) FROM seats WHERE student.seat_id < seat_id) id\nFROM student\nORDER BY id;\n\n\nSELECT Student.name, COUNT(*) id\nFROM Student LEFT JOIN Exam ON Student.id = Exam.id\nGROUP BY Student.name \nORDER BY id;\"\"\"\nWe define a harmonious array is an array where the difference between its maximum value and its minimum value is exactly 1.\n\nGiven an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.\n\nA subsequence of array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.\n\n \n\nExample 1:\n\nInput: nums = [1,3,2,2,5,2,3,7]\nOutput: 5\nExplanation: The longest harmonious subsequence is [3,2,2,2,3].\nExample 2:\n\nInput: nums = [1,2,3,4]\nOutput: 2\nExample 3:\n\nInput: nums = [1,1,", "groundtruth": "\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n"}
{"task_id": "python/30", "content": "class Solution:\n    def replaceElements(self, arr: List[int]) -> List[int]:\n        max_num = arr[0]\n        for i in range(1, len(arr)):\n            if arr[i] > max_num:\n                arr[i], max_num = max_num, arr[i]\n        arr[-1] = -1\n        return arr\n            \n'''\nIf you think that you can make it in O(1), then you can solve it.\n'''\nfrom collections import defaultdict\nclass Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        seen = defaultdict(bool)\n        longest = 0\n        for num in nums:\n            if seen[num]:\n                continue\n            if seen[num - 1] and seen[num + 1]:\n                seen[num - 1], seen[num + 1] = False, False\n                length = 2 + seen[num - 1] + seen[num + 1]\n                longest = max(longest, length)\n            elif seen[num - 1] or seen[num + 1]:\n                length = 2 + seen[num - 1] + seen[num + 1]\n                longest = max(longest, length)\n            else:\n                seen[num] = True\n        return longest\n# Write your MySQL query statement below\nSELECT id, \n       IF(id NOT IN (SELECT MAX(id) FROM salary),\n           (SELECT DISTINCT salary FROM salary ORDER BY salary DESC LIMIT 1 OFFSET 1), \n           salary) AS salary\nFROM salary;\nclass Solution:\n    def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:\n        rows = [0] * len(grid)\n        columns = [0] * len(grid[0])\n        for i, row in enumerate(grid):\n            rows[i] = max(row)\n            for j, num in enumerate(row):\n                if num > columns[j]:\n                    columns[j] = num\n        \n        total = 0\n        for i, row in enumerate(grid):\n            for j, num in enumerate(row):\n                total += min(rows[i], columns[j]) - num\n        \n        return total\nclass Solution:\n    def firstUniqChar(self, s: str) -> int:\n        for i, c in enumerate(s):\n           ", "groundtruth": "\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n"}
{"task_id": "python/31", "content": "\nThe code should be completed in 30 lines, including import statements.\n'''\n\n'''\n题目大意\n给定一个数组 nums 和一个整数 k，你可以在 nums 的任意位置进行 1 次操作，将 nums 中下标为 i 的元素增加 1：请你返回让数组 nums 成为一个严格上升数组的最少操作次数。一个数组 nums 被认为是严格上升数组当且仅当 nums[i] < nums[i + 1] 总成立，所有的 i (0 <= i < nums.length - 1)。\n\n思路\ndp1：nums 中存在多少个严格不满足的位置，那么前 n+k 个元素中必然有 n 个 0 都被加上 1，需要进行 n 次操作\ndp2：nums 中严格满足小于等于 k 的位置总数，那么前 k 个元素中必然有 k 个 0 都被加上 1，需要进行 k 次操作\ndp3：dp[i-1][2]+nums[i]-nums[i-1]+1，前 i-1 个元素中至少要增加 i-1 次操作才能满足 nums[i]>nums[i-1]，然后 nums[i-1]+1 变为 nums[i]。\ndp[0][2]=0\n'''\n\nclass Solution(object):\n    def minIncrementForUnique(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        if not A: return 0\n        A.sort()\n        k = 0\n        for i in xrange(1, len(A)):\n            if A[i]<=A[i-1]:\n                k += A[i]-A[i-1]+1\n                A[i] = A[i-1]+1\n        return k\n\nif __name__ == '__main__':\n    print Solution().minIncrementForUnique([5,2,6,1])#coding=utf-8\n'''\nDescription\nA robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the", "groundtruth": "\nclass Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n        dp1 = dp2 = dp3 = 0\n        for num in nums:\n            dp1, dp2, dp3 = min(dp1, dp2, dp3) + max(0, k - num), dp1, dp2\n        return min(dp1, dp2, dp3)\n"}
{"task_id": "python/32", "content": "Note: \nn == coins.length \n1 <= n <= 105\nedges.length == n - 1\nedges[i].length == 2\n0 <= ai, bi < n\nai!= bi\nedges represents a valid tree.\n1 <= coins[i] <= 106\nk >= 0\n\"\"\"\nfrom collections import deque\n\nclass Solution:\n    def maximumPoints(self, edges, coins, k):\n        g = [[] for _ in range(len(coins))]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n        ans = 0\n\n        def bfs(i, j):\n            cur = [0] * 31\n            cur[0] = coins[i]\n            q = deque()\n            for ch in g[i]:\n                if ch!= j:\n                    q.append((ch, i, cur))\n            while q:\n                ind, fa, cur = q.popleft()\n                for idx, num in enumerate(cur):\n                    if num == 0:\n                        break\n                    res1 = num >> j\n                    res2 = num >> (j + 1)\n                    cur[idx] -= num\n                    ans = max(ans, max(res1, res2))\n                    if idx < 31:\n                        for ch in g[ind]:\n                            if ch!= fa:\n                                q.append((ch, ind, cur + [num]))\n        bfs(0, -1)\n        return ans\n\nif __name__ == '__main__':\n    S = Solution()\n    edges = [[0,1],[1,2],[1,3],[1,4]]\n    coins = [6,3,2,1]\n    k = 1\n    print(S.maximumPoints(edges, coins, k))/leetcode-cn/sword2offer/047.maxSumOfSubArray.py\n\"\"\"\n面试题47. 礼物的最大价值\n在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定", "groundtruth": "\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i) \n                    if j < 13: \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n"}
{"task_id": "python/33", "content": "\"\"\"\n\n# dfs\nfrom functools import cache\n\n\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = -0x3f3f3f\n            res2 = -0x3f3f3f\n            for ch in g[i]:\n                if ch!= fa:\n                    res1 += dfs(ch, j, i)\n                    res2 += dfs(ch, j + 1, i)\n            return max(res1 + coins[i], res2) if j < 13 else res1\n        return dfs(0, 0, -1)\n/algorithm/sort/969.py\nfrom functools import reduce\n\n\nclass Solution:\n    def pancakeSort(self, arr: List[int]) -> List[int]:\n        ans = []\n        idx = len(arr)\n        while idx > 0:\n            mx = -0x3f3f3f\n            id, = range(idx)\n            for i, a in enumerate(arr[id:]):\n                if a > mx:\n                    mx, id = a, i + id\n                    if i + id > idx - 1:\n                        break\n            if id > 0:\n                ans.append(id + 1)\n                arr[:id + 1] = reversed(arr[:id + 1])\n                ans.append(idx)\n                arr[:idx] = reversed(arr[:idx])\n            idx -= 1\n        return ans\n\n\nclass Solution:\n    def pancakeSort(self, arr: List[int]) -> List[int]:\n        ans = []\n        id, n = 0, len(arr)\n        tmp = arr[:]\n        for x in range(n, 0, -1):\n            for i in range(n):\n                if tmp[i] == x:\n                    id, i = i, i\n        f ans and ans[-1] >= x:\n                    ans.append(x)\n                    break\n                else:\n                    nxt = ans.index(nxt)\n                    ans = ans[:", "groundtruth": "\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i) \n                    if j < 13: \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n"}
{"task_id": "python/34", "content": "\n```py [sol1-Python3]\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch!= fa:\n                    res1 += dfs(ch, j + 1, i)\n                    if j < 13:\n                        res2 += dfs(ch, j + 1, i)\n            return max(res1, res2)\n\n        return dfs(0, 0, -1)\n```\n\n```java [sol1-Java]\nclass Solution {\n    public int maximumPoints(int[][] edges, int[] coins, int k) {\n        int N = coins.length;\n        List[] g = new ArrayList[N];\n        for (int i = 0; i < N; ++i) {\n            g[i] = new ArrayList();\n        }\n        for (int[] e : edges) {\n            g[e[0]].add(e[1]);\n            g[e[1]].add(e[0]);\n        }\n\n        int[] dp = new int[N];\n\n        Deque<Integer> q = new ArrayDeque();\n        q.offer(0);\n        while (!q.isEmpty()) {\n            int u = q.poll();\n            for (int v : g[u]) {\n                if (dp[v] == 0) {\n                    dp[v] = dp[u] + (coins[v] >> k);\n                    q.offer(v);\n                }\n            }\n        }\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < 13; ++j) {\n                if (coins[i] >= (1 << (j + 1)))\n                    dp[i] += (coins[i] >> (j + 1));\n            }\n        }\n        return dp[0];\n    }\n}\n```\n\n```cpp", "groundtruth": " class Solution:     def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:         g = [[] for _ in coins]         for x, y in edges:             g[x].append(y)             g[y].append(x)         @cache         def dfs(i: int, j: int, fa: int) -> int:             res1 = (coins[i] >> j) - k             res2 = coins[i] >> (j + 1)             for ch in g[i]:                 if ch != fa:                     res1 += dfs(ch, j, i)                      if j < 13:                          res2 += dfs(ch, j + 1, i)              return max(res1, res2)         return dfs(0, 0, -1) "}
{"task_id": "python/35", "content": "/Code/CodeRecords/2309/61135/296937.py\nn = int(input())\nnums = list(map(int, input().split(' ')))\nfor i in range(n):\n    nums[i] -= i + 1\nnums.sort()\nprint(nums)/Code/CodeRecords/2647/48117/271595.py\ndef findMinArrowShots(points):\n    if len(points) == 0:\n        return 0\n\n    # 按照第一个数排序，第一个数相同，第二个数也相同\n    points.sort()\n    #print(points)\n    result = 0\n    left = right = 0\n    minright = points[0][1]\n    for point in points:\n        left = point[0]\n        right = point[1]\n        if right <= minright:\n            result += 1\n            minright = min(minright, right)\n    return result\n\n\nx = input()\ny = input()\na = []\nl = len(y)\nfor i in range(int(x)):\n    temp = []\n    for j in range(int(l/2)):\n        temp.append(int(y[i * (int(l/2)) + j]))\n    a.append(temp)\nprint(findMinArrowShots(a))/Code/CodeRecords/2510/47961/287248.py\nstr_ = input()\nk = int(input())\nnums = list(map(int, str_[1: -1].split(\",\")))\n\nnum_map = {}\ncount = 0\nfor num in nums:\n    if num not in num_map:\n        num_map[num] = 1\n    else:\n        num_map[num] += 1\n    if num_map[num] > k:\n        count += 1\nprint(count)/Code/CodeRecords/2381/60719/248592.py\nnums=eval(input())\ncount=0\nfor i in range(len(nums)-1):\n    for j in range(i+1,len(nums)):\n        if abs(nums[i]-nums[j])", "groundtruth": " class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o * 2] + sum[o * 2 + 1]             return res         ans = s = 0         last = {}         for i, x in enumerate(nums, 1):             j = last.get(x, 0)             s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j             ans += s             last[x] = i         return ans % 1_000_000_007 "}
{"task_id": "python/36", "content": "\n思路：把数组中的元素视为数字编号，则这个序列就可以用 [L,R]表示。然后我们需要计算这个序列的和。\n\n那么首先来想一个通用模板：计算某个区间内数字的和。\n\ntemplate<typename T>\nT getSum(const vector<T> &vec, int left, int right)\n{\n    T result = 0;\n    for (int i = left; i <= right; ++i)\n    {\n        result += vec[i];\n    }\n    return result;\n}\n\n接着，如果我们可以设计这样一个树：用一个数组表示树，那么就可以存储这些数据。这样的树可以称为线段树。这个线段树存储的数据为 sum[1..n*4]，用来表示 [1,1] 到 [1,n]的和。\n\n模板：\n\nclass SegmentTree\n{\npublic:\n    vector<int> sum;\n    void build(int o, int l, int r)\n    {\n        sum[o] = 0;\n        if (l == r) return;\n        int m = (l + r) >> 1;\n        build(o * 2, l, m);\n        build(o * 2 + 1, m + 1, r);\n    }\n\n    void update(int o, int l, int r, int pos, int add)\n    {\n        sum[o] += add;\n        if (l == r) return;\n        int m = (l + r) >> 1;\n        if (pos <= m) update(o * 2, l, m, pos, add);\n        else update(o * 2 + 1, m + 1, r, pos, add);\n    }\n\n    void update(int o, int l, int r, int L, int R, int add)\n    {\n        if (L <= l && r <= R) return update(o, l, r, add);\n        int m = (l + r) >> 1;\n        update(o * 2, l, m, L, R, add);\n        update(o * 2 + 1, m + 1, r, L, R, add);\n    }\n\n    int query(int o, int l, int r, int L, int R)\n    {\n        if", "groundtruth": " class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o * 2] + sum[o * 2 + 1]             return res         ans = s = 0         last = {}         for i, x in enumerate(nums, 1):             j = last.get(x, 0)             s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j             ans += s             last[x] = i         return ans % 1_000_000_007 "}
{"task_id": "python/37", "content": "/biweekly/149/C.cpp\nclass Solution {\npublic:\n    int smallestEvenMultiple(int n) {\n        return n * (2 + n % 2);\n    }\n};\n/biweekly/62/C.cpp\nclass Solution {\npublic:\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\n        vector<vector<int>> ans(isWater);\n        int n = ans.size(), m = ans[0].size();\n        if (isWater[n - 1][m - 1] == 0) {\n            return ans;\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                ans[i][j] = isWater[i][j]!= 0? 0 : 1 << 30;\n            }\n        }\n        int dx[] = {0, 1, 0, -1};\n        int dy[] = {1, 0, -1, 0};\n        queue<pair<int, int>> que;\n        que.emplace(n - 1, m - 1);\n        ans[n - 1][m - 1] = 0;\n        while (que.size()) {\n            int i = que.front().first, j = que.front().second;\n            que.pop();\n            for (int k = 0; k < 4; ++k) {\n                int ii = i + dx[k], jj = j + dy[k];\n                if (ii >= 0 && ii < n && jj >= 0 && jj < m) {\n                    if (ans[ii][jj] > ans[i][j] + 1) {\n                        ans[ii][jj] = ans[i][j] + 1;\n                        que.emplace(ii, jj);\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};\n/contest/3/376/D.cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n", "groundtruth": " class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o * 2] + sum[o * 2 + 1]             return res         ans = s = 0         last = {}         for i, x in enumerate(nums, 1):             j = last.get(x, 0)             s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j             ans += s             last[x] = i         return ans % 1_000_000_007 "}
{"task_id": "python/38", "content": "Input Description\nA binary string, a string\nOutput Description\nThe minimum number of changes required\nExamples\nSample Input\ns = \"0100\"\nSample Output\n2 \n*/\n\n/*\nGiven an array of numbers, find the length of longest subarray where the sum of numbers is zero.\nInput  : arr[] = {-3, 2, 3, 1, 6}\nOutput : Length of the longest subarray is 2\nExplanation :\nThe longest subarray with sum 0 is {-3, 2} or {2, 3}.\nInput  : arr[] = {1, -3, -2, 3, -4}\nOutput : Length of the longest subarray is 1\nExplanation :\nThe longest subarray with sum 0 is {1}\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int n;\n    cout << \"Enter the size of array\\n\";\n    cin >> n;\n    int *arr = new int[n];\n    cout << \"Enter the elements of array\\n\";\n    for (int i = 0; i < n; i++)\n    {\n        cin >> arr[i];\n    }\n\n    unordered_map<int, int> map;\n    map[0] = -1;\n    int sum = 0;\n    int ans = 0;\n\n    for (int i = 0; i < n; i++)\n    {\n        sum += arr[i];\n        if (map.find(sum)!= map.end())\n        {\n            ans = max(ans, i - map[sum]);\n        }\n        else\n        {\n            map[sum] = i;\n        }\n    }\n\n    if (ans == 0)\n    {\n        cout << \"No subarray with sum is 0 exists\" << endl;\n    }\n    else\n    {\n        cout << \"Length of longest subarray with sum is 0 is \" << ans << endl;\n    }\n\n    return 0;\n}\n/*\nYour task is to complete the function maxLen() which takes the array arr[] as input and return the maximum length of a subsequence such that elements in the subsequence are in strictly increasing order.\nNote: You need to return the length of longest subsequence only and not the subsequence itself.\nInput:\nFirst line consists of a", "groundtruth": " class Solution:     def minChanges(self, s: str) -> int:         cnt = 0         for i in range(0, len(s), 2):             if len(set(s[i:i + 2])) > 1:                 cnt += 1                 print(s)         return cnt "}
{"task_id": "python/39", "content": "In the code, the function lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int is a function. nums is the parameter nums in the function. If a list called nums is passed as a parameter to the function, then this function assigns the list nums to a local variable called nums. target is the parameter target in the function. If a list called target is passed as a parameter to the function, then this function assigns the list target to a local variable called target. Note that nums and target cannot be used as the name of a parameter or a local variable in the function.\nNote that f is a local variable.\n\nThe complete code should be as follows.\n\nclass Solution:\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        f = [0] + [-inf] * target\n        s = 0\n        for x in nums:\n            s = max(s, x)\n            for j in range(s, x - 1, -1):\n                if f[j] < f[j - x] + 1:\n                    f[j] = f[j - x] + 1\n        return f[-1] if f[-1] > 0 else -1\n\n'''\n\n\nclass Solution:\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        f = [0] + [-float('inf')] * target\n        s = 0\n        for x in nums:\n            s = max(s, x)\n            for j in range(s, x - 1, -1):\n                if f[j] < f[j - x] + 1:\n                    f[j] = f[j - x] + 1\n        return f[-1] if f[-1] > 0 else -1\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    assert solution.lengthOfLongestSubsequence([0, 0, 0, 0, 1], 1) == 2\n    assert solution.lengthOfLongestSubsequence([0, 0, 0, 0, 1], 0) == 5\n    assert solution.lengthOfLongestSubsequence([4, 2, 2, 2, 4], 6) == 2\n   ", "groundtruth": " class Solution:     def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:         f = [0] + [-inf] * target         s = 0         for x in nums:             s = min(s + x, target)             for j in range(s, x - 1, -1):                 # f[j] = max(f[j], f[j - x] + 1)                 if f[j] < f[j - x] + 1:                     f[j] = f[j - x] + 1         return f[-1] if f[-1] > 0 else -1 "}
{"task_id": "python/40", "content": "\n# -\n\nfrom collections import Counter\nh = Counter(hFences)\nv = Counter(vFences)\nmax(h&v, default=0)\n\n# +\nh = Counter(hFences)\nv = Counter(vFences)\n\nm1 = max(h&v, default=0)\nm2 = min(m - 1, n - 1)\nreturn -1 if m1 > m2 else m2**2\n\n\n# +\nclass Solution:     def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:         h = Counter(hFences)         v = Counter(vFences)         m1 = max(h&v, default=0)         m2 = min(m - 1, n - 1)         return -1 if m1 > m2 else m2**2\n\n# -\n\n\n", "groundtruth": " class Solution:     def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:         h = self.f(hFences, m)         v = self.f(vFences, n)         ans = max(h & v, default=0)         return ans ** 2 % 1_000_000_007 if ans else -1      def f(self, a: List[int], mx: int) -> Set[int]:         a.extend([1, mx])         a.sort()         return set(y - x for x, y in combinations(a, 2)) "}
{"task_id": "python/41", "content": "\"\"\"\n\nclass Solution:\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n        h = self.f(hFences, m)\n        v = self.f(vFences, n)\n        ans = max(h) * max(v)\n        return ans % 1_000_000_007 if ans else -1\n    def f(self, a: List[int], mx: int) -> Set[int]:\n        a.extend([1, mx])\n        a.sort()\n        ans = {1}\n        for i, x in enumerate(a):\n            if i > 0:\n                ans |= {x - a[i - 1]}\n        return ans/面试题 08.02. 迷路的机器人/readme.txt\n在一块 N x N 的土地上，每个单元格内可能有一台机器人，也可能没有。\n\n机器人 最初位于左上角 (0, 0)，地图上存在 N x N 个单元格，机器人的范围在这个范围内。假设机器人只能接收从纸上阅读的指令命令，并且要想机器人成功执行命令，机器人必须先返回到原点。\n\n机器人命令可以有三个字符：'H'，意思是向右移动两个单位，'V'，意思是向下移动两个单位，'!'，意思是返回原点（重置机器人）。\n\n机器人成功执行指令命令返回原点的条件是机器人所在单元格的坐标为 (0, 0) 并且指令列表编号为 validLists.length - 1 的命令为 '!'。请找出是否存在一个指令列表，使得机器人能够返回原点？如果存在这样的指令列表，请返回任意一个可行的指令列表。如果没有，请返回一个空列表。\n\n示例 1:\n\n输入: N = 2, validLists = ['HVHVHVHVHVHVHV']\n输出: \"HHVHHHH!H\"\n示例 2:\n\n输入: N = 3, validLists = [\"HHHVHV\", \"HH!H!VHV\"]\n输出: \"", "groundtruth": " class Solution:     def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:         h = self.f(hFences, m)         v = self.f(vFences, n)         ans = max(h & v, default=0)         return ans ** 2 % 1_000_000_007 if ans else -1      def f(self, a: List[int], mx: int) -> Set[int]:         a.extend([1, mx])         a.sort()         return set(y - x for x, y in combinations(a, 2)) "}
{"task_id": "python/42", "content": "The main() function has been completed and has been placed in the incorrect position, and the function main() is the function to be completed. It is as follows:\n int main() {     string source, target;     vector<string> original, changed;     vector<int> cost;     __________________         __________________         __________________         __________________         __________________     while (cin >> source >> target) {         __________________         __________________         __________________         __________________         __________________     }     return 0; }\n\n### 样例输入\n\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    string source, target;\n    vector<string> original, changed;\n    vector<int> cost;\n    cin >> source >> target;\n    while (cin >> source >> target) {\n        for (int i = 0; i < source.length(); i++) {\n            original.push_back(\"\");\n            changed.push_back(\"\");\n            cost.push_back(0);\n        }\n        int dis[26][26];\n        for (int i = 0; i < 26; i++)\n            for (int j = 0; j < 26; j++)\n                dis[i][j] = (i == j? 0 : (i > j? 100000 : 100001));\n        for (int i = 0; i < source.length(); i++)\n            cin >> original[i] >> changed[i] >> cost[i];\n        for (int x = 0; x < 26; x++)\n            for (int y = 0; y < 26; y++)\n                for (int z = 0; z < 26; z++)\n                    dis[x][y] = min(dis[x][y], dis[x][z] + dis[z][y]);\n        int ans = 0;\n        for (int i = 0; i < source.length(); i++)\n            ans += dis[source[i] - 'a'][target[i] - 'a'];\n        if (ans >= 100000)\n            cout << -1 << '\\n';\n        else\n            cout << ans << '\\n';\n    }\n    return 0;\n}\n\n\n### 样例输出\n\n\naabab", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)          for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))         return ans if ans < inf else -1 "}
{"task_id": "python/43", "content": "\n*/\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minimumCost(string source, string target, vector<string>& original, vector<string>& changed, vector<int>& cost) {\n        vector<vector<int>> dis(26, vector<int>(26, 1e5));\n        for (int i = 0; i < 26; i++) {\n            dis[i][i] = 0;\n        }\n        for (int i = 0; i < 26; i++) {\n            for (int j = 0; j < 26; j++) {\n                for (int k = 0; k < cost.size(); k++) {\n                    if (cost[k] == dis[i][j] && original[k][0] == char(i + 'a') && changed[k][0] == char(j + 'a')) {\n                        dis[i][j] = dis[j][i] = cost[k];\n                    }\n                }\n            }\n        }\n        for (int k = 0; k < 26; k++) {\n            for (int i = 0; i < 26; i++) {\n                for (int j = 0; j < 26; j++) {\n                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n                    dis[j][i] = min(dis[j][i], dis[j][k] + dis[k][i]);\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < source.length(); i++) {\n            ans += dis[source[i] - 'a'][target[i] - 'a'];\n        }\n        return ans;\n    }\n};\n\n\nint main() {\n\n    cout << \"Hello, World!\" << endl;\n    return 0;\n}\n(int i = 0; i < 10; i++) {\n        cout << numbers[i] << \",\";\n    }\n    cout << endl;\n\n    return 0;\n}\n/*\n * 1054. Distant Barcodes\n *\n * QUESTION:\n *", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)          for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))         return ans if ans < inf else -1 "}
{"task_id": "python/44", "content": "\n'''\n\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        \n        dis = [[float('inf') for _ in range(26)] for _ in range(26)]\n        for i in range(26):\n            dis[i][i] = 0\n        \n        for x, y, c in zip(original, changed, cost):\n            x = ord(x) - ord('a')\n            y = ord(y) - ord('a')\n            dis[x][y] = min(dis[x][y], c)\n            \n        for k in range(26):\n            for i in range(26):\n                for j in range(26):\n                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n    \n        ans = 0\n        for x, y in zip(source, target):\n            ans += dis[ord(x) - ord('a')][ord(y) - ord('a')]\n            \n        return ans if ans < float('inf') else -1\n\n/1057. Campus Bikes.py\n'''\nOn a campus represented as a 2D grid, there are N workers and M bikes, with N <= M. Each worker and bike is a 2D coordinate on this grid.\nOur goal is to assign a bike to each worker. Among the available bikes and workers, we choose the (worker, bike) pair with the shortest Manhattan distance between each other, and assign the bike to that worker. (If there are multiple (worker, bike) pairs with the same shortest Manhattan distance, we choose the pair with the smallest worker index; if there are multiple ways to do that, we choose the pair with the smallest bike index). We repeat this process until there are no available workers.\nThe Manhattan distance between two points p1 and p2 is Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|.\nReturn a vector ans of length N, where ans[i] is the index (0-indexed) of the bike that the i-th worker is", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)         for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))         return ans if ans < inf else -1 "}
{"task_id": "python/45", "content": "\n# Solution: LCA\n\nWe can use a DP to calculate the minimum cost from source to current character in target. For two characters a and b, let dp(a, b) be the minimum cost to change a into b and we can use an array cost(len(original)) to store the cost of converting characters in original.\n\nFor source[0], the DP equation is dp(source[0], target[0]) = cost[0], since we can only change it to target[0].\n\nFor source[i], we iterate each length j from 0 to i, let k be i – j, then there are two conditions for choosing it:\n\ndp(source[k], source[k]) + dp(source[k + j], source[k + j]) == cost[k + j]\ntarget[i] == source[k + j]\n\nThe equation is dp(source[i], target[i]) = dp(source[k], target[k]) + cost[k + j].\n\nIn order to speed up the query, we can sort all strings of length j with costs j and construct a LCA array in O(n log(n)).\n\n# Solution 1: LCA\n\nclass Solution:\ndef minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\nans = float('inf')\n# Construct a LCA tree\nlen_to_strs = defaultdict(set)\nfor x, y, c in zip(original, changed, cost):\nlen_to_strs[len(x)].add(x)\nlen_to_strs[len(y)].add(y)\n\nm = len(source)\nn = len(target)\n\ndef get_cost(i, j):\nif i >= m or j >= n:\nreturn 0\nif source[i] == target[j]:\nreturn get_cost(i + 1, j + 1)\nreturn min(cost[i] + get_cost(i + 1, j), cost[j] + get_cost(i, j + 1))\n\nans = min(ans, get_cost(0, 0))\nreturn -1 if ans == float('inf') else ans", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = min(dis[x][y], c)             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                      continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 "}
{"task_id": "python/46", "content": "The time and space complexity of the code are O(n3), where n is the length of strings source and target./1803. Count Pairs With XOR in a Range.py\nYou are given an array nums consisting of non-negative integers. You are also given a queries array, where queries[i] = [li, ri], which represents the list of numbers with indices between li and ri (inclusive).\n\nThe bitwise XOR of a sequence of integers is its eleven-or of all integers in it.\n\nFor example, the bitwise XOR of range [3, 5] is 3 XOR 4 XOR 5 = 011 XOR 101 XOR 110 = 100.\nA pair of indices (i, j) is a good pair if nums[i] XOR nums[j] is equal to 0.\n\nReturn an array ans of size queries.length, where ans[i] is the answer to the ith query.\n\nclass Solution:\n    def countPairs(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        nums.sort()\n        c = collections.Counter(nums)\n        dp = [0]*len(nums)\n        for i in range(1, len(nums)):\n            dp[i] = dp[i-1] + c[nums[i]^nums[i-1]]\n            c[nums[i]] += c[nums[i]^nums[i-1]]\n        res = []\n        for l, r in queries:\n            r -= 1\n            res.append(dp[r] - dp[l-1])\n        return res\n/1671. Minimum Number of Removals to Make Mountain Array.cpp\nclass Solution {\npublic:\n    int minimumMountainRemovals(vector<int>& nums) {\n        vector<int> dp(nums.size(), 0), pos(nums.size(), 0);\n        int n = nums.size();\n        for(int i = 1; i < n; i++)\n        {\n            int j = i-1;\n            while(j >= 0 && nums[j] >= nums[j+1])\n                j = pos[j];\n            pos[i] = j;\n            dp[i] = dp[j] + 1", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = min(dis[x][y], c)             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                       continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 "}
{"task_id": "python/47", "content": "class Solution {\npublic:\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\n        for (auto & row : image) {\n            int l = 0;\n            int r = row.size() - 1;\n            while (l < r) {\n                swap(row[l], row[r]);\n                row[l] ^= 1;\n                row[r] ^= 1;\n                l++;\n                r--;\n            }\n            if (l == r) {\n                row[l] ^= 1;\n            }\n        }\n        return image;\n    }\n};\n/*\n * Copyright (c) 2019 altonshen ()\n *\n * This project was published under the MIT license.\n *\n */\n\n#include \"solution.h\"\n\nnamespace leetcode::p01300 {\n\nint findNumbers(vector<int> & nums) {\n    int res = 0;\n    for (int num : nums) {\n        int count = 0;\n        while (num > 0) {\n            num /= 10;\n            ++count;\n        }\n        if (count % 2 == 0) {\n            ++res;\n        }\n    }\n    return res;\n}\n\n} // namespace leetcode::p01300\n/*\n * Copyright (c) 2019 altonshen ()\n *\n * This project was published under the MIT license.\n *\n */\n\n#include \"solution.h\"\n\nnamespace leetcode::p0350 {\n\nvector<int> intersect(vector<int> & nums1, vector<int> & nums2) {\n    vector<int> res;\n    unordered_map<int, int> nums1_map;\n    unordered_map<int, int> nums2_map;\n    for (int num : nums1) {\n        ++nums1_map[num];\n    }\n    for (int num : nums2) {\n        ++nums2_map[num];\n    }\n    for (auto & pair : nums1_map) {\n        int num = pair.first;\n        int count = pair.second;\n        if (nums2_map.count(num)) {\n            int smaller_count = min(nums1_map[num], nums", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = min(dis[x][y], c)             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                       continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 "}
{"task_id": "python/48", "content": "The complete code is as follows:\n\nDIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n\n    def adjacentSum(self, value: int) -> int:\n        return sum(self.s[value][:4])\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n\n    def adjacentSum(self, value: int) -> int:\n        return sum(self.s[value][:4])\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy", "groundtruth": "\nDIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n  "}
{"task_id": "python/49", "content": "\nExample 1:\n\nInput\n[\"NeighborSum\", \"adjacentSum\", \"adjacentSum\", \"adjacentSum\", \"adjacentSum\", \"adjacentSum\", \"diagonalSum\", \"diagonalSum\", \"adjacentSum\", \"adjacentSum\", \"diagonalSum\", \"diagonalSum\"]\n[[[1, 2, 3], [2, 3, 4], [3, 4, 5]], 0, 1, 2, 3, 4, 0, 3, 1, 3, 3, 4, 4]\nOutput\n[null, 8, 2, 3, 5, 6, 6, 9, 3, 4, 7, 9]\n\nExplanation\nneighborSum grid = [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\nneighborSum obj = NeighborSum(grid)\nobj.adjacentSum(0) = 1 + 2 + 3 + 3 + 4 + 4 = 8 // sum of the elements which are adjacent neighbors of value = 0\nobj.adjacentSum(1) = 2 + 3 + 4 + 4 = 11 // sum of the elements which are adjacent neighbors of value = 1\nobj.adjacentSum(2) = 3 + 4 + 5 = 12 // sum of the elements which are adjacent neighbors of value = 2\nobj.adjacentSum(3) = 4 + 5 = 9 // sum of the elements which are adjacent neighbors of value = 3\nobj.adjacentSum(4) = 5 = 5 // sum of the elements which are adjacent neighbors of value = 4\nobj.diagonalSum(0) = 2 + 3 + 5 + 4 = 14 // sum of the elements which are diagonal neighbors of value = 0\nobj.diagonalSum(3) = 4 + 4 = 8 // sum of the elements which are diagonal neighbors of value = 3\nobj.adjacentSum(1) = 2 + 3 + 4 = 9 // sum of the elements which are adjacent neighbors of value = 1\nobj.adjacentSum(3) = 4 + 4 = 8 // sum of the elements which are adjacent neighbors of", "groundtruth": "\nDIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n  "}
{"task_id": "python/50", "content": "\"\"\"\n\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            dq = deque([i])\n            vis[i] = 0\n\n            while dq:\n                s = dq.popleft()\n                for t in g[s]:\n                    if vis[t - 1]!= -1:\n                        continue\n                    vis[t - 1] = vis[s] + 1\n                    dq.append(t)\n\n            return vis[-1]\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans/1351/count_negative_numbers_in_a_sorted_matrix.py\nclass Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        n, m = len(grid), len(grid[0])\n        return sum([i < 0 for row in grid for i in row])\n        return sum([len([1 for row in grid if i in row]) < n for i in range(m)])\n        return sum([sum([1 if i < 0 else 0 for i in row]) for row in grid])/0841/keys_and_rooms.py\n\"\"\"\nThere are N rooms and you start in room 0. Each room has a distinct number in 0, 1, 2,..., N - 1, and each room may have some keys to access the next room. \nFormally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1,..., N - 1] where N = rooms.length. A key rooms[i][j] = v opens the room with number v.\nInitially, all the rooms start locked (except for room 0). You can walk back and forth between rooms freely. Return true if and only if you can enter every room.\nExample 1:\nInput: [[1", "groundtruth": "\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n "}
{"task_id": "python/51", "content": "'''\n\n\n# 并查集\ndef find(x):\n    if fa[x]!= x:\n        fa[x] = find(fa[x])\n    return fa[x]\n\ndef union(x, y):\n    fa[find(x)] = find(y)\n\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        # 初始化并查集\n        fa = list(range(n - 1))\n        # 遍历查询\n        ans = [n - 1] * len(queries)\n        for i, (ui, vi) in enumerate(queries):\n            # 当前操作的起点到终点之间，原本路径的长度\n            cur = ans[i]\n            # 当前起点到终点之间，经过当前操作，新的路径长度\n            nxt = min(ui, vi)\n            # 如果起点和终点在同一区域，则不更新\n            if find(ui) == find(vi):\n                ans[i + 1] = min(ans[i + 1], cur)\n            # 否则，更新起点到终点之间路径的长度\n            else:\n                ans[i + 1] = min(ans[i + 1], cur + nxt + 1)\n                # 合并起点和终点，路径的长度增加\n                union(ui, vi)\n\n        return ans\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"\nleetcode 860. 柠檬水找零\n中文English\n在柠檬水摊上，每一杯柠檬水的售价为 5 美元。\n顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。\n每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。\n注意，一开始你手头没有任何零钱。\n如果你能给每位顾客正确找零，返回 true ，否则返回", "groundtruth": "\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/52", "content": "The function signature and the input data format are determined according to the actual running environment. The function should return an array answer.\nPlease note the input data format is an array of arrays, not a single array.\n'''\n\ndef numberOfAlternatingGroups(a, queries):\n    return None\n\n\na = [2,3,1,4,5]\nqueries = [[1,2],[2,0],[1,1],[1,1],[1,3],[2,1],[1,4],[1,5]]\n#print(numberOfAlternatingGroups(a, queries))\n# Expected Output: [2,1,2,1,2]\n\n'''\n200. Number of Islands\n\nGiven a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\nExample 1:\nInput:\n11110\n11010\n11000\n00000\nOutput: 1\n\nExample 2:\nInput:\n11000\n11000\n00100\n00011\nOutput: 3\n'''\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        def numIslands(grid, i, j, rows, cols):\n            if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] == \"0\":\n                return\n            else:\n                grid[i][j] = \"0\"\n\n            if i > 0:\n                numIslands(grid, i - 1, j, rows, cols)\n            if i < rows - 1:\n                numIslands(grid, i + 1, j, rows, cols)\n            if j > 0:\n                numIslands(grid, i, j - 1, rows, cols)\n            if j < cols - 1:\n                numIslands(grid, i, j + 1, rows, cols)\n\n        if len(grid) == 0:\n            return 0\n\n        rows = len(grid)\n        cols = len(", "groundtruth": "\nfrom sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/53", "content": "\nExample 1:\nInput: colors = [1,0,1,0], queries = [[1,3],[2,2],[0,1],[1,1]]\nOutput: [2,3,0,1]\nExplanation: queries[0]: The group [0,1,0] has alternating colors and has 2 alternating groups.\nqueries[1]: The group [1,1,0,0] has alternating colors and has 3 alternating groups.\nqueries[2]: The group [0,1] has alternating colors and has 0 alternating groups.\nqueries[3]: The group [1,1] has alternating colors and has 1 alternating groups.\nExample 2:\nInput: colors = [0,0], queries = [[0,0],[0,1]]\nOutput: [1,0]\nExplanation: queries[0]: The group [0] has alternating colors and has 1 alternating groups.\nqueries[1]: The group [0,0] has alternating colors and has 0 alternating groups.\n'''and 4 more\nclass FenwickTree:\n    def __init__(self, maxn):\n        self.fen = [0]*maxn+1\n\n    def update(self, pos, val):\n        pos+=1\n        while pos<len(self.fen):\n            self.fen[pos] += val\n            pos += pos&-pos\n\n    def query(self, pos):\n        ans = 0\n        pos+=1\n        while pos>0:\n            ans += self.fen[pos]\n            pos &= pos-1\n        return ans\n\n    def build(self, a):\n        n = len(a)\n        for i,e in enumerate(a):\n            if e:\n                self.update(i,1)\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        tree = FenwickTree(2e5)\n        tree.build(a)\n        ans = []\n        for i,e in enumerate(a):\n            if not i:\n                tmp = tree.query(len(a))\n                ans.append(tmp)\n            else:\n                tmp = tree.query(i)\n                ans.append(tmp)\n\n        for q in queries:\n            if q[0]==2:\n               ", "groundtruth": "\nfrom sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/54", "content": "\nThe running time should not be more than 60 ms. The time complexity should not be more than O(n).\n\nTips: You can write only one additional variable to complete the solution.\n\nYou can use the following function to solve this problem.\n\nclass Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        return Solution()____\n\nExample:\nInput: nums = [1, 2, 3, 4, 5]\nOutput: true\nExplanation: Alice can choose the number 3 because 3 == 3, so Alice wins.\n\nInput: nums = [1, 2, 20, 40]\nOutput: false\nExplanation: Bob will win this game, because Alice chose the numbers 1, 2, 20, and 40. This makes the sum of her numbers 1 + 2 + 20 + 40 = 67, which is not strictly greater than Bob's numbers 20 and 40.\n\nInput: nums = [3, 7, 2, 3]\nOutput: true\nExplanation: Alice can choose the number 7 because 7 == 7, so Alice wins.class Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        return Solution()._canWin(nums)\n    \n    def _canWin(self,nums):\n        memo = set()\n        return self._helper(nums,0,memo)\n    \n    def _helper(self,nums,start,memo):\n        if start >= len(nums):\n            return False\n        elif tuple(nums[start:]) in memo:\n            return False\n        memo.add(tuple(nums[start:]))\n        return any(not self._helper(nums,i+1,memo) for i in range(start,len(nums)) if i+1<len(nums) and (nums[i]>10 or nums[i+1]>10)) or self._helper(nums,start+1,memo)\n    \n    ", "groundtruth": "\nclass Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        single=0\ndouble=0\nfor it in nums:\nif it>=10: \ndouble=double+it \nelse:\nsingle=single+it  \n        \nreturn single !=double\n "}
{"task_id": "python/55", "content": "Please submit your homework in the corresponding problem.\nSubmission:\n1. Click the \"Submit\" button to submit the corresponding problem.\n2. If you have more than one file, please compress them and upload them at the same time.\n3. If you submit in the web, please provide the number of your submission for us to track your submissions\n\nYour homework will be graded according to the specifications above. For any homework-related questions, please contact \n\nSubmission Guidelines\n1. Each problem must submit the completed code in a single python file.\n2. Submit in the form of a python file: ProblemN_HWN.py. For example, Problem1_HW2.py\n\nProblem Description (3):\nGiven a sequence of integers with different signs, please find out the maximum product generated by three of them.\n\nHere is a more clear description of the above problem:\n\nFor example,\n\nGiven sequence = [ 1, 5, 6, 7, 8, -1, -3, -2, -5, 4, 0 ], The maximum product will be 232:\nThe maximum product = 6 * 7 * 8 = 232\n\nYou can assume the length of the given sequence will not exceed 10000 and each element will not exceed 32-bit signed integer.\n\nPlease fill in the following incomplete code according to the description. The description is as follows:\n\nPlease complete the problem with one for loop.\nPlease submit your homework in the corresponding problem.\nSubmission:\n1. Click the \"Submit\" button to submit the corresponding problem.\n2. If you have more than one file, please compress them and upload them at the same time.\n3. If you submit in the web, please provide the number of your submission for us to track your submissions\n\nYour homework will be graded according to the specifications above. For any homework-related questions, please contact \n\nSubmission Guidelines\n1. Each problem must submit the completed code in a single python file.\n2. Submit in the form of a python file: ProblemN_HWN.py. For example, Problem1_HW2.py\n\nProblem Description (4):\nGiven an unsorted array of integers, find the length of the longest consecutive elements sequence.\n\nPlease fill", "groundtruth": "\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n    "}
{"task_id": "python/56", "content": "Constraints:\n1 <= X, Y <= 1000\n1 <= circles.length <= 100\ncircles[i].length == 3\n1 <= xCorner, yCorner <= X\n1 <= xi, yi <= X\n1 <= ri <= min(X, Y)\nAll the coordinates of the circles are unique.\n\"\"\"\n\nfrom typing import List\nfrom functools import reduce\n\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        '''\n            @desc: \n                判断点 (x,y) 是否在圆 (ox,oy,r) 内\n            @param {type} int\n            @param {type} int\n            @param {type} int\n            @param {type} int\n            @param {type} int\n            @return: bool\n            @other: None\n        '''\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        def dfs(i: int) -> bool:\n            '''\n                @desc: \n                    从圆 i 出发寻找目标\n                    判断是否能从圆 i 出发到达目标 (X,Y)\n                @return: bool\n            '''\n            # 圆 i 包含矩形左下角\n            if in_circle(x, y, r, 0, 0):\n                return True\n            \n            # 圆 i 包含矩形右上角\n            if in_circle(x, y, r, X, Y):\n                return True\n            \n            # 圆 i 与矩形上边界/左边界相交相切\n            elif (x <= X and abs(y - Y) <= r) or (y <= Y and x <= r) or (y > Y and in_circle(x, y, r, 0, Y)):\n                return True\n            else:\n                return False\n\n        # 判断每一个圆\n        for i, (x, y, r) in enumerate(circles):\n            vis[i] = not dfs(i)\n        \n        return reduce(lambda x,y: x or y, vis)\n        \"\"\"\n42. Trapping Rain Water\nMedium\n\nGiven n", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and \\\n                   (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or \\\n               in_circle(x, y, r, X, Y) or \\\n               not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/57", "content": "'''\n\nfrom typing import List\n\n\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        if circles[0][0] + circles[0][2] <= X or circles[0][1] + circles[0][2] <= Y:\n            return False\n        if circles[1][0] >= X or circles[1][1] >= Y:\n            return False\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            if vis[i]:\n                return False\n            vis[i] = True\n            if circles[i][0] + circles[i][2] > X and circles[i][1] + circles[i][2] > Y:\n                return True\n            x = circles[i][0]\n            y = circles[i][1]\n            r = circles[i][2]\n            for j in range(len(circles)):\n                if in_circle(x, y, r, circles[j][0], circles[j][1]) and in_circle(circles[j][0], circles[j][1], circles[j][2], x, y):\n                    return False\n                if in_circle(x, y, r, circles[j][0], circles[j][1]) and dfs(j):\n                    return True\n            vis[i] = False\n            return False\n        return dfs(0)/00240.search-a-2d-matrix-ii/Solution.java\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if (matrix.length == 0 || matrix[0].length == 0) return false;\n        int row = 0, col = matrix[0].length - 1;\n        while (row < matrix.length && col >= 0) {\n            if (matrix[row][col] == target) return true;\n            if (matrix[row][col] > target) {\n                col--;\n            } else {\n                row++;\n            }\n        }\n        return false;\n    }\n}\n/00038.count-and-say/Solution.java\n/*\n * @lc app=leetcode.cn id=38 lang=java\n *\n * [38] 外观数列\n */", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and \\\n                   (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or \\\n               in_circle(x, y, r, X, Y) or \\\n               not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/58", "content": "\nThe incomplete code is as follows:\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n\n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        \n        visited = [False] * n\n        count = self.dfs(graph, 0, visited)\n        \n        if count == n:\n            return 0\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        visited[start] = True\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                self.dfs(graph, neighbor, visited)\n        return len([True for i in visited if i])\n\n\n'''\n/interview/1501-2000/1930_Unique_Length-3_Palindromic_Subsequences.py\n'''\n\nGiven a string s, return the number of unique palindromic subsequences of a length three that can be formed from it. Since the answer can be very large, return it modulo 10^9 + 7.\n\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\nA palindrome is a string that reads the same backward as forward.\n\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\n \n\nExample 1:\n\nInput: s = \"abb\"\nOutput: 1\nExplanation: The 2 subsequences are \"a\", and \"ab\". The palindromes are \"\".\n\nExample 2:\n\nInput: s = \"aaa\"\nOutput: 6\nExplanation: The 6 palindromes are \"a\", \"a\", \"a\", \"aa\", \"aa\", and \"aaa\".\n \n\nConstraints:\n\n1 <= s.length <= 1000\ns consists of lowercase English letters.\n\n'''\n\nfrom collections import defaultdict\nclass Solution:\n    def countPalindromicSubsequence(self, s: str) -> int:\n        # Time Complexity： O(n^2)\n        # Space Complex", "groundtruth": "class Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/59", "content": "class Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        graph = [[] for _ in range(n)]\n        for start, end in edges:\n            graph[start].append(end)\n        visited = [False for _ in range(n)]\n\n        def dfs(graph, start, visited):\n            visited[start] = True\n            for end in graph[start]:\n                if visited[end]:\n                    continue\n                dfs(graph, end, visited)\n\n        for i in range(n):\n            if not visited[i]:\n                dfs(graph, i, visited)\n\n        for i in range(n):\n            if not visited[i]:\n                return i\n        return -1\n'''\n\ndef findChampion(n, edges):\n    graph = [[] for _ in range(n)]\n    for start, end in edges:\n        graph[start].append(end)\n\n    visited = [False for _ in range(n)]\n    def dfs(graph, start, visited):\n        visited[start] = True\n        for end in graph[start]:\n            if visited[end]:\n                continue\n            dfs(graph, end, visited)\n    for i in range(n):\n        if not visited[i]:\n            dfs(graph, i, visited)\n    for i in range(n):\n        if not visited[i]:\n            return i\n    return -1\n\n\nn = 5\nedges = [[0,1],[1,2],[2,3],[3,4]]\nres = findChampion(n, edges)\n\nprint(res)\n# coding=utf-8\n\n'''\n1110. Delete Nodes And Return Forest\nMedium\n\n875\n\n33\n\nFavorite\n\nShare\nYou are given the root of a binary tree and an integer mini.\n\nDelete every node in the tree that has a value not equal to mini.\n\nReturn the root of the new binary tree.\n\nThe binary tree is given by root.\n\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution(object):\n    def delNodes(self, root, minis):\n        \"\"\"\n        :type root: TreeNode\n        :type minis: List[int]", "groundtruth": "class Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/60", "content": "\"\"\"\n\nclass Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            visited = set()\n            ans = 0\n            def dfs(u, p = -1):\n                if u in visited:\n                    return 0\n                if nums[u] > 0:\n                    ans += nums[u]\n                    nums[u] = 0\n                visited.add(u)\n                for v in path[u]:\n                    if v!= p:\n                        dfs(v, u)\n            dfs(u)\n            return ans\n\n        return dfs(0)[1]\n/LeetCode/Problems/Algorithms/#150_EvaluateReversePolishNotation_sol1_recursion_88ms_52.5mb.py\nclass Solution:\r\n    def evalRPN(self, tokens: List[str]) -> int:\r\n        ops = {\r\n            '+': (lambda a, b: a + b),\r\n            '-': (lambda a, b: a - b),\r\n            '*': (lambda a, b: a * b),\r\n            '/': (lambda a, b: -(-a // b))\r\n        }\r\n        \r\n        def op(a, b):\r\n            for char, f in ops.items():\r\n                if char in a:\r\n                    return f(a, b)\r\n            return int(a)\r\n        \r\n        def evaluate(token, i):\r\n            if i == 0:\r\n                return int(token)\r\n            if token in ops:\r\n                return op(evaluate(tokens[i - 2], i - 2), evaluate(tokens[i - 1], i - 1))\r\n            else:\r\n                return evaluate(token, i - 1)\r\n        \r\n        return evaluate(tokens[-1], len(tokens) - 1)/LeetCode/Problems/Algorithms/#150_EvaluateReversePolishNotation_sol4_stack_96ms_52.3mb.py\nclass Solution:\r\n    def evalRPN(self, tokens: List[str]) -> int:\r\n        def op(a, b):\r\n            # a and b are not necessarily integers\r\n            a = int(a)", "groundtruth": "class Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v != p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp1 + nums[u], dp0)\n            \n        return dfs(0)[1]\n"}
{"task_id": "python/61", "content": "'''\nimport sys\nimport math\nimport heapq\nimport bisect\nfrom typing import List\nimport collections\nfrom functools import lru_cache\n\nclass Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], values: List[int]) -> int:\n        res = [0]\n        seen = set()\n        maxScore = 0\n        for _ in range(len(edges) * 2):\n            seen.clear()\n            queue = []\n            for i, v in enumerate(values):\n                if v > 0:\n                    maxScore = max(maxScore, v)\n                    heapq.heappush(queue, (-v, i))\n                seen.add(i)\n            for i, v in queue:\n                values[v] = 0\n                i = -i\n                if v not in seen and 0 not in seen:\n                    seen.add(v)\n                    maxScore += i\n        res[0] = maxScore\n        return res[0]\n\n\nsol = Solution()\nprint(sol.maximumScoreAfterOperations([[0,1],[0,2]], [1,2,4]))\nprint(sol.maximumScoreAfterOperations([[0,2],[2,1]], [2,4,-2]))\n/leetcode/python/1392_longest_happy_prefix.py\n'''\nA string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself).\n\nGiven a string s, return the longest happy prefix of s. Return an empty string if no such prefix exists.\n\nExample 1:\nInput: s = \"level\"\nOutput: \"l\"\nExplanation: s contains 4 prefix excluding itself (\"l\", \"le\", \"lev\", \"leve\"), and suffix (\"l\", \"el\", \"vel\", \"evel\"). The largest prefix which is also suffix is given by \"l\".\n\nExample 2:\nInput: s = \"ababab\"\nOutput: \"abab\"\nExplanation: \"abab\" is the largest prefix which is also suffix. They can overlap in the original string.\n\nExample 3:\nInput: s = \"leetcodeleet\"\nOutput: \"leet\"\n\nExample 4:\nInput: s = \"a\"\nOutput: \"\"\n\nConstraints:\n1 <= s.length <= 105\ns contains only", "groundtruth": "class Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v != p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp1 + nums[u], dp0)\n            \n        return dfs(0)[1]\n"}
{"task_id": "python/62", "content": "\n*/\n\npackage main\n\nimport (\n\t. \"fmt\"\n)\n\nfunc lengthOfLongestSubstringKDistinct(s string, k int) int {\n\n\tres := 0\n\tmapInt := make(map[byte]int)\n\ti, j := 0, 0\n\n\tfor i < len(s) {\n\n\t\tif _, ok := mapInt[s[i]];!ok {\n\t\t\tif len(mapInt) == k {\n\t\t\t\tdelete(mapInt, s[j])\n\t\t\t\tj++\n\t\t\t} else {\n\t\t\t\tmapInt[s[i]]++\n\t\t\t\tres = max(res, i-j+1)\n\t\t\t}\n\t\t} else {\n\t\t\tres = max(res, i-j+1)\n\t\t}\n\t\ti++\n\t}\n\treturn res\n}\n\nfunc max(i, j int) int {\n\tif i > j {\n\t\treturn i\n\t}\n\treturn j\n}\n\nfunc main() {\n\n\tprintln(lengthOfLongestSubstringKDistinct(\"eceba\", 3))\n}\nclass Solution:\n    def countSubstrings(self, s: str, t: str) -> int:\n\n        def check(ss, tt):\n            l, r = len(ss), len(tt)\n            if l > r:\n                return False\n            for i in range(l):\n                if ss[l-i-1]!= tt[r-i-1]:\n                    return False\n            return True\n\n        ans = 0\n        l = 0\n        r = 0\n        j = 0\n        while l < len(s) and r < len(t):\n            if s[l]!= t[r]:\n                l = j+1\n                r = j\n                j += 1\n            else:\n                j += 1\n          ans\n  while r < len(t) and t[r] == s[l]:\n                r += 1\n            ans += r-l\n\n        return /*\n\nhttps://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/\n\nYou are given an array of positive integers nums and an integer threshold.\nYou have to find the smallest positive integer divisible by all the elements of nums.\n\nFor example, given nums = [3,", "groundtruth": "class Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/63", "content": "Example 1:\nInput: nums = [1,2,3,4], k = 3\nOutput: 11\nExplanation:\nnums | = 11\nNote that all zeros are included in the result.\nExample 2:\nInput: nums = [1,2,3,4,5,6], k = 6\nOutput: 63\nExample 3:\nInput: nums = [2,4,6], k = 3\nOutput: 6\nExample 4:\nInput: nums = [12,3,4,5], k = 1\nOutput: 31\n'''\n\n\nclass Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        return reduce(lambda x,y:x|y,map(lambda z:1<<z,range(32)))&reduce(lambda x,y:x|(y<<x),nums)\n/力扣刷题/191. 位1的个数.py\n'''\n请编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。\n\n \n\n示例 1：\n\n输入：00000000000000000000000000001011\n输出：3\n解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。\n示例 2：\n\n输入：00000000000000000000000010000000\n输出：1\n解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。\n示例 3：\n\n输入：11111111111111111111111111111101\n输出：31\n", "groundtruth": "class Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for i in range(max(nums).bit_length()):\n            cnt1 = sum(x >> i & 1 for x in nums)\n            if cnt1 >= k:\n                ans |= 1 << i\n        return ans\n"}
{"task_id": "python/64", "content": "\"\"\"\n\n\nclass Solution:\n    def minSum(self, nums1, nums2):\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zeros1 = sum(1 for num in nums1 if num == 0)\n        zeros2 = sum(1 for num in nums2 if num == 0)\n        if sum1 == sum2:\n            return sum1 + zeros1\n        if zeros1 == 0 or zeros2 == 0:\n            return -1\n        if sum1 > sum2:\n            return self._min_sum_diff_1(nums1, zeros2, sum1 - sum2)\n        else:\n            return self._min_sum_diff_2(nums2, zeros1, sum2 - sum1)\n\n    def _min_sum_diff_1(self, nums1, zeros2, diff):\n        res = 0\n        for i, num in enumerate(nums1):\n            if num == 0:\n                nums1[i] = diff\n                diff -= 1\n                res += 1\n                zeros2 -= 1\n                if diff < 0:\n                    return -1\n                continue\n            if diff < 0:\n                return -1\n        if zeros2 < 0:\n            return -1\n        res += diff\n        for i, num in enumerate(nums1):\n            if num!= 0:\n                nums1[i] = 1\n        for i in range(zeros2):\n            nums2[i] = 0\n        return res\n\n    def _min_sum_diff_2(self, nums2, zeros1, diff):\n        res = 0\n        for i, num in enumerate(nums2):\n            if num == 0:\n                nums2[i] = diff\n                diff -= 1\n                res += 1\n                zeros1 -= 1\n                if diff < 0:\n                    return -1\n                continue\n            if diff < 0:\n                return -1\n        if zeros1 < 0:\n            return -1\n        res += diff\n        for i, num in enumerate(nums2):\n            if num!= 0:\n                nums2[i] = 1\n        for i in range(zeros1):\n            nums1[i] = 0\n        return res\n\n\nif __name__ == '__main__':\n    assert Solution().minSum(nums1=[1, 1000, 1], nums2=[10", "groundtruth": "class Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n\n"}
{"task_id": "python/65", "content": "Complete the following incomplete code according to the description. If you are confused or do not understand the description, feel free to ask questions in the comments.\nclass Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n        ____\n\nYou are given a 0-indexed array nums of length n and two integers a and b. The array nums consists of the numbers 0 to n - 1 in random order (possibly duplicated).\nWe define a subarray of a array nums as: nums[l] -> nums[l + 1] ->... -> nums[r], where 0 <= l <= r < n.\nAfter performing an operation on a subarray nums[l] -> nums[l + 1] ->... -> nums[r], you will have to pay ₹a times for the subarray and ₹b times for the remaining subarrays. You want to minimise the total amount you have to pay.\nComplete the following incomplete code according to the description. If you are confused or do not understand the description, feel free to ask questions in the comments.\nclass Solution:\n    def minimumCost(self, nums: List[int], a: int, b: int) -> int:\n        n = len(nums)\n        dp = [[0] * 2 for _ in range(n + 1)]\n        for i in range(n):\n            if i == 0:\n                dp[0][1] = 0\n                dp[0][0] = 0\n            else:\n                dp[i][1] = min(dp[i - 1][1] + a, dp[i - 1][0] + 2 * a)\n                dp[i][0] = min(dp[i - 1][1] + b, dp[i - 1][0] + b)\n        return min(dp[-1][0], dp[-1][1])\n\nThere is an integer n that represents the number of items. The items are numbered from 0 to n - 1. You can order any item by paying a price equal to i * price[i], where i is the item number. The price of each item is given in an array price = [price[i] for i in range(n)], and each item can be purchased no more than once. Return the maximum price of", "groundtruth": "class Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n        dp1 = dp2 = dp3 = 0\n        for num in nums:\n            dp1, dp2, dp3 = min(dp1, dp2, dp3) + max(0, k - num), dp1, dp2\n        return min(dp1, dp2, dp3)\n"}
{"task_id": "python/66", "content": "class Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        #write your code here\n\n## Problem 12.05.2: \n\nA word can be generated by a 1-to-n letter mapping from one letter to another letter. Please complete the code to implement the mapping function, and then test it. The input is as follows:\nThe input is as follows:\nFirst line contains the number of words n.\nThe following n lines contain one word per line.\nThe output is as follows:\nThe output of each word is one line. If the word can not be constructed, then the output is “not possible”.\nNote: You can only use one word for each line.\n#sample input\n4\nabcd\ncabd\nabba\nabaa\n#sample output\ncabd\nnot possible\nabba\nabaa\n\n\nclass Solution:\n    def one_to_one_mapping(self, words: List[str]) -> List[str]:\n        # write your code here\ns = Solution()\nwords = ['abcd', 'cabd', 'abba', 'abaa']\nprint(s.one_to_one_mapping(words))\n/week6/README.md\n# Week 6: Problem Set 11: Graphs\n\n| Problem | Status |\n| ------- | ------ |\n| [1.01.1](#problem-1011) | Done (not reviewed) |\n| [1.01.2](#problem-1012) | Done (not reviewed) |\n| [1.01.3](#problem-1013) | Done (not reviewed) |\n| [1.02.1](#problem-1021) | Done (not reviewed) |\n| [1.02.2](#problem-1022) | Done (not reviewed) |\n| [1.03](#problem-103) | Done (not reviewed) |\n| [1.04](#problem-104) | Done (not reviewed) |\n| [1.05](#problem-105) | Done (not reviewed) |\n| [1.06](#problem-106) | Done (not reviewed", "groundtruth": "class Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i) \n                    if j < 13: \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n"}
{"task_id": "python/67", "content": "\nTest case\nExample 1:\nInput: nums = [1,1,1,1,1]\nOutput: 8\nExplanation: The subarrays of nums are:\n\n[1] with a distinct count of 1.\n[1,1] with a distinct count of 1.\n[1,1,1] with a distinct count of 1.\n[1,1,1,1] with a distinct count of 1.\n[1,1,1,1,1] with a distinct count of 1.\nThe sum of squares of distinct counts is 1 + 1 + 1 + 1 + 1 = 8.\n\n'''\n\nfrom typing import List\n\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        last = [0] * (n + 1)\n        s = [0] * (n + 1)\n        for i, x in enumerate(nums):\n            ans += (s[last[x]] + last[x] - 1) * 2 + i - last[x]\n            last[x] = i\n            s[i + 1] = s[i] + 1\n\n        return ans % 1000000007\n'''\n\nGiven two integers representing the numerator and denominator of a fraction, return the fraction in string format.\nIf the fractional part is repeating, enclose the repeating part in parentheses.\n\nExample 1:\n\nInput: numerator = 1, denominator = 2\nOutput: \"0.5\"\nExample 2:\n\nInput: numerator = 2, denominator = 1\nOutput: \"2\"\nExample 3:\n\nInput: numerator = 2, denominator = 3\nOutput: \"0.(6)\"\n\n'''\n\nfrom typing import List\n\nclass Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        sign = '-' if numerator * denominator < 0 else ''\n        d, r = divmod(abs(numerator), abs(denominator))\n        ans = [sign + str(d)]\n        if r == 0:\n            return ans[0]\n        ans += '.'\n        dic =", "groundtruth": "\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = [0] * (n * 4)\n        todo = [0] * (n * 4)\n\n        def do(o: int, l: int, r: int, add: int) -> None:\n            sum[o] += add * (r - l + 1)\n            todo[o] += add\n\n        # o=1  [l,r] 1<=l<=r<=n\n        # 把 [L,R] 加一，同时返回加一之前的区间和\n        def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:\n            if L <= l and r <= R:\n                res = sum[o]\n                do(o, l, r, 1)\n                return res\n\n            m = (l + r) // 2\n            add = todo[o]\n            if add:\n                do(o * 2, l, m, add)\n                do(o * 2 + 1, m + 1, r, add)\n                todo[o] = 0\n\n            res = 0\n            if L <= m: res += query_and_add1(o * 2, l, m, L, R)\n            if m < R:  res += query_and_add1(o * 2 + 1, m + 1, r, L, R)\n            sum[o] = sum[o * 2] + sum[o * 2 + 1]\n            return res\n\n        ans = s = 0\n        last = {}\n        for i, x in enumerate(nums, 1):\n            j = last.get(x, 0)\n            s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j\n            ans += s\n            last[x] = i\n        return ans % 1_000_000_007\n"}
{"task_id": "python/68", "content": "\nExample 1:\nInput: nums = [4,4,4,2,4]\nOutput: 42\nExplanation: The distinct count of the subarrays is [1,1,1,1,3,2,1,4,3,3,4]. The sum of the squares of the distinct counts is 121.\nExample 2:\n\nInput: nums = [1,3,3,2]\nOutput: 30\nExplanation: The distinct count of the subarrays is [1,1,2,1,2,1,3,1,3,2,3,3]. The sum of the squares of the distinct counts is 147.\nExample 3:\n\nInput: nums = [10000]\nOutput: 1000000000\nExplanation: The distinct count of the subarrays is [1]. The sum of the squares of the distinct counts is 1.\n\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def pathSum(self, root: TreeNode, target: int) -> List[List[int]]:\n        dic = dict()\n        dic[0] = [[]]\n        def pre(root, target):\n            if not root:\n                return dic\n            dic[root.val] = [[root.val]+i for i in dic[target-root.val]]\n            pre(root.left, target)\n            pre(root.right, target)\n        pre(root, target)\n        return dic[target]\n/169/2.py\n#!/usr/bin/env python\n# _*_ coding: utf-8 _*_\n# @Time : 2021/7/18 21:19 \n# @Author : Aries \n# @Site :  \n# @File : 2.py\n# @Software: PyCharm\n\nfrom typing import List\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        n = len(nums)\n        ret = nums[0]\n        for i in", "groundtruth": "\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = [0] * (n * 4)\n        todo = [0] * (n * 4)\n\n        def do(o: int, l: int, r: int, add: int) -> None:\n            sum[o] += add * (r - l + 1)\n            todo[o] += add\n\n        # o=1  [l,r] 1<=l<=r<=n\n        # 把 [L,R] 加一，同时返回加一之前的区间和\n        def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:\n            if L <= l and r <= R:\n                res = sum[o]\n                do(o, l, r, 1)\n                return res\n\n            m = (l + r) // 2\n            add = todo[o]\n            if add:\n                do(o * 2, l, m, add)\n                do(o * 2 + 1, m + 1, r, add)\n                todo[o] = 0\n\n            res = 0\n            if L <= m: res += query_and_add1(o * 2, l, m, L, R)\n            if m < R:  res += query_and_add1(o * 2 + 1, m + 1, r, L, R)\n            sum[o] = sum[o * 2] + sum[o * 2 + 1]\n            return res\n\n        ans = s = 0\n        last = {}\n        for i, x in enumerate(nums, 1):\n            j = last.get(x, 0)\n            s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j\n            ans += s\n            last[x] = i\n        return ans % 1_000_000_007\n"}
{"task_id": "python/69", "content": "For example:\nInput: s = \"1100\"\nOutput: 0\nExplanation: s does not have any substrings with even length in it.\nThus, there are no changes required. s is beautiful.\n\nInput: s = \"0010\"\nOutput: 1\nExplanation: The substring \"0\" can be changed to \"1\" to make s beautiful.\nThis takes one change from the original string.\n\nInput: s = \"01001010\"\nOutput: 0\nExplanation: s does not have any substrings with even length in it.\nThus, there are no changes required. s is beautiful.\n\n */\npackage com.javaplus.exercise002;\n\n/**\n * \n * @author wangrui\n *\n */\npublic class Leetcode1512 {\n\n  public static void main(String[] args) {\n\n  }\n\n  public int minChanges(String s) {\n    int res = 0;\n    char currentChar = 'x';\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      if (c!= currentChar) {\n        res++;\n      }\n      currentChar = c;\n    }\n    return res / 2;\n  }\n}\n/src/main/java/com/javaplus/exercise001/Leetcode212.java\npackage com.javaplus.exercise001;\n\n/**\n * 212. Word Search II\n * Given an m x n board of characters and a list of strings words, return all words on the board.\n * Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n * \n * \n * \n * Example 1:\n * Input: board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\n * Output: [\"eat\",\"oath\"]\n * \n * Example 2:\n * Input: board = [[\"a\",\"b\"],[\"c\",\"", "groundtruth": "\nclass Solution:\n    def minChanges(self, s: str) -> int:\n        cnt = 0\n        for i in range(0, len(s), 2):\n            if len(set(s[i:i + 2])) > 1:\n                cnt += 1\n                \n        print(s)\n        return cnt\n"}
{"task_id": "python/70", "content": "The code must be Python code, and the code must be executable, and the runtime must be within one second.\n'''\n#https://programmers.co.kr/learn/courses/30/lessons/12904\n\n# import sys,os\n# sys.stdin=open('input.txt','rt')\n\n# from itertools import combinations\n\n# # def dfs(cnt,start):\n# #     global result\n# #     if len(result)>0 and result[0]<cnt:\n# #         return\n# #     if start>=n:\n# #         result[0]=max(result[0],cnt)\n# #         return\n# #     for i in range(start,n):\n# #         if nums[i][0]>cnt:\n# #             break\n# #         dfs(cnt+nums[i][1],i+1)\n# # n,m = map(int,input().split())\n# # nums=[]\n# # result=[-1]\n# # for _ in range(n):\n# #     nums.append(list(map(int,input().split())))\n# #     nums[-1].sort()\n# # nums.sort()\n# # for start in range(n):\n# #     dfs(nums[start][1],start+1)\n# # if result[0]==-1:\n# #     result[0]=0\n# # print(result[0])\n# class Solution:\n#     def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n#         result = [-1]\n#         def dfs(cnt,start):\n#             if len(result)>0 and result[0]<cnt:\n#                 return\n#             if start>=n:\n#                 result[0]=max(result[0],cnt)\n#                 return\n#             for i in range(start,n):\n#                 if nums[i][0]>cnt:\n#                     break\n#                 dfs(cnt+nums[i][1],i+1)\n#         n,m = map(int,input().split())\n#         nums=[]\n#         for _ in range(n):\n#             nums.append(list(map(int,input().split())))", "groundtruth": "\nclass Solution:\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        f = [0] + [-inf] * target\n        s = 0\n        for x in nums:\n            s = min(s + x, target)\n            for j in range(s, x - 1, -1):\n                # f[j] = max(f[j], f[j - x] + 1)\n                if f[j] < f[j - x] + 1:\n                    f[j] = f[j - x] + 1\n        return f[-1] if f[-1] > 0 else -1\n"}
{"task_id": "python/71", "content": "\nExamples:\nInput: m = 6, n = 2, hFences = [4], vFences = [2]\nOutput: 4\nExplanation: The maximum area of the square field that can be formed using the given fences is 2 x 2 = 4.\n\nInput: m = 5, n = 6, hFences = [1, 3, 5], vFences = [3, 4]\nOutput: 4\nExplanation: The maximum area of the square field that can be formed using the given fences is 2 x 2 = 4.\n\nConstraints:\n\n1 <= m <= 15\n1 <= n <= 15\n1 <= hFences.length, vFences.length <= 500\n1 <= hFences[i], vFences[j] <= min(m, n)\nhFences and vFences are not sorted.\n\n'''\n/codeforces/1700/1731_B.cpp\n/*\nGiven an integer n, check whether the digits 0, 1, and 8 are in non-decreasing order in n. If this is so, return Yes, otherwise, return No.\n\nInput\nThe first line contains the number of test cases t (1<=t<=1000).\n\nEach of the next t lines contains an integer n (0 <= n < 10^18).\n\nOutput\nFor each test case, output Yes or No without quotes.\n\nExample\nInput:\n2\n5\n998244353\n\nOutput:\nYes\nNo\n\n*/\n#include <bits/stdc++.h> \nusing namespace std; \n\nbool f(long long &n) { \n    string s=to_string(n);\n    //if(s.find(\"8\") == string::npos) return false;\n    sort(s.begin(),s.end());\n    if(s.find(\"1\") > s.find(\"0\") || s.find(\"0\") > s.find(\"8\")) return false;\n    return true; \n}\n\nint main()\n{\n\tint t; scanf(\"%d\",&t);\n\twhile(t--) {\n\t\tlong long n; scanf(\"%lld\",&", "groundtruth": "\nclass Solution:\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n        h = self.f(hFences, m)\n        v = self.f(vFences, n)\n        ans = max(h & v, default=0)\n        return ans ** 2 % 1_000_000_007 if ans else -1\n\n    def f(self, a: List[int], mx: int) -> Set[int]:\n        a.extend([1, mx])\n        a.sort()\n        return set(y - x for x, y in combinations(a, 2))\n"}
{"task_id": "python/72", "content": "\"\"\"\n\n\nclass Solution:\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n        return self.dfs(0, 0, m-1, n-1, set(hFences), set(vFences))\n\n    def dfs(self, xl, yl, xr, yr, hFences, vFences) -> int:\n        if xl >= xr or yl >= yr:\n            return 0\n        xm = xr + xl\n        ym = yr + yl\n        if xl == xm - 1 and yl == ym - 1:\n            return (xr - xl) * (yr - yl)\n        l = self.dfs(xl, yl, xm, ym, hFences, vFences)\n        r = self.dfs(xm, yl, xr, ym, hFences, vFences)\n        u = self.dfs(xl, ym, xm, yr, hFences, vFences)\n        d = self.dfs(xl, yl, xm, ym, hFences, vFences)\n        return max(l, r, u, d, self.helper(xl, yl, xr, yr, l, r, u, d, hFences, vFences))\n\n    def helper(self, xl, yl, xr, yr, l, r, u, d, hFences, vFences) -> int:\n        if not (l and r and u and d):\n            return -1\n        xm = xr + xl\n        ym = yr + yl\n        xs = [i for i in range(xl, xr) if i in hFences]\n        ys = [j for j in range(yl, yr) if j in vFences]\n        for x in xs:\n            if self.f([xm-1, xl, x], x) & self.f([ym-1, yl, yr], ym):\n                return l\n        for y in ys:\n            if self.f([xm, xl, xr], y) & self.f([ym-1, yl, y], ym):\n                return d\n        return -1\n\n    def f(self", "groundtruth": "\nclass Solution:\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n        h = self.f(hFences, m)\n        v = self.f(vFences, n)\n        ans = max(h & v, default=0)\n        return ans ** 2 % 1_000_000_007 if ans else -1\n\n    def f(self, a: List[int], mx: int) -> Set[int]:\n        a.extend([1, mx])\n        a.sort()\n        return set(y - x for x, y in combinations(a, 2))\n"}
{"task_id": "python/73", "content": "*/\n\n\nclass Solution {\npublic:\n    int minimumCost(string source, string target, vector<string> original, vector<string> changed, vector<int> cost) {\n\n    }\n};\n/*\nhttps://leetcode.com/problems/path-crossing/\n\nGiven a string path, where path[i] = 'N', 'S', 'E' or 'W', each representing moving one unit north, south, east, or west, respectively. You start at the origin (0, 0) on a 2D plane and walk on the path specified by path.\nReturn True if the path crosses itself at any point, that is, if at any time you are on a location you've previously visited. Return False otherwise.\n\nInput: path = \"NES\"\nOutput: false \nExplanation: Notice that the path doesn't cross any point more than once.\n\nInput: path = \"NESWW\"\nOutput: true\nExplanation: Notice that the path visits the origin twice.\n\nExample 1:\nInput: path = \"NES\"\nOutput: false\nExplanation: Notice that the path doesn't cross any point more than once.\n\nExample 2:\nInput: path = \"NESWW\"\nOutput: true\nExplanation: Notice that the path visits the origin twice.\n\nConstraints:\n1 <= path.length <= 104\npath will only consist of characters in {'N', 'S', 'E', 'W}\n\n\n*/\n\nclass Solution {\npublic:\n    bool isPathCrossing(string path) {\n        if(path.size()==1)return false;\n        unordered_map<string, bool> check;\n        check[\"NESW\"] = false;\n        int x = 0, y = 0;\n        string temp =\"\";\n        for (int i = 0; i < path.size(); ++i)\n        {\n            temp += path[i];\n            if(temp == \"NE\" || temp == \"NW\" || temp == \"SE\" || temp == \"SW\")\n            {\n                x += (temp[0] - 'N');\n                y += (temp[1] - 'E');\n                if(check[\"NESW\"] || check[to_string(x) + to_string(y)])\n                    return true;\n                check[\"NESW\"] =", "groundtruth": "\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        dis = [[inf] * 26 for _ in range(26)]\n        for i in range(26):\n            dis[i][i] = 0\n\n        for x, y, c in zip(original, changed, cost):\n            x = ord(x) - ord('a')\n            y = ord(y) - ord('a')\n            dis[x][y] = min(dis[x][y], c)\n\n        for k in range(26):\n            for i in range(26):\n                for j in range(26):\n                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))\n        return ans if ans < inf else -1\n"}
{"task_id": "python/74", "content": "```\n\n```python\nfrom collections import defaultdict\n\ninf = float(\"inf\")\n\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        len_to_strs = defaultdict(set)\n        dis = defaultdict(lambda: defaultdict(lambda: inf))\n        for x, y, c in zip(original, changed, cost):\n            len_to_strs[len(x)].add(x)  \n            len_to_strs[len(y)].add(y)\n            dis[x][y] = min(dis[x][y], c)\n            dis[x][x] = 0\n            dis[y][y] = 0\n\n        for strs in len_to_strs.values():\n            for k in strs:\n                for i in strs:\n                    if dis[i][k] == inf:  \n                        continue\n                    for j in strs:\n                        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        @cache\n        def dfs(i: int) -> int:\n            if i == 0:\n                return 0\n            \n            res = inf\n            for j in range(i):\n                # 选子字符串\n                s = source[i - j: i + 1]\n                \n                # 找相邻的两个字符串\n                for x in len_to_strs[j]:\n                    if x == s[-1]: \n                        for y in len_to_strs[i - j]:\n                            if y == s[0]:\n                                res = min(res, cost[x == y] + dfs(i - j))\n            return res\n\n        ans = dfs(len(source))\n        return ans if ans < inf else -1\n```\n\n## 523. 连续的子数组和\n```\n给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：\n子数组中任意元素将被替换为原数组中按位异或后的结果。\n原数组的子数组之和也为 k 。\n如果存在 同时满足上述条件的连续子数组，则返回 true ；否则，返回 false 。\n\nclass Solution:\n    def check", "groundtruth": "\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        len_to_strs = defaultdict(set)\n        dis = defaultdict(lambda: defaultdict(lambda: inf))\n        for x, y, c in zip(original, changed, cost):\n            len_to_strs[len(x)].add(x)  \n            len_to_strs[len(y)].add(y)\n            dis[x][y] = min(dis[x][y], c)\n            dis[x][x] = 0\n            dis[y][y] = 0\n\n        for strs in len_to_strs.values():\n            for k in strs:\n                for i in strs:\n                    if dis[i][k] == inf:  \n                        continue\n                    for j in strs:\n                        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        @cache\n        def dfs(i: int) -> int:\n            if i == 0:\n                return 0\n            res = inf\n            if source[i - 1] == target[i - 1]:\n                res = dfs(i - 1) \n            for size, strs in len_to_strs.items():  \n                if i < size:\n                    continue\n                s = source[i - size: i]\n                t = target[i - size: i]\n                if s in strs and t in strs:  \n                    res = min(res, dis[s][t] + dfs(i - size))\n            return res\n        ans = dfs(len(source))\n        return ans if ans < inf else -1\n"}
{"task_id": "python/75", "content": "\nExample 1:\nInput: source = \"leetcode\", target = \"practice\", original = [\"leet\",\"code\"], changed = [\"practice\",\"practice\"], cost = [3,4]\nOutput: 3\nExplanation: To convert source into target, we need the following operations:\n- Pick \"leet\", and change it to \"practice\" in cost 3.\n- Pick \"co\", and change it to \"ce\" in cost 3.\nThe total cost is 3 + 3 = 6.\n\nExample 2:\nInput: source = \"abcdefghijklmn\", target = \"magician\", original = [\"abcdefgh\",\"abcdefgh\",\"abcdefgh\"], changed = [\"abcdefgh\",\"abcdefgh\",\"abcdefgh\"], cost = [0,1,2,3,4,5,6,7,8,9,10,11]\nOutput: -1\nExplanation: Since changing any substring would increase the total cost, it is impossible to convert the string.\n\"\"\"/C++/63_UniquePathsII.cpp\n/*\nA robot is located at the top-left corner of a m x n grid.\n\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid.\n\nNow consider if some obstacles are added to the grids. How many unique paths would there be?\n\nAn obstacle and space is marked as 1 and 0 respectively in the grid.\n\nNote: m and n will be at most 100.\n\nExample:\n\nInput:\n\n[\n[0,0,0],\n[0,1,0],\n[0,0,0]\n]\n\nOutput: 2\n\nExplanation:\nThere is one obstacle in the middle of the 3x3 grid above.\n\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right\n*/\n\n// 26/26 cases passed(24ms)\n\nclass Solution {\npublic:\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        int m = obstacleGrid.size();\n        int n = obstacleGrid[0].size();\n        vector<vector<long long>> dp(m, vector<long long>(n));\n        for(int", "groundtruth": "\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        len_to_strs = defaultdict(set)\n        dis = defaultdict(lambda: defaultdict(lambda: inf))\n        for x, y, c in zip(original, changed, cost):\n            len_to_strs[len(x)].add(x)  \n            len_to_strs[len(y)].add(y)\n            dis[x][y] = min(dis[x][y], c)\n            dis[x][x] = 0\n            dis[y][y] = 0\n\n        for strs in len_to_strs.values():\n            for k in strs:\n                for i in strs:\n                    if dis[i][k] == inf:  \n                        continue\n                    for j in strs:\n                        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        @cache\n        def dfs(i: int) -> int:\n            if i == 0:\n                return 0\n            res = inf\n            if source[i - 1] == target[i - 1]:\n                res = dfs(i - 1) \n            for size, strs in len_to_strs.items():  \n                if i < size:\n                    continue\n                s = source[i - size: i]\n                t = target[i - size: i]\n                if s in strs and t in strs:  \n                    res = min(res, dis[s][t] + dfs(i - size))\n            return res\n        ans = dfs(len(source))\n        return ans if ans < inf else -1\n"}
{"task_id": "cpp/0", "content": "int n;int mod;vector<vector<int>> f;vector<int> nums;\ndfs(state, i)\n{\nif(f[state][i]!= -1)\n{\nreturn f[state][i];\n}\nif(state == (1 << i))\n{\nreturn 1;\n}\nf[state][i] = 0;\nfor(int j = 0; j < n; j++)\n{\nif(i == j ||!(state >> j & 1))\n{\ncontinue;\n}\nif(nums[i] % nums[j]!= 0 && nums[j] % nums[i]!= 0)\n{\ncontinue;\n}\nf[state][i] = f[state][i] + dfs(state | (1 << j), j);\n}\nreturn f[state][i];\n}\nres = res + dfs(1 << i, i);\n}\nreturn res % mod;\n\n## Explain\n\nFirst, we need to consider what special permutations are.\n\nHere is the answer, it is necessary that each element is only divided by other elements in the array, such that the divisor of it can not be divided by the number.\nFor example, 5%4==0 5%10!=0 5%20!=0\nThe special permutations in this case are 5, 4, 20, 10, 80, 40, 320, 200, 1600, 1000, 800, 6400, 5120, 40960, 327680, 2621440\n\nThe question asks us to calculate how many special permutations there are in total, so we need to get the number of permutations.\n\nIn general, the number of permutations of n elements (including repeated elements) is given by:\n$$P_n = n!$$\nBecause the number of the elements does not matter, and we have a total of n elements to choose from, so for the first element, there are n options, for the second, there are n-1, and so on, it is:\n$$P_{n} = n \\times", "groundtruth": "class Solution {public:static const int mod = 1e9 + 7;int specialPerm(vector<int>& nums) {int n = nums.size();vector<vector<int>> f(1 << n, vector<int>(n, -1));function<int(int, int)> dfs = [&](int state, int i) {if (f[state][i] != -1) {return f[state][i];}if (state == (1 << i)) {return 1;}f[state][i] = 0;for (int j = 0; j < n; j++) {if (i == j || !(state >> j & 1)) {continue;}if (nums[i] % nums[j] != 0 && nums[j] % nums[i] != 0) {continue;}f[state][i] = (f[state][i] + dfs(state ^ (1 << i), j)) % mod;}return f[state][i];};int res = 0;for (int i = 0; i < n; i++) {res = (res + dfs((1 << n) - 1, i)) % mod;}return res;}};"}
{"task_id": "cpp/1", "content": "The only two functions that should be completed are the constructor and the paintWalls function. The code should not be modified in any other function.\nSample Test Case 1:\nSample Input:\ncost = [38, 36, 30, 51, 16, 5, 37, 11]time = [21, 42, 30, 53, 15, 13, 44, 10]Sample Output: 224\nExplanation: The best way to paint the walls is to use the paid painter only once (painting the walls in the order 4,6,1,3,2,5,7,0). In this way, the paid painter will take 42 + 30 + 51 + 15 + 5 + 44 = 224 units of money.\nSample Test Case 2:\nSample Input:\ncost = [1, 1, 1]time = [1, 1, 1]Sample Output: 2\nExplanation: It is best to use the free painter and paid painter on the first two walls.\n*/\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <vector>\nusing namespace std;\nclass Solution {\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        int n = cost.size();\n        int m = 2*n + 1;\n        vector<int> f(m, 1e9 / 2);\n        vector<int> g(m, 1e9 / 2);\n        f[n] = 0;\n        for(int i=0; i<n; ++i) {\n            g[0] = min(f[0], f[1]); //f[0]为无人，f[1]为有人\n            for(int j=2; j<m; ++j) {\n                g[j-1] = min(g[j-1], f[j]);\n            }\n            swap(g, f);\n        }\n        return *min_element(f.begin() + n, f.end());\n    }\n};\n/*\nint main() {\n    Solution sol;\n   ", "groundtruth": "class Solution {public:int paintWalls(vector<int>& cost, vector<int>& time) {int n = cost.size();vector<int> f(n * 2 + 1, INT_MAX / 2);f[n] = 0;for (int i = 0; i < n; ++i) {vector<int> g(n * 2 + 1, INT_MAX / 2);for (int j = 0; j <= n * 2; ++j) {// 付费g[min(j + time[i], n * 2)] = min(g[min(j + time[i], n * 2)], f[j] + cost[i]);// 免费if (j > 0) {g[j - 1] = min(g[j - 1], f[j]);}}f = move(g);}return *min_element(f.begin() + n, f.end());}};"}
{"task_id": "cpp/2", "content": "\nSample Input:\n2\na\nabracadabra\n\nSample Output:\nz\nabrcazdabra\n\n*/\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    std::string smallestString(std::string s) {\n        std::string res;\n        std::find_if(s.begin(), s.end(), [](char c) {\n            return c!= 'a';\n        });\n\n        int indexOfFirstNonA = std::distance(s.begin(), it);\n        if (indexOfFirstNonA == s.length()) {\n            return s.substr(0, s.length() - 1) + 'z';\n        }\n\n        size_t indexOfFirstA_AfterFirstNonA = s.find('a', indexOfFirstNonA);\n        if (____) {\n            indexOfFirstA_AfterFirstNonA = s.length();\n        }\n\n        for (int i = 0; i < s.length(); ++i) {\n            if (____) {\n                res.push_back(static_cast<char>(s[i] - 1));\n            } else {\n                res.push_back(s[i]);\n            }\n        }\n\n        return res;\n    }\n};\n\nint main(int argc, const char* argv[]) {\n    Solution solution;\n    std::string s;\n\n    std::cin >> s;\n    std::cout << solution.smallestString(s) << std::endl;\n\n    return 0;\n}/2021-03-16-Peking_2/test.cc\n/*\nPeking 2 20210316 1100 ~ 2300\n*/\n\n#include <iostream>\n\nusing namespace std;\n\nvoid swap(int a, int b) {\n    int c = a;\n    a = b;\n    b = c;\n}\n\nint main() {\n    int a = 10;\n    int b = 20;\n\n    swap(a, b);\n\n    cout << a << endl;\n    cout << b << endl;\n\n    return 0;\n}/2021-03-19-Peking_3/1014-Palindrome_Number.cc\n/*\n\nPal", "groundtruth": "class Solution {public:string smallestString(string s) {char target = 'a';auto it = std::find_if(s.begin(), s.end(), [target](char c) {return c != target;});int indexOfFirstNonA = std::distance(s.begin(), it);if (indexOfFirstNonA == s.length()) {return s.substr(0, s.length() - 1) + 'z';}size_t indexOfFirstA_AfterFirstNonA = s.find('a', indexOfFirstNonA);if (indexOfFirstA_AfterFirstNonA == string::npos) {indexOfFirstA_AfterFirstNonA = s.length();}string res;for (int i = 0; i < s.length(); ++i) {if (indexOfFirstNonA <= i && i < indexOfFirstA_AfterFirstNonA) {res.push_back(static_cast<char>(s[i] - 1));} else {res.push_back(s[i]);}}return res;}};"}
{"task_id": "cpp/3", "content": "```\nclass Solution {\npublic:\n    long long minCost(vector<int>& nums, int x) {\n        int n = nums.size();\n        vector<int> f(nums);\n        long long ans = 0;\n        for (int k = 1; k < n; ++k) {\n            for (int i = 0; i < n; ++i) {\n                f[i] = min(f[i], nums[(i + k) % n]);\n            }\n            ans += x * k;\n        }\n        return ans;\n    }\n};\n```\n\n### 1032 01-Matrix\nYou are given an m x n binary matrix grid where each cell is either 0 (representing an empty cell) or 1 (representing a wall). You can move up, down, left, or right from and to an empty cell in one step. Return the length of the shortest path from the top-left cell (grid[0][0]) to the bottom-right cell (grid[m - 1][n - 1]) such that you could visit every non-wall cell exactly once. If there is no path from the top-left cell to the bottom-right cell, then return -1.\n\n* 类似BFS，一点一点搜索，并记录每个点的最短距离；\n* 注意在搜索时，从上到下进行遍历，在一个行内的点从左到右依次搜索；\n* 注意每次搜索的路径都是直线连续的，因此记录从每个点的连线，能获得到这个点的最短距离；\n```\nclass Solution {\npublic:\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\n        if (grid[0][0] || grid[grid.size() - 1][grid[0].size() - 1]) {\n            return -1;\n        }\n        int n = grid.size(), m = grid[0].size();\n        int dirs[8][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\n\n        vector<vector<int>> vis(n, vector<int>(m));\n        queue<pair", "groundtruth": "class Solution {public:long long minCost(vector<int>& nums, int x) {int n = nums.size();vector<int> f(nums);long long ans = accumulate(f.begin(), f.end(), 0LL);for (int k = 1; k < n; ++k) {for (int i = 0; i < n; ++i) {f[i] = min(f[i], nums[(i + k) % n]);}ans = min(ans, static_cast<long long>(k) * x + accumulate(f.begin(), f.end(), 0LL));}return ans;}};"}
{"task_id": "cpp/4", "content": "\nPlease complete the following code for the given description:\n/** * Definition for a binary tree node. */\npublic class TreeNode {int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }\n// Complete the function to create a tree below.\npublic TreeNode buildTree(TreeNode root) { if(root == null) return new TreeNode(root.val); root.left = ____; root.right = ____; return ____; }\n// Complete the function to print the tree in-order below.\npublic void inOrder(TreeNode root) { if(root == null) return; ___; inOrder(root.left); System.out.print(root.val + \" \"); inOrder(root.right); }\n// Complete the function to print the tree post-order below.\npublic void postOrder(TreeNode root) { if(root == null) return; postOrder(root.left); postOrder(root.right); ___; }\nIn addition to the incomplete code, please answer the following questions. You may also use the language you like, which we recommend using the Java language. The Java code for the incomplete code is as follows:\n// Complete the function to create a tree below.\npublic TreeNode buildTree(TreeNode root) { if (root == null) return new TreeNode(root.val); root.left = ____; root.right = ____; return root; }\n// Complete the function to print the tree in-order below.\npublic void inOrder(TreeNode root) { if (root == null) return; ___; inOrder(root.left); System.out.print(root.val + \" \"); inOrder(root.right); }\n// Complete the function to print the tree post-order below.\npublic void postOrder(TreeNode root) { if (root == null) return; postOrder(root.left); postOrder(root.right); ___; }\nYou may also use the language you like, which we recommend using the Java language. The Java code for the incomplete code is as follows:\nclass Solution {public:vector<int> maximumSumQueries(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {vector<pair<int, int>> sortedNums;vector<tuple<int, int, int>> sortedQueries;for (int i = 0; i <", "groundtruth": "class Solution {public:vector<int> maximumSumQueries(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {vector<pair<int, int>> sortedNums;vector<tuple<int, int, int>> sortedQueries;for (int i = 0; i < nums1.size(); i++) {sortedNums.emplace_back(nums1[i], nums2[i]);}sort(sortedNums.begin(), sortedNums.end(), greater<pair<int, int>>());for (int i = 0; i < queries.size(); i++) {sortedQueries.emplace_back(i, queries[i][0], queries[i][1]);}sort(sortedQueries.begin(), sortedQueries.end(), [](tuple<int, int, int> &a, tuple<int, int, int> &b) {return get<1>(a) > get<1>(b);});vector<pair<int, int>> stk;vector<int> answer(queries.size(), -1);int j = 0;for (auto &[i, x, y] : sortedQueries) {while (j < sortedNums.size() && sortedNums[j].first >= x) {auto [num1, num2] = sortedNums[j];while (!stk.empty() && stk.back().second <= num1 + num2) {stk.pop_back();}if (stk.empty() || stk.back().first < num2) {stk.emplace_back(num2, num1 + num2);}j++;}int k = lower_bound(stk.begin(), stk.end(), make_pair(y, 0)) - stk.begin();if (k < stk.size()) {answer[i] = stk[k].second;}}return answer;}};"}
{"task_id": "cpp/5", "content": "Note: The incomplete code may contain errors. Please correct the above code before submitting.\nThe following test data is used for evaluation.\nThe first line is the number of test cases. The following lines are parameters of each test case.\nThere is only one test case.\nThe first line contains a string s, and the second line is a number t, where 1 ≤ |s| ≤ 1000 and 1 ≤ t ≤ 1000.\nThere is only one test case.\nThe first line contains a string s, and the second line is a number t, where 1 ≤ |s| ≤ 1000 and 1 ≤ t ≤ 1000.\nThere is only one test case.\nThe first line contains a string s, and the second line is a number t, where 1 ≤ |s| ≤ 1000 and 1 ≤ t ≤ 1000.\nSample Output 1\n3\n0123210\n5\n11110\n50\n\nSample Output 2\n4\n0123210\n5\n11110\n50\n2020\n\nSample Output 3\n2\n0123210\n5\n11110\n50\n2020\n*/#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * @lc app=leetcode.cn id=67 lang=cpp\n *\n * [67] 二进制求和\n *\n * https://leetcode-cn.com/problems/add-binary/description/\n *\n * algorithms\n * Easy (50.15%)\n * Likes:    174\n * Dislikes: 0\n * Total Accepted:    34.2K\n * Total Submissions: 67.9K\n * Testcase Example:  '\"11\"\\n\"1\"'\n *\n * 给定两个二进制字符串，返回他们的和（用二进制表示）。\n * \n * 输入为非空字符串且只包含数字 1 和 0。\n * \n * 示例 1:\n * \n * 输入: a = \"11\", b = \"1\"", "groundtruth": "class Solution {public:int longestSemiRepetitiveSubstring(string s) {int ans = 1, left = 0, same = 0, n = s.length();for (int right = 1; right < n; right++) {if (s[right] == s[right - 1] && ++same > 1) {for (left++; s[left] != s[left - 1]; left++);same = 1;}ans = max(ans, right - left + 1);}return ans;}};"}
{"task_id": "cpp/6", "content": "\n*/\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nclass Solution {\n public:\n  static constexpr int mod = 1e9 + 7;\n  int sumDistance(vector<int>& nums, string s, int d) {\n    int n = nums.size();\n    vector<long long> pos(n);\n    for (int i = 0; i < n; i++) {\n      if (s[i] == 'L') {\n        pos[i] = nums[i] - d * i;\n      } else {\n        pos[i] = nums[i] + d * i;\n      }\n    }\n    sort(pos.begin(), pos.end());\n    long long res = 0;\n    for (int i = 1; i < n; i++) {\n      res += abs(pos[i] - pos[i - 1]);\n      res %= mod;\n    }\n    return res;\n  }\n};\n\nint main() {\n  Solution s;\n  vector<int> nums{1, 4, 2};\n  string s1(\"LL\");\n  cout << s.sumDistance(nums, s1, 4) << endl;\n  return 0;\n}\n/*\nGiven an array of numbers, return the most frequent k numbers.\n\nExample 1:\nInput: nums = [1,1,2,2,3,3,3], k = 3\nOutput: [3,1,2]\n\nExample 2:\nInput: nums = [1,1,1,2,2,3,3], k = 2\nOutput: [2,1]\n\nExample 3:\nInput: nums = [1,1,1,2,2,3,3], k = 1\nOutput: [1]\n\nConstraints:\n\n1 <= k <= nums.length <= 105\n0 <= nums[i] <= 105\n\nFollow-up: Can you solve it in linear time?\n\n*/\n\n#include <algorithm>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\n public:\n  vector<int> topKFrequent(vector<int", "groundtruth": "class Solution {public:static constexpr int mod = 1e9 + 7;int sumDistance(vector<int>& nums, string s, int d) {int n = nums.size();vector<long long> pos(n);for (int i = 0; i < n; i++) {if (s[i] == 'L') {pos[i] = (long long) nums[i] - d;} else {pos[i] = (long long) nums[i] + d;}}sort(pos.begin(), pos.end());long long res = 0;for (int i = 1; i < n; i++) {res += 1ll * (pos[i] - pos[i - 1]) * i % mod * (n - i) % mod;res %= mod;}return res;}};"}
{"task_id": "cpp/7", "content": "*/\nclass Solution {\n    static constexpr int N = 1 << 8;\n    int st = 0;\n    int mp[N];\n  public:\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        for (int j = 0; j < n; j++) {\n            int k = 0;\n            for (int i = 0; i < m; i++)\n                k |= (grid[j][i] << i);\n            mp[k] = j;\n        }\n        if (mp[0])\n            return {};\n        for (auto& p: mp) {\n            for (auto& q: mp)\n                if (p.first | q.first)\n                    if ((p.first & q.first) == 0)\n                        return {min(p.second, q.second), max(p.second, q.second)};\n        }\n        return {};\n    }\n};---\n--- Generated by EmmyLua(https://github.com/EmmyLua)\n--- Created by yulunzhang.\n--- DateTime: 2020/7/30 22:59\n---\n--- [1686. Stone Game VI](https://leetcode-cn.com/problems/stone-game-vi/)\n---\n--- 题意:\n--- 有些石子是正方形的，有些是圆形的。\n--- Alice 和 Bob 轮流拿石子，Alice 总是先开始。\n--- 每次只可以拿1~2堆的石子（可以是任意的堆）。\n--- 谁拿到最后一堆石子的分数高谁赢。\n--- 分数是石堆的大小之和。\n--- 给你一个数组 stones ，其中 stones[i] 表示第 i 堆石子中的石子数。\n--- 先取石堆的先后顺序列表（即先取stones[0]、stones[1]...），请你决定两个人轮流取石堆的分数之和大小关系。\n--- 每一轮可以选取1~2堆的石子，Alice 先选取。\n--- 请你返回第一个玩家比第二个玩家获得更多分", "groundtruth": "class Solution {public:vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {vector<int> ans;unordered_map<int, int> mp;int m = grid.size();int n = grid[0].size();for (int j = 0; j < m; j++) {int st = 0;for (int i = 0; i < n; i++) {st |= (grid[j][i] << i);}mp[st] = j;}if (mp.count(0)) {ans.push_back(mp[0]);return ans;}for (auto [x, i]: mp) {for (auto [y, j]: mp) {if (!(x & y)) {return {min(i, j), max(i, j)};}}}return ans;}};"}
{"task_id": "cpp/8", "content": "\nSample Input\n4 [[0,0,3],[1,0,1],[1,3,5],[0,1,4],[0,2,1],[1,2,3],[0,3,1],[1,1,3]]\n\nSample Output\n19\n#include<bits/stdc++.h>\nusing namespace std;\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        int len = lists.size();\n        ListNode *head = NULL, *p;\n        for (int i = 0; i < len; i++) {\n            if (lists[i]!= NULL) {\n                if (head == NULL) {\n                    head = p = lists[i];\n                }\n                else {\n                    while (p->next && p->next->val > lists[i]->val) {\n                        p = p->next;\n                    }\n                    if (p->next == NULL) {\n                        p->next = lists[i];\n                    }\n                    else {\n                        ListNode *tmp = p->next;\n                        p->next = lists[i];\n                        lists[i]->next = tmp;\n                    }\n                }\n            }\n        }\n        return head;\n    }\n};\n\nint main(int argc, char *argv[]) {\n    ListNode *head, *head1 = NULL, *head2 = NULL;\n    vector<ListNode*> lists;\n    head1 = new ListNode(1);\n    head1->next = new ListNode(2);\n    head1->next->next = new ListNode(3);\n    head2 = new ListNode(4);\n    head2->next = new ListNode(5);\n    head2->next->next = new ListNode(6);\n    lists.push_back(head1);\n    lists.push_back(head2);\n    Solution s;\n    head = s.mergeKLists(lists);\n    while (head) {\n        printf(\"%d \", head->val);\n        head = head->next;\n    }\n    printf(\"\\n\");\n    return 0;\n}\n#include<bits/stdc++.h>\nusing namespace std;\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n", "groundtruth": "class Solution {public:long long matrixSumQueries(int n, vector<vector<int>> &queries) {long long ans = 0;unordered_set<int> vis[2];for (int i = queries.size() - 1; i >= 0; i--) {auto &q = queries[i];int type = q[0], index = q[1], val = q[2];if (!vis[type].count(index)) { // 后面（>i）没有对这一行/列的操作// 这一行/列还剩下 n-vis[type^1].size() 个可以填入的格子ans += (long long) (n - vis[type ^ 1].size()) * val;vis[type].insert(index);}}return ans;}};"}
{"task_id": "cpp/9", "content": "\n```cpp\nclass Solution {\r\npublic:\r\n    static constexpr int N = 23;\r\n    static constexpr int M = 401;\r\n    static constexpr int MOD = 1e9 + 7;\r\n    int d[N][M];\r\n    string num;\r\n    int min_sum;\r\n    int max_sum;\r\n    int dfs(int i, int j, bool limit) {\r\n        if (j > max_sum) {\r\n            return 0;\r\n        }\r\n        if (i == -1) {\r\n            return j >= min_sum;\r\n        }\r\n        if (!limit && d[i][j]!= -1) {\r\n            return d[i][j];\r\n        }\r\n        int res = 0;\r\n        int up = limit? num[i] - '0' : 9;\r\n        for (int x = 0; x <= up; x++) {\r\n            res = (res + dfs(i - 1, j + x, limit && x == up)) % MOD;\r\n        }\r\n        if (!limit) {\r\n            d[i][j] = res;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    int get(string num) {\r\n        reverse(num.begin(), num.end());\r\n        this->num = num;\r\n        return dfs(num.size() - 1, 0, true);\r\n    }\r\n\r\n    // 求解 num - 1，先把最后一个非 0 字符减去 1，再把后面的 0 字符变为 9\r\n    string sub(string num) {\r\n        int i = num.size() - 1;\r\n        while (num[i] == '0') {\r\n            i--;\r\n        }\r\n        num[i]--;\r\n        i++;\r\n        while (i < num.size()) {\r\n            num[i] = '9';\r\n            i++;\r\n        }\r\n        return num;\r\n    }\r\n\r\n    int count(string num1, string num2, int min_sum, int max_sum) {\r\n        memset(d, -1, sizeof d);\r\n        this->min_sum = min_sum;\r\n        this->max_sum = max_sum;\r\n        long long res = 0;\r\n        res += get(num1);\r\n        res += MOD - get(sub(num1));\r\n        res -= get(num2);\r\n        res += MOD - get(sub(num2));\r\n        return res % MOD;\r\n    }\r\n};", "groundtruth": "class Solution {static constexpr int N = 23;static constexpr int M = 401;static constexpr int MOD = 1e9 + 7;int d[N][M];string num;int min_sum;int max_sum;int dfs(int i, int j, bool limit) {if (j > max_sum) {return 0;}if (i == -1) {return j >= min_sum;}if (!limit && d[i][j] != -1) {return d[i][j];}int res = 0;int up = limit ? num[i] - '0' : 9;for (int x = 0; x <= up; x++) {res = (res + dfs(i - 1, j + x, limit && x == up)) % MOD;}if (!limit) {d[i][j] = res;}return res;}int get(string num) {reverse(num.begin(), num.end());this->num = num;return dfs(num.size() - 1, 0, true);}// 求解 num - 1，先把最后一个非 0 字符减去 1，再把后面的 0 字符变为 9string sub(string num) {int i = num.size() - 1;while (num[i] == '0') {i--;}num[i]--;i++;while (i < num.size()) {num[i] = '9';i++;}return num;}public:int count(string num1, string num2, int min_sum, int max_sum) {memset(d, -1, sizeof d);this->min_sum = min_sum;this->max_sum = max_sum;return (get(num2) - get(sub(num1)) + MOD) % MOD;}};"}
{"task_id": "cpp/10", "content": "You can assume that m == mat.size() and m > 0, n == mat[0].size() and n > 0, arr.length is in [1, m * n], and arr and mat both consist of all the integers in the range [1, m * n].\nYou can modify mat in any way (add to, remove from, and modify). However, do not change the value of any element in arr.\nConstraints:\nm == mat.length\nn == mat[i].length\n1 <= m, n <= 250\nm * n <= 250 * 250\n1 <= arr.length <= m * n\n1 <= mat[i][j], arr[i] <= m * n\n1 <= sum(arr.length) <= 250 * 250\nTime complexity: O(m*n + len(arr))\nSpace complexity: O(m*n + len(arr))\n\n'''\nfrom typing import List\n\nclass Solution:\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\n        return min([i for i, val in enumerate(arr)\n                    if not [i for i in range(len(mat)) if not all([v in mat[i] for v in mat[i]])]\n                    and not [i for i in range(len(mat[0])) if not all([v in [mat[j][i] for j in range(len(mat))] for v in mat[0]])]],\n                   default=-1)\n\n        # mp = dict()\n        # for i in range(len(mat)):\n        #     for j in range(len(mat[i])):\n        #         mp[mat[i][j]] = i, j\n        #\n        # rowcnt = [0] * len(mat)\n        # colcnt = [0] * len(mat[0])\n        #\n        # for i in range(len(arr)):\n        #     rowcnt[mp[arr[i]][0]] += 1\n        #     if rowcnt[mp[arr[i]][0]] == len(mat[0]):\n        #         return i\n        #     colcnt[mp[arr[i]][1]] += 1\n        #     if colcnt[mp[arr[i]][1]] == len", "groundtruth": "class Solution {public:int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {int n = mat.size();int m = mat[0].size();unordered_map<int, pair<int, int>> mp;for (int i = 0; i < n; ++i) {for (int j = 0; j < m; ++j) {mp[mat[i][j]] = {i, j};}}vector<int> rowCnt(n, 0);vector<int> colCnt(m, 0);for (int i = 0; i < arr.size(); ++i) {auto& v = mp[arr[i]];++rowCnt[v.first];if (rowCnt[v.first] == m) {return i;}++colCnt[v.second];if (colCnt[v.second] == n) {return i;}}return -1;}};"}
{"task_id": "cpp/11", "content": "\nint[][] specialRoads = {{1, 2, 4, 6, 1}, {4, 4, 7, 11, 2}, {2, 6, 2, 7, 3}, {1, 4, 5, 6, 4}, {2, 3, 3, 4, 3}, {1, 7, 5, 8, 1}, {7, 7, 8, 9, 4}, {5, 6, 5, 9, 1}};\n*/\nclass Solution {\npublic:\n    int minimumCost(vector<int> &start, vector<int> &target, vector<vector<int>>& specialRoads) {\n        int t = (target[0] << 32) | target[1];\n        unordered_map<int, int> dis = {{(start[0] << 32) | start[1], 0}, {t, 0x3f3f3f3f}};\n        unordered_set<int> vis;\n        while (!vis.count(t))\n        {\n            int v = -1, dv = -1;\n            for (auto &[p, d]: dis)if (!vis.count(p) && (dv < 0 || d < dv))v = p, dv = d;\n            if (v == t) return dv; // 到终点的最短路已确定\n            vis.insert(v);\n            int vx = v >> 32, vy = v & UINT32_MAX;\n            // 更新到终点的最短路\n            for (auto &r: specialRoads)\n            {\n                int d = abs(r[2] - vx) + abs(r[3] - vy);\n                int w = (r[2] << 32) | r[3];\n                if (!dis.count(w) || d < dis[w])dis[w] = d;\n            }\n        }\n        return -1;\n    }\n};\n#include <cstdio>\r\n#include <cstring>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nint n;\r\nint a[310];\r\nbool c[310][310];\r\nint ans[31", "groundtruth": "class Solution {public:int minimumCost(vector<int> &start, vector<int> &target, vector <vector<int>> &specialRoads) {using LL = long long;LL t = (LL) target[0] << 32 | target[1];unordered_map<LL, int> dis = {{(LL) start[0] << 32 | start[1], 0}, {t, INT_MAX}};unordered_set<LL> vis;for (;;) {LL v = -1;int dv = -1;for (auto &[p, d]: dis)if (!vis.count(p) && (dv < 0 || d < dv))v = p, dv = d;if (v == t) return dv; // 到终点的最短路已确定vis.insert(v);int vx = v >> 32, vy = v & UINT32_MAX;// 更新到终点的最短路dis[t] = min(dis[t], dv + target[0] - vx + target[1] - vy);for (auto &r: specialRoads) {int d = dv + abs(r[0] - vx) + abs(r[1] - vy) + r[4];LL w = (LL) r[2] << 32 | r[3];if (!dis.count(w) || d < dis[w])dis[w] = d;}}}};"}
{"task_id": "cpp/12", "content": "\nExample 1:\nInput: s = \"bebc\", k = 5\nOutput: \"beebc\"\nExplanation: The string can be modified as follows:1. Replace the 2nd letter 'b' by 'e'. 2. Replace the 1st letter 'e' by 'e'. 3. Replace the 4th letter 'c' by 'b'. \"beecb\" is lexicographically larger. \"beecc\" is 2nd lexicographically larger. \"beebc\" is 3rd lexicographically larger. None of them meets the condition \"The string consists of the first k letters of the English lowercase alphabet. It does not contain any substring of length 2 or more which is a palindrome\".\nExample 2:\nInput: s = \"eedaaab\", k = 5\nOutput: \"\"\nExplanation: It is not possible to modify the string to make it beautiful.\nConstraints:The number of characters in the string is n, where 1 ≤ n ≤ 1,000,000.1 ≤ k ≤ 26.All the characters in the string are lower case English letters.\n\n#include<stdio.h>\n\n#include<stdlib.h>\n\n#include<string.h>\n\nchar* smallestBeautifulString(char *s, int k) {    char*ret=(char*)calloc(1000007,sizeof(char));//ret是一个数组      char* p = ret;    int* visit = (int*)calloc(k, sizeof(int));    int tmp = k;    for (int i = s[i] - 'a'; i < tmp; i++) {//先统计所有字母的个数        visit[i] = 1;        tmp = i + 1;    }    for (int i = 0; i < strlen(s); i++) {//检查当前位置的字母是否比visit[tmp - 1]大        if (s[i] - 'a' >= visit[tmp - 1]) {            return ret;        }        tmp--;    }    for (int i = strlen(s) - 1; i >= 0; i--) {//找一个比当前位置的字符大并且还没出现的字母        if (s[i] -", "groundtruth": "class Solution {public:string smallestBeautifulString(string s, int k) {for (int i = s.length() - 1; i >= 0; --i) {unordered_set<char> blockedCharacters;for (int j = 1; j <= 2; ++j) {if (i - j >= 0) {____}}for (int j = 1; j <= 3; ++j) {if (s[i] - 'a' + j + 1 <= k && blockedCharacters.find(s[i] + j) == blockedCharacters.end()) {return generate(s, i, j);}}}return \"\";}string generate(string s, int idx, int offset) {s[idx] += offset;for (int i = idx + 1; i < s.length(); ++i) {unordered_set<char> blockedCharacters;for (int j = 1; j <= 2; ++j) {if (i - j >= 0) {blockedCharacters.insert(s[i - j]);}}for (int j = 0; j < 3; ++j) {if (____) {s[i] = 'a' + j;break;}}}return s;}};"}
{"task_id": "cpp/13", "content": "Input description:Input consists of multiple test cases.The first line of input contains an integer T (1 <= T <= 1000), indicating the number of test cases.Then T test cases follow.For each test case, the first line contains an integer n (1 <= n <= 100000), the length of each array.The next line contains n space-separated integers A[i] (1 <= A[i] <= n), the i-th integer of the array A.The next line contains n space-separated integers B[i] (1 <= B[i] <= n), the i-th integer of the array B.Output description:Output the prefix common array of A and B, each integer separated by space.\nInput Sample:\n3\n4\n2 1 2 3\n2 1 2 3\n5\n1 2 2 3 2\n1 2 1 1 2\n2\n2 1\n1 2\nOutput Sample:\n0 1 1 1\n0 0 0 1 1\n\n• 评论\n\n• 上一篇\n• 下一篇", "groundtruth": "class Solution {public:vector<int> findThePrefixCommonArray(vector<int> &a, vector<int> &b) {int n = a.size();vector<int> ans(n);long long p = 0, q = 0;for (int i = 0; i < n; ++i) {p |= 1LL << a[i];q |= 1LL << b[i];ans[i] = __builtin_popcountll(p & q);}return ans;}};"}
{"task_id": "cpp/14", "content": "class Solution {\nprivate:\nstatic constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\npublic:\nint findMaxFish(vector<vector<int>> &grid) {\nint m = grid.size(), n = grid[0].size(), ans = 0;\nfunction<int(int, int)> dfs = [&](int x, int y) -> int {\nif (grid[x][y] <= 0) return 0;\nint sum = grid[x][y];\ngrid[x][y] = 0; // 标记成访问过\nfor (auto &d: dirs) // 四方向移动\nint res = dfs(x + d[0], y + d[1]);\nreturn sum + res;\n};\nfor (int i = 0; i < m; ++i)\nfor (int j = 0; j < n; ++j)\nans = max(ans, dfs(i, j));\nreturn ans;\n}\n};\n'''\n\n\n\"\"\"\n\n\"\"\"\n\n\nclass Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        dp = [0, 0, 0]\n        mod = 10 ** 9 + 7\n        for n in nums:\n            dp_next = [0] * 3\n            for i in range(3):\n                dp_next[i] = max(dp[(i - n) % 3] + n, dp[i])\n            dp = dp_next\n\n        return dp[0] % mod\n\n'''\n# dp[k] 以nums[k]为结尾且和为k能得到的最大值\n# dp[k] = max(dp[k-nums[k]], nums[k])\n# nums[k] 不可以超过n/3\n# 时间复杂度 O(N^2)\n# 空间复杂度 O(N)\nclass Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        dp = [0] * (1 + len(nums))\n        n = len(nums)\n        for i in range(1, 1 + n):\n            for j in range(1, i):\n                dp[i", "groundtruth": "class Solution {static constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};public:int findMaxFish(vector<vector<int>> &grid) {int m = grid.size(), n = grid[0].size(), ans = 0;function<int(int, int)> dfs = [&](int x, int y) -> int {if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0)return 0;int sum = grid[x][y];grid[x][y] = 0; // 标记成访问过for (auto &d: dirs) // 四方向移动sum += dfs(x + d[0], y + d[1]);return sum;};for (int i = 0; i < m; ++i)for (int j = 0; j < n; ++j)ans = max(ans, dfs(i, j));return ans;}};"}
{"task_id": "cpp/15", "content": "\nExample 1:\n\nInput: nums = [2,3,1,4,5]\nOutput: 4\nExplanation: The first operation removes the minimum value 1 to get nums = [2,3,4,5] and performs 1 operation.\nThe second operation removes the minimum value 2 to get nums = [3,4,5] and performs 2 operations.\nThe third operation removes the minimum value 3 to get nums = [4,5] and performs 3 operations.\nThe fourth operation removes the minimum value 4 to get nums = [5] and performs 4 operations.\nThe minimum number of operations needed to empty nums is 4.\nExample 2:\n\nInput: nums = [1,2,3,4,5]\nOutput: 0\nExplanation: The array is already empty, so there are no operations.\nExample 3:\n\nInput: nums = [4,2,3,4,5]\nOutput: 4\nExplanation: The first operation removes the minimum value 2 to get nums = [3,4,5] and performs 1 operation.\nThe second operation removes the minimum value 3 to get nums = [4,5] and performs 2 operations.\nThe third operation removes the minimum value 4 to get nums = [5] and performs 3 operations.\nThe fourth operation removes the minimum value 5 to get nums = [] and performs 4 operations.\nThe minimum number of operations needed to empty nums is 4.\n*/\n#include <iostream>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nclass BIT {\nprivate:\n  vector<int> tree;\n\npublic:\n  BIT(int n) : tree(n) {}\n\n  void inc(int i) {\n    while (i < tree.size()) {\n      ++tree[i];\n      i += i & -i;\n    }\n  }\n\n  int sum(int x) {\n    int res = 0;\n    while (x > 0) {\n      res += tree[x];\n      x &= x - 1;\n    }\n    return res;\n  }\n\n  int query(int left, int right) {\n    return sum(right) - sum(left - 1);\n  }\n};\n\nclass Solution {\nprivate:\n  int id[10", "groundtruth": "// 树状数组模板class BIT {vector<int> tree;public:BIT(int n) : tree(n) {}// 将下标 i 上的数加一void inc(int i) {while (i < tree.size()) {++tree[i];i += i & -i;}}// 返回闭区间 [1, i] 的元素和int sum(int x) {int res = 0;while (x > 0) {res += tree[x];x &= x - 1;}return res;}// 返回闭区间 [left, right] 的元素和int query(int left, int right) {return sum(right) - sum(left - 1);}};class Solution {public:long long countOperationsToEmptyArray(vector<int> &nums) {int n = nums.size(), id[n];iota(id, id + n, 0);sort(id, id + n, [&](int i, int j) {return nums[i] < nums[j];});long long ans = n; // 先把 n 计入答案BIT t(n + 1); // 下标从 1 开始int pre = 1; // 上一个最小值的位置，初始为 1for (int k = 0; k < n; ++k) {int i = id[k] + 1; // 下标从 1 开始if (i >= pre) // 从 pre 移动到 i，跳过已经删除的数ans += i - pre - t.query(pre, i);else // 从 pre 移动到 n，再从 1 移动到 i，跳过已经删除的数ans += n - pre + i - k + t.query(i, pre - 1);t.inc(i); // 删除 ipre = i;}return ans;}};"}
{"task_id": "cpp/16", "content": " */\npublic List<Integer> getSubarrayBeauty(int[] nums, int k, int x) {\n    int bias = 50;\n    int n = nums.length;\n    //计数器，统计负数在第j范围的数量\n    int[] cnt = new int[bias*2 + 1];\n    //ans的第i位是 [i,i+k-1]范围内的美丽值\n    List<Integer> ans = new ArrayList<>(n-k+1);\n    for(int i = k-1; i<n; i++){\n        //往窗口（保证窗口内是k个数）内增加一个元素\n        cnt[nums[i] + bias]++;\n        //[k-1,i]范围内的美丽值\n        int left = x;\n        for(int j = 0; j<bias; j++){\n            //找到美丽值\n            if(left <= 0){\n                ans.add(j-bias);\n                break;\n            }\n            left -= cnt[j];\n        }\n        //离开窗口\n        cnt[nums[i-k+1] + bias]--;\n    }\n    return ans;\n}\n\npublic static void main(String[] args) {\n    System.out.println(new Q4458_SubarrayBeauty().getSubarrayBeauty(\n            new int[]{-2,-3,1,-1,2},4,3));\n}\n\n/**\n * 思路一\n * 记录每k个数的美丽值，用一个cnt[]数组表示，cnt[i]记录的是i的美丽值出现的次数\n * 第i个数的美丽值=该范围内的负数个数(cnt[0]~cnt[50]和cnt[51]~cnt[100]都需要考虑)，\n * 用一个指针left指向该范围内的负数个数，从cnt数组开始遍历，left累加cnt[i],每遇到一个负数，left--，\n * 一旦left<=0，就表示第i个数就是k个数范围内的美丽值，则在答案数组ans第i-k+1位置上赋值i-50\n *\n * 复杂度分析：\n *\n * 时间复杂度O(n)\n * 空间复杂", "groundtruth": "class Solution {public:vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x) {const int BIAS = 50;int cnt[BIAS * 2 + 1]{}, n = nums.size();for (int i = 0; i < k - 1; ++i) // 先往窗口内添加 k-1 个数++cnt[nums[i] + BIAS];vector<int> ans(n - k + 1);for (int i = k - 1; i < n; ++i) {++cnt[nums[i] + BIAS]; // 进入窗口（保证窗口有恰好 k 个数）int left = x;for (int j = 0; j < BIAS; ++j) { // 暴力枚举负数范围 [-50,-1]left -= cnt[j];if (left <= 0) { // 找到美丽值ans[i - k + 1] = j - BIAS;break;}}--cnt[nums[i - k + 1] + BIAS]; // 离开窗口}return ans;}};"}
{"task_id": "cpp/17", "content": "class Solution {\npublic:\nint minOperations(vector<int>& nums) {\nint n = nums.size(), gcd_all = 0, cnt1 = 0;\nfor (int x: nums) {\ngcd_all = gcd(gcd_all, x);\nif (gcd_all > 1) return -1;\nif (cnt1) return n - cnt1;\nint min_size = n;\nfor (int i = 0; i < n; ++i) {\nint g = 0;\nfor (int j = i; j < n; ++j) {\ng = gcd(g, nums[j]);\nif (g == 1) {// 这里本来是 j-i+1，把 +1 提出来合并到 return 中\nbreak;\n}\n}\nmin_size = min(min_size, j - i);\n}\nreturn min_size + n - 1;\n}\n};", "groundtruth": "class Solution {public:int minOperations(vector<int> &nums) {int n = nums.size(), gcd_all = 0, cnt1 = 0;for (int x: nums) {gcd_all = gcd(gcd_all, x);cnt1 += x == 1;}if (gcd_all > 1) return -1;if (cnt1) return n - cnt1;int min_size = n;for (int i = 0; i < n; ++i) {int g = 0;for (int j = i; j < n; ++j) {g = gcd(g, nums[j]);if (g == 1) {// 这里本来是 j-i+1，把 +1 提出来合并到 return 中min_size = min(min_size, j - i);break;}}}return min_size + n - 1;}};"}
{"task_id": "cpp/18", "content": "\nExample\nExample 1:\nInput: nums = [2, 4, 8], divisors = [2, 4, 8]\nOutput: 8\nExplanation:\nWhen we have [2, 4, 8], the divisibility score of divisor = 2 is 1, which is the largest. Hence we should return 8.\nExample 2:\nInput: nums = [1, 2, 3, 4, 5], divisors = [2, 3, 5]\nOutput: 2\nExplanation:\nWhen we have [1, 2, 3, 4, 5], the divisibility score of divisor = 2 is 1, divisor = 3 is 2, and divisor = 5 is 3.\nTherefore, 2 is the best choice since it has the largest divisibility score.\n\n\"\"\"\n\n\nclass Solution:\n    \"\"\"\n    @param nums: the given array\n    @param divisors: the given divisor array\n    @return: the largest divisor\n    \"\"\"\n\n    def maxDivScore(self, nums, divisors):\n        cnt = -1\n        ans = 0\n\n        for i in range(len(divisors)):\n            tmp = 0\n            for j in range(len(nums)):\n                if nums[j] % divisors[i] == 0:\n                    tmp += 1\n            if tmp > cnt or (tmp == cnt and divisors[i] < ans):\n                cnt = tmp\n                ans = divisors[i]\n\n        return ans\n\"\"\"\n\nGiven a set of points that can be connected by straight line segments, find the maximum\nsum of the lengths of any two connected line segments.\n\nExample\nExample 1:\n\nInput:  [[-1,0],[0,0],[2,-1],[2,4],[3,1]]\nOutput:  5.00000\nExplanation:\nThe two line segments with the maximum sum of the lengths are represented by red line segments: [-1,0]--[0,0] and [2,-1]--[3,1].\nExample 2:\n\nInput:  [[0,0],[1,0],[2,0],[3,0],[4,0],[5,0],[6,0],[7,0]]", "groundtruth": "class Solution {public:int maxDivScore(vector<int>& nums, vector<int>& divisors) {int cnt = -1, ans = 0;for (int i = 0; i < divisors.size(); i++) {int tmp = 0;for (int j = 0; j < nums.size(); j++) {if (nums[j] % divisors[i] == 0) {tmp++;}}if (tmp > cnt || (tmp == cnt && divisors[i] < ans)) {ans = divisors[i];cnt = tmp;}}return ans;}};"}
{"task_id": "cpp/19", "content": "*/\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\nusing namespace std;\nint addMinimum(string word) {\n\tint n = word.size();\n\tvector<int> d(n + 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i >= 1 && word[i - 1] == 'c') {\n\t\t\td[i] = d[i - 1] - 1;\n\t\t}\n\t\telse if (i >= 2 && word[i - 2] == 'b') {\n\t\t\td[i] = d[i - 2] - 1;\n\t\t}\n\t\telse if (i >= 3 && word[i - 3] == 'a') {\n\t\t\td[i] = d[i - 3] - 1;\n\t\t}\n\t}\n\treturn d[n];\n}\nint main()\n{\n\tstring str;\n\tcin >> str;\n\tcout << addMinimum(str) << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}#include<iostream>\n#include<vector>\nusing namespace std;\nvector<int> findShortestSubArray(vector<int> nums)\n{\n\tint arr[50000] = { 0 };\n\tint length = 0;\n\tfor (int i = 0; i < nums.size(); i++)\n\t{\n\t\tarr[nums[i]]++;\n\t\tif (length < arr[nums[i]])\n\t\t{\n\t\t\tlength = arr[nums[i]];\n\t\t}\n\t}\n\tint result[50000] = { 0 };\n\tfor (int j = 0; j < nums.size(); j++)\n\t{\n\t\tif (length == arr[nums[j]])\n\t\t{\n\t\t\tresult[j] = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[j] = 0;\n\t\t}\n\t}\n\tint count = 0;\n\tint begin = 0, end = 0;\n\tint sum = 0;\n\tfor (int j = 0; j < nums.", "groundtruth": "class Solution {public:int addMinimum(string word) {int n = word.size();vector<int> d(n + 1);for (int i = 1; i <= n; i++) {d[i] = d[i - 1] + 2;if (i > 1 && word[i - 1] > word[i - 2]) {d[i] = d[i - 1] - 1;}}return d[n];}};"}
{"task_id": "cpp/20", "content": "'''\nclass Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        next, count = [[] for i in range(n)], [0 for i in range(n)]\n        for edge in edges:\n            next[edge[0]].append(edge[1])\n            next[edge[1]].append(edge[0])\n        def dfs(node, parent, end):\n            if node == end:\n                count[node] += 1\n                return True\n            for child in next[node]:\n                if child == parent:\n                    continue\n                if dfs(child, node, end):\n                    count[node] += 1\n                    return True\n            return False\n        for trip in trips:\n            dfs(trip[0], -1, trip[1])\n        def dp(node, parent):\n            res = [0 for i in range(2)]\n            for child in next[node]:\n                if child == parent:\n                    continue\n                x, y = dp(child, node)\n                res[0] += x\n                res[1] += min(x, y)\n            if count[node] == 1:\n                res[0] += price[node]\n            else:\n                res[1] += price[node]\n            return res\n        x, y = dp(0, -1)\n        return min(x, y)/cs61a/discussion/lecture6/homework.py\n\"\"\"Homework: Functions and Data Structures\n\nFunctions are extremely useful because they allow us to take code and put it into a reusable form. The only way to \nstore a particular piece of code in a reusable form is to name it.\n\"\"\"\n\ndef plus_1(n):\n    \"\"\"Returns n+1.\"\"\"\n    return n+1\n\nplus_1(5)\n\n\"\"\"To get the value of plus_1 we pass 5 to the function.\"\"\"\n\ndef square(n):\n    \"\"\"Returns n^2.\"\"\"\n    return n*n\n\nsquare(5)\n\n\"\"\"Here we passed 5 to square and stored the result as x.\"\"\"\n\nx = square(5)\n\n\"\"\"\n\nLet's say we want to compute the sum of the first 100 numbers. We could write out all of these plus ones:\n", "groundtruth": "class Solution {public:int minimumTotalPrice(int n, vector<vector<int>> &edges, vector<int> &price, vector<vector<int>> &trips) {vector<vector<int>> next(n);for (auto &edge : edges) {next[edge[0]].push_back(edge[1]);next[edge[1]].push_back(edge[0]);}vector<int> count(n);function<bool(int, int, int)> dfs = [&](int node, int parent, int end) -> bool {if (node == end) {count[node]++;return true;}for (int child : next[node]) {if (child == parent) {continue;}if (dfs(child, node, end)) {count[node]++;return true;}}return false;};for (auto &trip: trips) {dfs(trip[0], -1, trip[1]);}function<pair<int, int>(int, int)> dp = [&](int node, int parent) -> pair<int, int> {pair<int, int> res = {price[node] * count[node], price[node] * count[node] / 2};for (int child : next[node]) {if (child == parent) {continue;}auto [x, y] = dp(child, node);res.first += min(x, y); // node 没有减半，因此可以取子树的两种情况的最小值res.second += x; // node 减半，只能取子树没有减半的情况}return res;};auto [x, y] = dp(0, -1);return min(x, y);}};"}
{"task_id": "cpp/21", "content": "\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tint *data;\n\tint len;\n\tint capacity;\n} array_int_t;\n\nvoid array_int_init(array_int_t *arr, int capacity)\n{\n\tarr->len = 0;\n\tarr->capacity = capacity;\n\tarr->data = (int *)malloc(arr->capacity * sizeof(int));\n}\n\nvoid array_int_destory(array_int_t *arr)\n{\n\tif (arr) {\n\t\tif (arr->data) {\n\t\t\tfree(arr->data);\n\t\t\tarr->data = NULL;\n\t\t\tarr->capacity = 0;\n\t\t\tarr->len = 0;\n\t\t}\n\t}\n}\n\nbool array_int_insert(array_int_t *arr, int x)\n{\n\tif (arr->len == arr->capacity) {\n\t\tint *p = (int *)realloc(arr->data, sizeof(int) * 2 * arr->capacity);\n\t\tif (NULL == p) {\n\t\t\treturn false;\n\t\t}\n\t\tarr->data = p;\n\t\tarr->capacity *= 2;\n\t}\n\tarr->data[arr->len++] = x;\n\treturn true;\n}\n\nbool array_int_delete(array_int_t *arr, int pos)\n{\n\tif (pos < 0 || pos >= arr->len) {\n\t\treturn false;\n\t}\n\tfor (int i = pos; i < arr->len - 1; ++i) {\n\t\tarr->data[i] = arr->data[i + 1];\n\t}\n\t--arr->len;\n\treturn true;\n}\n\nstatic inline int _max(int x, int y)\n{\n\treturn x > y? x : y;\n}\n\nvoid findPrefixScore(array_int_t *arr)\n{\n\tif (arr == NULL || arr->len < 1) {\n\t\treturn;\n\t}\n\tint i;\n\tint tmp;\n\tfor (i = 0; i < arr->len; ++i) {\n\t\tif (i ==", "groundtruth": "class Solution {public:vector<long long> findPrefixScore(vector<int>& nums) {vector<long long> ans;int tmp = nums[0];ans.push_back(nums[0] * 2);for (int i = 1; i < nums.size(); ++i) {if (nums[i] > tmp) tmp = nums[i];ans.push_back(nums[i] + tmp + ans[i - 1]);}return ans;}};"}
{"task_id": "cpp/22", "content": "\n'''\n#\n# @lc app=leetcode.cn id=1614 lang=python\n#\n# [1614] 收集果子的最低开销.py\n#\n# https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/description/\n#\n# algorithms\n# Medium (30.49%)\n# Likes:    70\n# Dislikes: 0\n# Total Accepted:    4.2K\n# Total Submissions: 13.8K\n# Testcase Example:  '\"zza\"'\n#\n# 给你一个字符串 s ，每一次操作你都可以在字符串的任意位置插入任意字符。\n# \n# 请你返回使 s 成为回文串的 最少操作次数 。\n# \n# 「回文串」是正读和反读都相同的字符串。\n# \n# \n# \n# 示例 1：\n# \n# \n# 输入：s = \"zzazz\"\n# 输出：0\n# 解释：字符串 \"zzazz\" 已经是回文串了，所以不需要做任何插入操作。\n# \n# \n# 示例 2：\n# \n# \n# 输入：s = \"mbadm\"\n# 输出：2\n# 解释：字符串可变为 \"mbdadbm\" 或者 \"mdbabdm\" 。\n# \n# \n# 示例 3：\n# \n# \n# 输入：s = \"leetcode\"\n# 输出：5\n# 解释：插入 5 个字符后字符串变为 \"leetcodocteel\" 。\n# \n# \n# 示例 4：\n# \n# \n# 输入：s = \"g\"\n# 输出：0\n# \n# \n# 示例 5：\n# \n# \n# 输入：s = \"no\"\n# 输出：1\n# \n# \n# \n# \n# 提示：\n# \n# \n# 1 <= s.length <= 500\n# s 只包含小写英文字母。\n# ", "groundtruth": "class Solution {public:TreeNode* replaceValueInTree(TreeNode* root) {vector<TreeNode*> q = {root};root->val = 0;while (!q.empty()) {vector<TreeNode*> q2;int sum = 0;for (auto fa : q) {if (fa->left) {q2.push_back(fa->left);sum += fa->left->val;}if (fa->right) {q2.push_back(fa->right);sum += fa->right->val;}}for (auto fa : q) {int child_sum = (fa->left ? fa->left->val : 0) +(fa->right ? fa->right->val : 0);if (fa->left) {fa->left->val = sum - child_sum;}if (fa->right) {fa->right->val = sum - child_sum;}}q = move(q2);}return root;}};"}
{"task_id": "cpp/23", "content": "\nSample input\n5\n[[0, 1, 3], [0, 2, 1], [3, 1, 2], [3, 0, 3], [2, 4, 1], [4, 2, 1]]\nSample output\n2\n\nSample explanation\nThe graph is represented by the above figure.\n\nThe input means that there are 5 nodes and edges [[0, 1, 3], [0, 2, 1], [3, 1, 2], [3, 0, 3], [2, 4, 1], [4, 2, 1]] in the graph. After calling the graph constructor with 5 nodes and edges, the internal graph representation is like the figure above. The initial distances for all nodes are all set as INT_MAX(0x7fffffff). After calling addEdge, graph is changed as:\n\n// graph is: {1: [(1, 2), (2, 4)], 0: [(0, 2), (1, 3)], 2: [(2, 1)], 3: [(0, 3)], 4: [(3, 1)]}\n\nThe addEdge function changes graph as above:\n\n// graph is: {1: [(1, 2), (2, 4)], 0: [(0, 2), (1, 3), (0, 3)], 2: [(2, 1)], 3: [(1, 2)], 4: [(3, 1)]}\n\nNext, call the shortestPath function for node 0 and node 2 and the internal distance list is (0x7fffffff, 2, 0x7fffffff, 3, 0x7fffffff).\n\nFirst, add node 0 to the priority_queue and pop the node. After pop, the internal distance list becomes (0x7fffffff, 0x7fffffff, 0x7fffffff, 3, 0x7fffffff). Then check the distance to node 2. There is a path from node 0 to node 2 with the total cost 3 (i.e., 1 + 2). Since the cost is smaller than the current shortest path cost (i.e., 0x7fffffff), update the shortest path cost as", "groundtruth": "class Graph {public:using pii = pair<int, int>;Graph(int n, vector<vector<int>>& edges) {this->graph = vector<vector<pii>>(n);for (auto &vec : edges) {int x = vec[0];int y = vec[1];int cost = vec[2];graph[x].emplace_back(y, cost);}}void addEdge(vector<int> edge) {int x = edge[0];int y = edge[1];int cost = edge[2];graph[x].emplace_back(y, cost);}int shortestPath(int node1, int node2) {priority_queue<pii, vector<pii>, greater<pii>> pq;vector<int> dist(graph.size(), INT_MAX);dist[node1] = 0;pq.emplace(0, node1);while (!pq.empty()) {auto [cost, cur] = pq.top();pq.pop();if (cur == node2) {return cost;}for (auto [next, ncost] : graph[cur]) {if (dist[next] > cost + ncost) {dist[next] = cost + ncost;pq.emplace(cost + ncost, next);}}}return -1;}private:vector<vector<pii>> graph;};"}
{"task_id": "cpp/24", "content": "\nThe output format is as follows:\nExample 1:\nInput: nums = [5,2,4,5]\nOutput: [2,4,6,8]\nExplanation: For each value in nums we can consider a group of all j such that nums[j] == nums[i] and j!= i.\n- For nums[0] i = 0, j = 0, the blue part is of size 0.\n- For nums[1] i = 1, j = 0, the blue part is of size 1.\n- For nums[2] i = 2, j = 0 and j = 1, the blue part is of size 1 and 2 respectively.\n- For nums[3] i = 3, j = 2, the blue part is of size 2.\nThe final answer is [2, 4, 6, 8].\nExample 2:\nInput: nums = [4,2,2,4]\nOutput: [8,0,0,8]\nExplanation: For each value in nums we can consider a group of all j such that nums[j] == nums[i] and j!= i.\n- For nums[0] i = 0, j = 1 and j = 2, the blue part is of size 1 and 2 respectively.\n- For nums[1] i = 1, j = 0, the blue part is of size 0.\n- For nums[2] i = 2, j = 0 and j = 1, the blue part is of size 1 and 2 respectively.\n- For nums[3] i = 3, j = 0 and j = 2, the blue part is of size 1 and 2 respectively.\nThe final answer is [8, 0, 0, 8].\nConstraints:\n1 <= nums.length <= 105\n1 <= nums[i] <= 105\n\n#include<iostream>\n#include<vector>\nusing namespace std;\n\nvector<long long> distance(vector<int>& nums) {\nvector<long long> ans(nums.size());\nlong long pre[nums.size()];\npre[0] = 0;\nfor (int i = 0; i", "groundtruth": "class Solution {public:vector<long long> distance(vector<int> &nums) {int n = nums.size();unordered_map<int, vector<int>> groups;for (int i = 0; i < n; ++i)groups[nums[i]].push_back(i); // 相同元素分到同一组，记录下标vector<long long> ans(n);long long s[n + 1];s[0] = 0;for (auto &[_, a]: groups) {int m = a.size();for (int i = 0; i < m; ++i)s[i + 1] = s[i] + a[i]; // 前缀和for (int i = 0; i < m; ++i) {long long target = a[i];long long left = target * i - s[i]; // 蓝色面积long long right = s[m] - s[i] - target * (m - i); // 绿色面积ans[target] = left + right;}}return ans;}};"}
{"task_id": "cpp/25", "content": "Examples:\nInput: nums = [5,1,2,4,7], p = 2\nOutput: 1\nExplanation: 0-indexed pairs of indices with minimum maximum difference are: - 0 and 4, 1 and 4.\n\n(cnt >= p? right : left) = mid;是干什么用的呢？？？？？？？\n*/#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<string>\n#include<queue>\n#include<map>\n#include<cmath>\n#include<algorithm>\n#define LL long long\n#define min(x,y) (x<y?x:y)\n#define max(x,y) (x>y?x:y)\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int mod=1e9+7;\n\nstruct node\n{\n    int h;\n    int w;\n    node()\n    {\n        h=INF;\n        w=INF;\n    }\n}A[1010];\nint n,m;\n\nint main()\n{\n    int h,w,i,j;\n    scanf(\"%d%d\",&n,&m);\n    for(i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&h);\n        for(j=1;j<=h;j++)\n        {\n            scanf(\"%d\",&A[j].w);\n        }\n        A[0].h=h;\n    }\n\n    for(i=m;i>=1;i--)\n    {\n        if(i==m)\n        {\n            for(j=1;j<=m;j++)\n            {\n                A[j].h=0;\n            }\n        }\n        else\n        {\n            for(j=1;j<=m;j++)\n            {\n                A[j].h=INF;\n                for(h=j-1;h>=1;h--)\n                {\n                    if(A[h].w<A[j].w&&A[h].h+1<A[j].h)\n                    {\n                        A[j].h=A[h].h+1;\n                        A[j].w=A[h].w;\n                        break;\n                    }\n                }", "groundtruth": "class Solution {public:int minimizeMax(vector<int> &nums, int p) {sort(nums.begin(), nums.end());int left = -1, right = nums.back() - nums[0]; // 开区间while (left + 1 < right) { // 开区间int mid = left + (right - left) / 2, cnt = 0;for (int i = 0; i < nums.size() - 1; ++i)if (nums[i + 1] - nums[i] <= mid) { // 都选++cnt;++i;}(cnt >= p ? right : left) = mid;}return right;}};"}
{"task_id": "cpp/26", "content": "# Leetcode 624: Maximum Distance in Arrays\n## Easy \n<div class=\"content__u3I1 question-content__JfgR\"><p>Given <code>m</code> arrays, and each array is sorted in ascending order. Now you can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the distance between two integers <code>a</code> and <code>b</code> to be their absolute difference <code>|a - b|</code>. Your task is to find the maximum distance.\n</p>\n\n<p>\n<b>Example 1:</b><br>\n<pre>\n<b>Input:</b> \n[[1,2,3],\n [4,5],\n [1,2,3]]\n<b>Output:</b> 4\n<b>Explanation:</b> \nOne way to reach the maximum distance 4 is to pick 1 in the first or third array and pick 5 in the second array.\n</pre>\n</p>\n\n<p>\n<b>Note:</b><br>\n<ol>\n<li><code>1 &lt;= m &lt;= 10000</code></li>\n<li><code>1 &lt;= m[i].size &lt;= 10000</code></li>\n<li><code>1 &lt;= m[i][j] &lt;= 10^9</code></li>\n<li><code>1 &lt;= k &lt;= m</code></li>\n</ol>\n</p></div>\n  \n<li><code>1 &lt;= nums.length, k &lt;= 10^9</code></li>\n<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>\n</ol>\n</p></div>\n # Leetcode 1438: Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit\n## Medium \n<div class=\"content__1Y2H\">\n<p>Given an array of integers <code>nums</code> and an integer <code>k</code>,", "groundtruth": "class Solution {public:int minimumVisitedCells(vector<vector<int>>& grid) {int m = grid.size(), n = grid[0].size();vector<vector<int>> dist(m, vector<int>(n, -1));dist[0][0] = 1;vector<priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>>> row(m), col(n);auto update = [](int& x, int y) {if (x == -1 || y < x) {x = y;}};for (int i = 0; i < m; ++i) {for (int j = 0; j < n; ++j) {while (!row[i].empty() && row[i].top().second + grid[i][row[i].top().second] < j) {row[i].pop();}if (!row[i].empty()) {update(dist[i][j], dist[i][row[i].top().second] + 1);}while (!col[j].empty() && col[j].top().second + grid[col[j].top().second][j] < i) {col[j].pop();}if (!col[j].empty()) {update(dist[i][j], dist[col[j].top().second][j] + 1);}if (dist[i][j] != -1) {row[i].emplace(dist[i][j], j);col[j].emplace(dist[i][j], i);}}}return dist[m - 1][n - 1];}};"}
{"task_id": "cpp/27", "content": "\n*/\n\n#include <vector>\n#include <iostream>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> findMatrix(vector<int> &nums) {\n        unordered_map<int, int> cnt;\n        for (int x: nums) {\n            ++cnt[x];\n        }\n        vector<vector<int>> ans;\n        while (!cnt.empty()) {\n            vector<int> row;\n            for (auto it = cnt.begin(); it!= cnt.end();) {\n                row.push_back(it->first);\n                if (--it->second == 0) {\n                    cnt.erase(it++);\n                } else {\n                    ++it;\n                }\n            }\n            ans.push_back(row);\n        }\n        return ans;\n    }\n};\n\nint main() {\n    Solution s;\n    vector<int> nums = {3, 6, 7, 11};\n    vector<vector<int>> res = s.findMatrix(nums);\n    for (auto row: res) {\n        for (int x: row) {\n            cout << x << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}\n/leetcode_cpp/807_Max_Increase_to_Keep_City_Skyline.cpp\n/*\n807. Max Increase to Keep City Skyline\n\nIn a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well.\n\nAt the end, the \"skyline\" when viewed from all four directions of the grid, i.e. top, bottom, left, and right, must be the same as the skyline of the original grid. A city's skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See the following example.\n\nWhat is the maximum total sum that the height of the buildings can be increased?\n\nExample:\nInput: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,", "groundtruth": "class Solution {public:vector<vector<int>> findMatrix(vector<int> &nums) {unordered_map<int, int> cnt;for (int x: nums) ++cnt[x];vector<vector<int>> ans;while (!cnt.empty()) {vector<int> row;for (auto it = cnt.begin(); it != cnt.end();) {row.push_back(it->first);if (--it->second == 0) it = cnt.erase(it);else ++it;}ans.push_back(row);}return ans;}};"}
{"task_id": "cpp/28", "content": "Example 1:Input: reward1 = [8, 4, 6, 2, 3], reward2 = [2, 1, 3, 3, 2], k = 3Output: 6Explanation: We can choose indices 1, 2, and 4 for the first mouse, and choose indices 4, 3, and 1 for the second mouse. At the end, both mice have eaten 6 pieces of cheese.\nExample 2:Input: reward1 = [1, 3, 2, 1, 1], reward2 = [6, 6, 3, 6, 4], k = 4Output: 12Explanation: We can choose indices 0, 1, 3, and 4 for the first mouse, and choose indices 0, 2, 3, and 4 for the second mouse. At the end, both mice have eaten 12 pieces of cheese.\nConstraints:\nn == reward1.length == reward2.length\n1 <= n <= 105\n1 <= reward1[i], reward2[i] <= 10000\n1 <= k <= n\nAccepted\n6,518\nSubmissions\n13,852\n */\n\npublic class MiceAndCheese {\n    public static void main(String[] args) {\n        System.out.println(new MiceAndCheese().miceAndCheese(new int[]{8,4,6,2,3}, new int[]{2,1,3,3,2}, 3));\n        System.out.println(new MiceAndCheese().miceAndCheese(new int[]{1,3,2,1,1}, new int[]{6,6,3,6,4}, 4));\n        System.out.println(new MiceAndCheese().miceAndCheese(new int[]{1,1,1}, new int[]{1,1,1}, 3));\n    }\n    //n log n\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\n        int[] diffs = new int[reward1.length];\n        for(int i=0; i<reward1.length; i++){\n            diffs[i]", "groundtruth": "class Solution {public:int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {int ans = 0;int n = reward1.size();vector<int> diffs(n);for (int i = 0; i < n; i++) {ans += reward2[i];diffs[i] = reward1[i] - reward2[i];}sort(diffs.begin(), diffs.end());for (int i = 1; i <= k; i++) {ans += diffs[n - i];}return ans;}};"}
{"task_id": "cpp/29", "content": "Note that p and banned will both have the value of the same position.\nPlease use the following code to complete the code.\nInput:n = 5,p = 2,banned = [0,1,3],k = 1p = banned = k = 0,n = 20,p = 0,banned = [2,3,4,5,7,9,11,13,15,16,17,19]\nOutput:[-1,1,1,1,1,3,1,1,1,1,4,1,1,1,1,3,1,1,1,1]\nConstraints:\n1 <= n <= 5000\n0 <= p < n\n1 <= k <= n\n1 <= banned[i] < n\nbanned has a unique value.\nAccepted\n11,693\nSubmissions\n20,799\nThanks\nSee More\n */\n\n\n// 34\n/*\nA city was trying to create an optimal elevated connection between the two parts of the city for a company, and therefore hired you as a programmer.\nBut the city is complex and in an unstable state, so the elevated connection was not created, and the company stopped hiring you.\nThe city has N streets, numbered from 1 to N, and is represented as a rooted tree. The root of the tree is city 1. The path between each pair of cities is one street.\nThe cost of creating the connection between a pair of cities is equal to the distance between the two cities, which means the cost of creating the connection between cities x and y is equal to the number of streets on the path from x to y.\nThe two parts of the city are divided by the city n/2 (for integer division) as follows:\nThe east part consists of the cities 1 to n/2.\nThe west part consists of the cities n/2 + 1 to n.\nTo simplify things, we define the following terms:\nAn interval is a contiguous segment of streets on the path from 1 to n.\nAn unstable interval is an interval that has streets from the east part and streets from the west part, that is, an interval contains both east st", "groundtruth": "class Solution {public:vector<int> minReverseOperations(int n, int p, vector<int> &banned, int k) {unordered_set<int> ban{banned.begin(), banned.end()};set<int> sets[2];for (int i = 0; i < n; ++i)if (i != p && !ban.count(i))sets[i % 2].insert(i);sets[0].insert(n);sets[1].insert(n); // 哨兵vector<int> ans(n, -1);vector<int> q = {p};for (int step = 0; !q.empty(); ++step) {vector<int> nq;for (int i: q) {ans[i] = step;// 从 mn 到 mx 的所有位置都可以翻转到int mn = max(i - k + 1, k - i - 1);int mx = min(i + k - 1, n * 2 - k - i - 1);auto &s = sets[mn % 2];for (auto it = s.lower_bound(mn); *it <= mx; it = s.erase(it))nq.push_back(*it);}q = move(nq);}return ans;}};"}