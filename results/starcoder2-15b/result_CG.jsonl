{"task_id": "java/0", "content": "\n## input output format:\n\nThe input and output formats of the following examples are illustrated below:\n\nThe first line is n and m, which is the number of teams and number of directed edges respectively. Then m rows, each row has 2 numbers: ui, vi\n\nIn the first line of the output is a single integer: the champion team.\n\n## Sample input and output\n\n### Sample 1:\n\ninput:\n\n4 6\n\n1 0\n\n0 2\n\n2 1\n\n3 2\n\n3 1\n\n1 3\n\noutput:\n\n-1\n\n### Sample 2:\n\ninput:\n\n6 7\n\n1 0\n\n2 0\n\n3 0\n\n0 4\n\n4 5\n\n5 3\n\n5 2\n\noutput:\n\n5\n\n### Sample 3:\n\ninput:\n\n6 3\n\n2 0\n\n2 1\n\n1 0\n\noutput:\n\n-1\n\n### Sample 4:\n\ninput:\n\n7 5\n\n2 0\n\n0 1\n\n3 0\n\n0 4\n\n3 5\n\noutput:\n\n3\n\n### Sample 5:\n\ninput:\n\n7 5\n\n2 0\n\n0 1\n\n3 0\n\n0 4\n\n0 6\n\noutput:\n\n-1\n\n### Sample 6:\n\ninput:\n\n10 9\n\n1 2\n\n2 3\n\n4 0\n\n0 6\n\n6 0\n\n6 7\n\n5 6\n\n8 5\n\n8 9\n\noutput:\n\n-1\n\n## Sample explanation\n\n1. Sample 1: No team is the champion.\n\n## Tip\n\nUse the in-degree of the directed graph to determine the champion team.\n\n## Hint\n\nIn order to solve this problem quickly, you should first think about the in-degree of the directed graph: can the in-degree of the directed graph determine the champion team? If the answer is yes, then we can use Topological sorting to determine the champion team, and there is no need to write any code!\n\nJava", "groundtruth": "class Solution {    public int findChampion(int n, int[][] edges) {        int[] degree = new int[n];        for (int[] e : edges) {            degree[e[1]]++;        }        int champion = -1;        for (int i = 0; i < n; i++) {            if (degree[i] == 0) {                if (champion == -1) {                    champion = i;                } else {                    return -1;                }            }        }        return champion;    }}"}
{"task_id": "java/1", "content": "\n## Java\n\n```public class LeetCode_5508_TreeWithMaxScore {public long maximumScoreAfterOperations(int[][] edges, int[] values) {     if (null == edges || edges.length <= 1) {          return Arrays.stream(values).sum();      }      List<Set<Integer>> relations = new ArrayList<>();      for (int[] edge : edges) {          // 相邻节点的关系          relations.add(new HashSet<>(Arrays.asList(edge[0], edge[1])));      }      int length = values.length;      long[] totalValues = new long[length];      // 记录每个叶子节点到根节点上的权重总值      long[][] pathValues = new long[length][length];      // 记录节点 x 的子节点      List<Set<Integer>> subSets = new ArrayList<>();      for (int i = 0; i < length; i++) {          subSets.add(new HashSet<>());      }      // 计算子节点      for (int i = 0; i < length - 1; i++) {          relations.get(i).stream().filter(x ->!relations.get(i + 1).contains(x)).forEach(x -> {              subSets.get(x).add(i + 1);              subSets.get(i + 1).add(x);          });      }      // 总数      long max = 0;      // 记录叶子节点的权重总值      for (int i = 0; i < length; i++) {          totalValues[i] = values[i];          if (subSets.get(i).size() == 1) {              max += totalValues[i];          }      }      // 计算从每个节点到根节点的所有路径的权重总值      for (int i = 0; i < length; i++) {          for (int j : subSets.get(i)) {              // 同层节点，不需要再计算其子节点的路径              if (pathValues[i][j]!= 0) {                  continue;              }              // 记录权重总值              totalValues[j] = values[j];              long sum = totalValues[j];              for (int k : subSets.get(j))", "groundtruth": "class Solution {    public long maximumScoreAfterOperations(int[][] edges, int[] values) {        List<Integer>[] g = new ArrayList[values.length];        Arrays.setAll(g, e -> new ArrayList<>());        g[0].add(-1);         for (int[] e : edges) {            int x = e[0], y = e[1];            g[x].add(y);            g[y].add(x);        }        long ans = 0;        for (int v : values) {            ans += v;        }        return ans - dfs(0, -1, g, values);    }    private long dfs(int x, int fa, List<Integer>[] g, int[] values) {        if (g[x].size() == 1) {             return values[x];        }        long loss = 0;         for (int y : g[x]) {            if (y != fa) {                loss += dfs(y, x, g, values);             }        }        return Math.min(values[x], loss);     }}"}
{"task_id": "java/2", "content": "\nInput description:\nThere is a 3-digit array in the test case, representing the lengths of three sides of a triangle.\n\nOutput description:\nThe code is completed, and only one string that represents the type of triangle can be returned:\n\nExample 1:\nInput:\n[4,2,6]\nOutput:\n\"scalene\"\nExplanation:\nThis triangle is a scalene triangle since all its three sides have different lengths.\n\nExample 2:\nInput:\n[2,3,4]\nOutput:\n\"isosceles\"\nExplanation:\nThis triangle is an isosceles triangle since it has two sides of length 2 and 3.\n\n\nExample 3:\nInput:\n[4,5,6]\nOutput:\n\"equilateral\"\nExplanation:\nThis triangle is an equilateral triangle since all its three sides have the same length.\n\n\nExample 4:\nInput:\n[2,2,2]\nOutput:\n\"equilateral\"\nExplanation:\nThis triangle is an equilateral triangle since all its three sides have the same length.\n\n\nConstraints:\n\nnums.length == 3\n0 <= nums[i] <= 1000\n\n\nFollow up question:\nFind the error in the code, and provide the error test case.\n\nclass Solution {    public String triangleType(int[] nums) {        Arrays.sort(nums);        int x = nums[0];        int y = nums[1];        int z = nums[2];        if (x + y <= z) { // 排序后，只需比较 x+y 和 z            return \"none\";        }        if (x == z) { // 排序了，说明 y 也和 x z 相等            return \"equilateral\";        }        if (x == y) { // 排序了，说明 y 和 z 相等            return \"isosceles\";        }        return \"scalene\";    }}\n\nTime complexity: O(1)\nSpace complexity: O(1)", "groundtruth": "class Solution {    public String triangleType(int[] nums) {        Arrays.sort(nums);        int x = nums[0];        int y = nums[1];        int z = nums[2];        if (x + y <= z) { // 排序后，只需比较 x+y 和 z            return 'none';        }        if (x == z) { // 排序了，说明 y 也和 x z 相等            return 'equilateral';        }        if (x == y || y == z) {            return 'isosceles';        }        return 'scalene';    }}"}
{"task_id": "java/3", "content": "\n### Input Format\n\nA 2D array points of size n x 2 representing integer coordinates of some points on a 2D plane, where points[i] = [xi, yi].\n\n### Output Format\n\nReturn an integer that represents the number of pairs of points (A, B), where A is on the upper left side of B, and there are no other points in the rectangle (or line) they make (including the border).\n\n### Sample input 1\n\npoints = [[1, 3], [2, 2], [3, 1]]\n\n### Sample output 1\n\n2\n\n### Sample input 2\n\npoints = [[1, 1], [2, 2], [3, 3]]\n\n### Sample output 2\n\n0\n\n### Sample input 3\n\npoints = [[1, 1], [1, 3], [3, 1], [3, 3], [2, 2]]\n\n### Sample output 3\n\n4\n\n### Sample input 4\n\npoints = [[3, 2], [2, 1], [1, 4], [4, 3], [4, 1]]\n\n### Sample output 4\n\n4\n\n### Sample input 5\n\npoints = [[3, 2], [4, 2], [4, 3], [3, 4], [2, 4], [2, 3]]\n\n### Sample output 5\n\n4\n\n## hint\n\nYou can try to enumerate all pairs of points, and for each pair, check whether there are other points in the rectangle they make. If not, then this pair is valid. This approach can solve this problem, but the time complexity is O(n^2). The answer can be O(n^2). You can use this approach to pass the last three test cases.\nIn the answer, I will prove that the number of valid pairs can be solved in O(nlogn). The solution is to first sort all points by xi in ascending order. The time complexity of this step is O(nlogn). Next, for each point, we want to find the first point whose yi is less than the yi of the current point. The answer can use a binary search algorithm to find this point. Therefore, the time complexity of this step is", "groundtruth": "class Solution {    public int numberOfPairs(int[][] points) {        int pairs = 0;        Arrays.sort(points, (a, b) -> {            if (a[0] != b[0]) {                return a[0] - b[0];            } else {                return b[1] - a[1];            }        });        int n = points.length;        for (int i = 0; i < n; i++) {            for (int j = i + 1; j < n; j++) {                if (points[i][1] >= points[j][1] && isGood(points, i, j)) {                    pairs++;                }            }        }        return pairs;    }    public boolean isGood(int[][] points, int index1, int index2) {        int n = points.length;        for (int i = 0; i < n; i++) {            if (i == index1 || i == index2) {                continue;            }            if (points[i][0] >= points[index1][0] && points[i][0] <= points[index2][0] && points[i][1] >= points[index2][1] && points[i][1] <= points[index1][1]) {                return false;            }        }        return true;    }}"}
{"task_id": "java/4", "content": "\n[Python]\n\nclass Solution:    def maximumSubarraySum(self, nums, k):        ans = float('-inf')        cur_sum = 0        first_index_sum = dict()        for i, x in enumerate(nums):            if x - k in first_index_sum:                ans = max(ans, cur_sum + x - first_index_sum[x - k])            first_index_sum[x] = cur_sum            cur_sum += x        return ans if ans > float('-inf') else 0\n\n• 1\n点赞\n• 0\n收藏\n• 打赏\n• 评论", "groundtruth": "class Solution {    public long maximumSubarraySum(int[] nums, int k) {        long ans = Long.MIN_VALUE;        long sum = 0;        Map<Integer, Long> minS = new HashMap<>();        for (int x : nums) {            long s1 = minS.getOrDefault(x - k, Long.MAX_VALUE / 2);            long s2 = minS.getOrDefault(x + k, Long.MAX_VALUE / 2);            ans = Math.max(ans, sum + x - Math.min(s1, s2));            minS.merge(x, sum, Math::min);            sum += x;        }        return ans > Long.MIN_VALUE / 4 ? ans : 0;    }}"}
{"task_id": "java/5", "content": "\n### 题目背景\n\n### 题目描述\n\n给定一个只含 01 的字符串 s ，求有多少个包含 s 中所有 0 的子串中有多少个 1 。\n\n### 输入格式\n\n输入共一行，一个只含 01 的字符串 s 。\n\n### 输出格式\n\n输出共一行，表示包含 s 中所有 0 的子串中有多少个 1 。\n\n### 样例\n\n输入\n100110\n\n输出\n4\n\n输入\n00010010\n\n输出\n11\n\n输入\n0\n\n输出\n0\n\n数据范围\n字符串长度 $n \\le 10^6$\n\n### 题目来源\n\nNOIP 普及组 2020.9\n\nCodeForces 992C\n\nNOI OnlineJudge 1706/docs/algorithm/基础算法——树状数组.md\n# 树状数组\n\n## 基本内容\n\n### 结构\n\n​\t1、如果下标 $i$ 为奇数，其父结点的下标为 $(i-1)/2$，如果是偶数，则其父结点的下标为 $i/2$ 。\n\n​\t2、如果下标 $i$ 为奇数，其儿子结点的下标为 $2i+1$，如果是偶数，则其儿子结点的下标为 $2i$ 。\n\n​\t3、如果下标 $i$ 为奇数，$s$ 表示树中从当前结点到根结点的路径中所有从左边经过的结点下标，即 $s=i-1$，如果是偶数，$s=i/2$ 。\n\n​\t4、如果下标 $i$ 为奇数，从它到根结点的路径中每经过一个结点，$i$ 会一直向右儿子变 $2$ 次，如果是偶数，则会一直向左儿子变 $2$ 次。\n\n\n\n### 树状数组的实现\n\n**在查询中，对于查询 $a_i$ 的情况，假设该查询的路径上有", "groundtruth": "class Solution {    public int numberOfSubstrings(String S) {        char[] s = S.toCharArray();        int n = s.length;        int m = 0;        int[] a = new int[n + 1];        for (int i = 0; i < n; i++) {            if (s[i] == '0') {                a[m++] = i;            }        }        int tot1 = n - m;        a[m] = n; // 哨兵        int ans = 0;        int i = 0; // >= left 的第一个 0 的下标是 a[i]        for (int left = 0; left < n; left++) {            if (s[left] == '1') {                ans += a[i] - left; // 不含 0 的子串个数            }            for (int k = i; k < m; k++) {                int cnt0 = k - i + 1;                if (cnt0 * cnt0 > tot1) {                    break;                }                int cnt1 = a[k] - left - (k - i);                ans += Math.max(a[k + 1] - a[k] - Math.max(cnt0 * cnt0 - cnt1, 0), 0);            }            if (s[left] == '0') {                i++; // 这个 0 后面不会再枚举到了            }        }        return ans;    }}"}
{"task_id": "java/6", "content": "The completed code is as follows:\npublic static void main(String[] args) throws IOException {\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    String[] firstLine = br.readLine().split(\",\");\n    int X = Integer.parseInt(firstLine[0]), Y = Integer.parseInt(firstLine[1]);\n    int n = Integer.parseInt(firstLine[2]);\n    int[][] circles = new int[n][3];\n    for (int i = 0; i < n; i++) {\n        String[] input = br.readLine().split(\",\");\n        circles[i][0] = Integer.parseInt(input[0]);\n        circles[i][1] = Integer.parseInt(input[1]);\n        circles[i][2] = Integer.parseInt(input[2]);\n    }\n    System.out.println(new Solution().canReachCorner(X, Y, circles));\n}\n// 圆 i 和圆 j 相切时\nprivate Point pointInCircle(long x1, long y1, long r1, long x2, long y2, long r2) {\n    long dx = x1 - x2, dy = y1 - y2;\n    long d = (r2 - r1) / Math.hypot(dx, dy);\n    return new Point(dx * d + x1, dy * d + y1);\n}\n\nclass Point {\n    long x, y;\n\n    Point(long x, long y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\npublic static void main(String[] args) throws IOException {\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    String[] firstLine = br.readLine().split(\",\");\n    int X = Integer.parseInt(firstLine[0]), Y = Integer.parseInt(firstLine[1]);\n    int n = Integer.parseInt(firstLine[2]);\n    int[][] circles = new int[n][3];\n    for (int i = 0; i < n; i++) {\n        String[] input = br.readLine().split(\",\");\n        circles[i][0] = Integer.parseInt(input[0]);\n        circles[i][1] = Integer.parseInt(input[1]);\n        circles[i][2] = Integer.parseInt(input[2]);\n    }\n    System.out.println(new Solution", "groundtruth": "class Solution {\n    public boolean canReachCorner(int X, int Y, int[][] circles) {\n        boolean[] vis = new boolean[circles.length];\n        for (int i = 0; i < circles.length; i++) {\n            long x = circles[i][0], y = circles[i][1], r = circles[i][2];\n            if (inCircle(x, y, r, 0, 0) || // 圆 i 包含矩形左下角\n                inCircle(x, y, r, X, Y) || // 圆 i 包含矩形右上角\n                // 圆 i 是否与矩形上边界/左边界相交相切\n                !vis[i] && (x <= X && Math.abs(y - Y) <= r ||\n                            y <= Y && x <= r ||\n                            y > Y && inCircle(x, y, r, 0, Y)) && dfs(i, X, Y, circles, vis)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n    private boolean inCircle(long ox, long oy, long r, long x, long y) {\n        return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r;\n    }\n\n    private boolean dfs(int i, int X, int Y, int[][] circles, boolean[] vis) {\n        long x1 = circles[i][0], y1 = circles[i][1], r1 = circles[i][2];\n        // 圆 i 是否与矩形右边界/下边界相交相切\n        if (y1 <= Y && Math.abs(x1 - X) <= r1 ||\n            x1 <= X && y1 <= r1 ||\n            x1 > X && inCircle(x1, y1, r1, X, 0)) {\n            return true;\n        }\n        vis[i] = true;\n        for (int j = 0; j < circles.length; j++) {\n            long x2 = circles[j][0], y2 = circles[j][1], r2 = circles[j][2];\n            // 在两圆相交相切的前提下，点 A 是否严格在矩形内\n            if (!vis[j] &&\n                (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) &&\n                x1 * r2 + x2 * r1 < (r1 + r2) * X &&\n                y1 * r2 + y2 * r1 < (r1 + r2) * Y &&\n                dfs(j, X, Y, circles, vis)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"task_id": "java/7", "content": "\n*/\n/src/main/java/org/jesse/tdd/leetcode/Q859.java\npackage org.jesse.tdd.leetcode;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Q859. Buddy Strings\n *\n * Given two strings A and B of lowercase letters,\n * return true if and only if we can swap two letters in A so that the result equals B.\n *\n *\n *\n * Example 1:\n *\n * Input: A = \"ab\", B = \"ba\"\n * Output: true\n * Example 2:\n *\n * Input: A = \"ab\", B = \"ab\"\n * Output: false\n * Example 3:\n *\n * Input: A = \"aa\", B = \"aa\"\n * Output: true\n * Example 4:\n *\n * Input: A = \"aaaaaaabc\", B = \"aaaaaaacb\"\n * Output: true\n * Example 5:\n *\n * Input: A = \"\", B = \"aa\"\n * Output: false\n *\n *\n * Note:\n *\n * 0 <= A.length <= 20000\n * 0 <= B.length <= 20000\n * A and B consist only of lowercase letters.\n */\npublic class Q859 {\n\n    /**\n     *\n     * @param A\n     * @param B\n     * @return\n     *\n     *\n     * If |A|!= |B|, then there's no chance.\n     *\n     * If A==B, then check for any pair of same letter.\n     *\n     * If swap, then check whether every letter has same appearance in A and B.\n     */\n    public boolean buddyStrings(String A, String B) {\n\n        char[] a = A.toCharArray();\n        char[] b = B.toCharArray();\n        if(a.length!= b.length) return false;\n        if(a.length < 2) return false;\n\n        List<Character> l1 = new ArrayList<Character>();\n        List<Character> l2 = new ArrayList<Character>();\n        for(int i=0;i<a.length;i++){\n            if(a[i]!= b[i]) {\n                l1.add(a[i]);\n               ", "groundtruth": "class Solution {\n    public long flowerGame(int n, int m) {\n        long a = ((long)n/2) * ((long)m-((long)m/2));\n        long b = ((long)m/2) * ((long)n-((long)n/2));\n        return a + b;\n    }\n}\n"}
{"task_id": "java/8", "content": "\nPlease submit the answer within 2 seconds.\n\nPlease submit the answer within 2 seconds.\n\nJava Code:\nclass Solution {\n    public int minOrAfterOperations(int[] nums, int k) {\n        int ans = 0;\n        int mask = 0;\n        for (int b = 29; b >= 0; b--) {\n            mask |= 1 << b;\n            int cnt = 0; // 操作次数\n            int and = -1; // -1 的二进制全为 1\n            for (int x : nums) {\n                and &= x & mask;\n                if (and!= 0) {\n                    cnt++; // 合并 x，操作次数加一\n                } else {\n                    and = -1; // 准备合并下一段\n                }\n            }\n            if (cnt > k) {\n                ans |= 1 << b; // 答案的这个比特位必须是 1\n                mask ^= 1 << b; // 后面不考虑这个比特位\n            }\n        }\n        return ans;\n    }\n}/docs/solution/bishi/xiaohongshu/mianshi01.java\npublic class Main {\n\n    //输入字符串长度\n    public static int n;\n    //输入字符\n    public static char[] s;\n    //辅助变量\n    public static int[] cnt;\n    //结果\n    public static char[] ans;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] temp = br.readLine().split(\" \");\n        n = temp.length;\n        //字符数组\n        s = new char[n];\n        //每个字符的数量\n        cnt = new int[10];\n        //结果\n        ans = new char[n];\n        for(int i = 0;i < n;i++){\n            s[i] = temp[i].charAt(0);\n            cnt[s[i] - '0']++;\n        }\n        int index = 0;\n        for(int i = 0;i < 10;i++){\n            //当前字符的数量大于 0\n            while(cnt[i] > 0){\n                //如果是奇数\n                if(cnt[i] % 2!= 0){\n                    //奇数就放在中间，注意这里不是正中间\n                    ans[n/", "groundtruth": "class Solution {\n    public int minOrAfterOperations(int[] nums, int k) {\n        int ans = 0;\n        int mask = 0;\n        for (int b = 29; b >= 0; b--) {\n            mask |= 1 << b;\n            int cnt = 0; // 操作次数\n            int and = -1; // -1 的二进制全为 1\n            for (int x : nums) {\n                and &= x & mask;\n                if (and != 0) {\n                    cnt++; // 合并 x，操作次数加一\n                } else {\n                    and = -1; // 准备合并下一段\n                }\n            }\n            if (cnt > k) {\n                ans |= 1 << b; // 答案的这个比特位必须是 1\n                mask ^= 1 << b; // 后面不考虑这个比特位\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/9", "content": "If the completed code is as follows:\nclass Solution {\n    public int[] countOfPairs(int n, int x, int y) {\n        int w[][] = new int[n + 1][n + 1];\n        int INF = Integer.MAX_VALUE / 2;\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                w[i][j] = (i == j? 0 : INF);\n        if (x!= y) {\n            w[x][y] = 1;\n            w[y][x] = 1;\n        }\n        for (int i = 1; i < n; i++) {\n            w[i][i + 1] = 1;\n            w[i + 1][i] = 1;\n        }\n        for (int p = 1; p <= n; p++)\n            for (int st = 1; st <= n; st++)\n                for (int end = 1; end <= n; end++)\n                    w[st][end] = Math.min(w[st][end], w[st][p] + w[p][end]);\n        int[] res = new int[n + 1];\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                if (w[i][j]!= INF)\n                    res[w[i][j]]++;\n        int[] result = new int[n];\n        for (int i = 0; i < n; i++)\n            result[i] = res[i + 1];\n        return result;\n    }\n}\n题目：\nGiven a string S, find the number of substrings that have only 1s.\nIf the length of the given string is n, return the result modulo 109 + 7.\nNote: A substring is a contiguous sequence of characters within a string.\nThe incomplete code is as follows:\npublic static int substringCount(String s) {\n    int count = 0;\n    int n = s.length();\n    //i j 都是当前字符串的起始点，所以 i必须小于等于j,同时j必须小于n\n    for (int i = 0; i <= n; i++)", "groundtruth": "class Solution {\n    public int[] countOfPairs(int n, int x, int y) {\n        int w[][] = new int[n + 1][n + 1];\n        int INF = Integer.MAX_VALUE / 2;\n        //初始化 邻接矩阵。\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                w[i][j] = (i == j ? 0 : INF);\n        //额外的捷径的权值是1。但不能是自身到自身，因为自身到自身的权值本来就是0.\n        if (x != y) {\n            w[x][y] = 1;\n            w[y][x] = 1;\n        }\n        //建图，前后相邻 权值都是1。\n        for (int i = 1; i < n; i++) {\n            w[i][i + 1] = 1;\n            w[i + 1][i] = 1;\n        }\n        //佛洛依德算法\n        for (int p = 1; p <= n; p++)\n            for (int st = 1; st <= n; st++)\n                for (int end = 1; end <= n; end++)\n                    w[st][end] = Math.min(w[st][end], w[st][p] + w[p][end]);\n        //先用下标从0开始的数组来求结果。\n        int[] res = new int[n + 1];\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                if (w[i][j] != INF)\n                    res[w[i][j]]++;\n        //最终再遍历一次把求得的结果放到 下标从1开始的result数组。\n        int[] result  = new int[n];\n        for (int i = 0; i < n; i++)\n            result[i] = res[i + 1];\n        return result;\n    }\n}\n"}
{"task_id": "java/10", "content": "Example 1:\nInput: n = 1, x = 1, y = 1\nOutput: [1]\nExample 2:\nInput: n = 3, x = 2, y = 3\nOutput: [2,3,2]\nHint: For the first example, since x and y are the same, the only shortcut is 1-2, and the minimum number of steps to go from 1 to 1 is 0.\nFor the second example, there are six shortest paths:\n1-2-3.\n1-2-3-1.\n1-2-3-2.\n3-2-1.\n3-2-1-3.\n3-2-1-2.\nSo the minimum number of steps is 2 for three times, 3 for one time, 2 for one time.\n\n##  翻译\n\n\n## 题目解析\n\n\n## 代码\n\n```java\n\n```# 概述\n\n## 知识点\n\n- 网络的相关知识\n- IP 、ARP 、 MAC 地址的概念\n- 子网掩码、 默认网关的作用\n- 集线器、交换机的作用\n- DNS域名解析\n- NAT 网络地址转换\n- IP 地址分类\n- 端口号分类\n- UDP 和 TCP的区别\n- 三次握手和四次挥手\n- 在浏览器中输入URL到页面呈现发生了什么\n- 各种状态码的含义（2开头、3开头、4开头、5开头）\n- get 和post 的区别\n- Cookie 和 Session 的关系与区别\n\n## 参考\n\n- 图解HTTP\n\n# 网络的相关知识\n\n# IP、 ARP 、 MAC 地址的概念\n\n# 子网掩码、 默认网关的作用\n\n# 集线器、交换机的作用\n\n# DNS域名解析\n\n# NAT 网络地址转换\n\n# IP 地址分类\n\n# 端口号分类\n\n# UDP 和 TCP的区别\n\n# 三次握手和四次挥手\n\n# 在浏览器中输入URL到页面呈现发生了什么\n\n#", "groundtruth": "class Solution {\n    public int[] countOfPairs(int n, int x, int y) {\n        int w[][] = new int[n + 1][n + 1];\n        int INF = Integer.MAX_VALUE / 2;\n        \n        //初始化 邻接矩阵。\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                w[i][j] = (i == j ? 0 : INF);\n\n        //额外的捷径的权值是1。但不能是自身到自身，因为自身到自身的权值本来就是0.\n        if (x != y) {\n            w[x][y] = 1;\n            w[y][x] = 1;\n        }\n\n        //建图，前后相邻 权值都是1。\n        for (int i = 1; i < n; i++) {\n            w[i][i + 1] = 1;\n            w[i + 1][i] = 1;\n        }\n\n        //佛洛依德算法\n        for (int p = 1; p <= n; p++)\n            for (int st = 1; st <= n; st++)\n                for (int end = 1; end <= n; end++)\n                    w[st][end] = Math.min(w[st][end], w[st][p] + w[p][end]);\n\n        //先用下标从0开始的数组来求结果。\n        int[] res = new int[n + 1];\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                if (w[i][j] != INF)\n                    res[w[i][j]]++;\n\n        //最终再遍历一次把求得的结果放到 下标从1开始的result数组。\n        int[] result  = new int[n];\n        for (int i = 0; i < n; i++)\n            result[i] = res[i + 1];\n\n        return result;\n    }\n}\n"}
{"task_id": "java/11", "content": "/test_case.java\n/**\n\n@author (Andy)\n\n*/\n\nimport java.util.*;\nclass Solution {\n    public boolean canSortArray(int[] nums) {\n        int lastCnt = 0;\n        int lastGroupMax = 0;\n        int curGroupMax = 0;\n        for (int num : nums) {\n            int curCnt = Integer.bitCount(num);\n            if (curCnt == lastCnt) {\n                curGroupMax = Math.max(curGroupMax, num);\n            } else {\n                lastCnt = curCnt;\n                lastGroupMax = curGroupMax;\n                curGroupMax = num;\n            }\n            if (num < lastGroupMax) {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "groundtruth": "class Solution {\n    public boolean canSortArray(int[] nums) {\n        int lastCnt = 0;\n        int lastGroupMax = 0;\n        int curGroupMax = 0;\n        for (int num : nums) {\n            int curCnt = Integer.bitCount(num);\n            if (curCnt == lastCnt) {\n                curGroupMax = Math.max(curGroupMax, num);\n            } else {\n                lastCnt = curCnt;\n                lastGroupMax = curGroupMax;\n                curGroupMax = num;\n            }\n            if (num < lastGroupMax) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "java/12", "content": "*/\n\nclass Solution {\n    public int minimumArrayLength(int[] nums) {\n        int m = Integer.MAX_VALUE;\n        for (int x : nums) {\n            m = Math.min(m, x);\n        }\n\n        for (int x : nums) {\n            if (x % m > 0) {\n                return 1;\n            }\n        }\n\n        int cnt = 0;\n        for (int x : nums) {\n            if (x == m) {\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n}\n\n/*\nExample 1:\nInput: nums = [5,10,15,25]\nOutput: 2\nExplanation: Initially, the length of nums is 4.\nIf we choose the indices i = 1 and j = 3, the result of nums[i] % nums[j] is 0, so we insert 0 at the end of nums. Now, nums = [5,10,15,25,0].\nThe array is still unstable, but since no more operations can be performed, we must return the length of nums which is 2.\nTherefore, the minimum length of nums is 2.\nExample 2:\nInput: nums = [4,12,16]\nOutput: 1\nExplanation: There is no operation that can be performed, so we return the length of nums which is 1.\n*/\n/src/00200-00299/0290_WordPattern/README.md\n# 290. Word Pattern\n\nDifficulty: Easy\n\nhttps://leetcode.com/problems/word-pattern/\n\nGiven a `pattern` and a string `s`, find if `s` follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in `pattern` and a **non-empty word** in `s`.\n\n**Example 1:**\n```\nInput: pattern = \"abba\", s = \"dog cat cat dog\"\nOutput: true\n```\n**Example 2:**\n```\nInput: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\n```\n**Example 3:**\n```\nInput: pattern = \"aaaa\", s = \"dog", "groundtruth": "class Solution {\n    public int minimumArrayLength(int[] nums) {\n        int m = Integer.MAX_VALUE;\n        for (int x : nums) {\n            m = Math.min(m, x);\n        }\n\n        for (int x : nums) {\n            if (x % m > 0) {\n                return 1;\n            }\n        }\n\n        int cnt = 0;\n        for (int x : nums) {\n            if (x == m) {\n                cnt++;\n            }\n        }\n        return (cnt + 1) / 2;\n    }\n}\n"}
{"task_id": "java/13", "content": "\nPlease refer to the completed code and fill in the blank space above.\nPlease make sure that the main function is correct and can pass all the test cases.\n\nSample test case analysis\nTest Case\nnums: [1,2,4,5,4,6]\nk: 4\ndist: 4\nIn the above test case, the answer is 11, and the division method is as follows:\n\n[1] 2 4 5 [4] 6\n\nConsider the following example:\n\nnums: [10,1,2,4,5,4,6]\nk: 4\ndist: 4\nThere are two subarrays in nums with the same minimum value, which are nums[0..2] and nums[1..3]. The minimum cost is 10.\n\nWe can directly enumerate the cost of each subarray and find the subarray with the minimum cost, but it will cause TLE.\n\nIn order to prevent the two subarrays from becoming adjacent, we need to ensure that the number of subarrays is not more than k, and the distance between the last element of the second subarray and the first element of the third subarray is not less than dist.\n\nBecause the two subarrays cannot be adjacent, we can make the first subarray from the minimum value to dist and then make the following k - 1 subarrays from the smallest to the largest. At this time, if the subarray does not have the target length, then we can maintain the sum of the subarrays by adding and subtracting to the end, so that the sum of the subarrays is equal to the cost of the subarray. This approach has good efficiency.\n\nThere is a question in the above example. The cost of nums[0..2] is 10, but we only need to subtract 1. This is because 2 - 0 <= 4, so nums[2] can also be used as the end of nums[0..1].\n\nSpecifically, we first make the subarray of length dist + 1 (dist + 1 can be seen as the left size of the sliding window, the subarray is the content of the sliding window, and nums.length - dist is the right size of the sliding window). At this time, we record the sum of nums[0..dist], and we want", "groundtruth": "class Solution {\n    public long minimumCost(int[] nums, int k, int dist) {\n        k--;\n        sumL = nums[0];\n        for (int i = 1; i < dist + 2; i++) {\n            sumL += nums[i];\n            L.merge(nums[i], 1, Integer::sum);\n        }\n        sizeL = dist + 1;\n        while (sizeL > k) {\n            l2r();\n        }\n\n        long ans = sumL;\n        for (int i = dist + 2; i < nums.length; i++) {\n            // 移除 out\n            int out = nums[i - dist - 1];\n            if (L.containsKey(out)) {\n                sumL -= out;\n                sizeL--;\n                removeOne(L, out);\n            } else {\n                removeOne(R, out);\n            }\n\n            // 添加 in\n            int in = nums[i];\n            if (in < L.lastKey()) {\n                sumL += in;\n                sizeL++;\n                L.merge(in, 1, Integer::sum);\n            } else {\n                R.merge(in, 1, Integer::sum);\n            }\n\n            // 维护大小\n            if (sizeL == k - 1) {\n                r2l();\n            } else if (sizeL == k + 1) {\n                l2r();\n            }\n\n            ans = Math.min(ans, sumL);\n        }\n        return ans;\n    }\n\n    private long sumL;\n    private int sizeL;\n    private final TreeMap<Integer, Integer> L = new TreeMap<>();\n    private final TreeMap<Integer, Integer> R = new TreeMap<>();\n\n    private void l2r() {\n        int x = L.lastKey();\n        removeOne(L, x);\n        sumL -= x;\n        sizeL--;\n        R.merge(x, 1, Integer::sum);\n    }\n\n    private void r2l() {\n        int x = R.firstKey();\n        removeOne(R, x);\n        sumL += x;\n        sizeL++;\n        L.merge(x, 1, Integer::sum);\n    }\n\n    private void removeOne(Map<Integer, Integer> m, int x) {\n        int cnt = m.get(x);\n        if (cnt > 1) {\n            m.put(x, cnt - 1);\n        } else {\n            m.remove(x);\n        }\n    }\n}\n"}
{"task_id": "java/14", "content": "Example 1:\nInput: s = \"baba\", a = \"ba\", b = \"ab\", k = 1\nOutput: [1,2]\nExplanation: The substrings underlined are \"ba\" and \"ab\".\n- \"ba\" occurs twice at indices 1 and 2.\n  There exists j = 0 such that j = 0 and 1 <= 2 - 0 <= 1.\n  There exists j = 1 such that j = 1 and 2 - 1 <= 1.\n- \"ab\" occurs twice at indices 0 and 2.\n  There exists j = 1 such that j = 1 and 2 - 1 <= 1.\n  There exists j = 2 such that j = 2 and 0 - 2 <= 1.\nIt can be proved that no other indices are beautiful.\nExample 2:\nInput: s = \"bbbaaaabaabaabbbbababbbabbabbbababbababaababbaabbabbbaababbbaabbbbaaabbaababbaaabbabbbbaabbbaabbbababbbbabaabababaaaababbbbaabbababbaaabbaaabaababbabbbbaaaaaabbbabbbbaaaabababbabbbbaabbbababbbbaaaabaabbaaababbabaaabbabbaaabbabbbaabbaaaaaabbbbaaabbaabbaaaabbbaabbbbaabaabaaabbbbaababaaabbabababbbababaabbaabbabbaaaaaaabbbbbbababbabbabbaabaababbbaabbbbbaabaaabaabaabaabaabbabaabbbaabbbaabaabbbababbbbbaabbbbaababbbbaabbbbabaaababaaababaaabbabbaabaababbbbabaabaaaaababbbaaaabababbabbaabbaaabaaaababbbaababbaaabaabbabbaaabbbaabaaababababaabaabbbbbaaabaaabbabbbaabbabaabbaaaabaaababbaaaabbabbabababbababaabaaabbaababbbbbaaaababaaabbbbababbbaabbababbbbbbaaabbabababbabbbbaabababbbaabbbbaabbaaaaaaaababbaaabbbbabbaaabbbaabbbaabaabbabaabaabbaaabababababbbbabaabbababaabbbabaaaabbbaabbaaaaababbabaabbbababaaabaabaaabaaabbaabbaabbababbaaaabbbaaabbababbaaaabab", "groundtruth": "class Solution {\n    public List<Integer> beautifulIndices(String s, String a, String b, int k) {\n        char[] text = s.toCharArray();\n        List<Integer> posA = kmp(text, a.toCharArray());\n        List<Integer> posB = kmp(text, b.toCharArray());\n\n        List<Integer> ans = new ArrayList<>();\n        for (int i : posA) {\n            int bi = lowerBound(posB, i);\n            if (bi < posB.size() && posB.get(bi) - i <= k ||\n                bi > 0 && i - posB.get(bi - 1) <= k) {\n                ans.add(i);\n            }\n        }\n        return ans;\n    }\n\n    private List<Integer> kmp(char[] text, char[] pattern) {\n        int m = pattern.length;\n        int[] pi = new int[m];\n        int c = 0;\n        for (int i = 1; i < m; i++) {\n            char v = pattern[i];\n            while (c > 0 && pattern[c] != v) {\n                c = pi[c - 1];\n            }\n            if (pattern[c] == v) {\n                c++;\n            }\n            pi[i] = c;\n        }\n\n        List<Integer> res = new ArrayList<>();\n        c = 0;\n        for (int i = 0; i < text.length; i++) {\n            char v = text[i];\n            while (c > 0 && pattern[c] != v) {\n                c = pi[c - 1];\n            }\n            if (pattern[c] == v) {\n                c++;\n            }\n            if (c == m) {\n                res.add(i - m + 1);\n                c = pi[c - 1];\n            }\n        }\n        return res;\n    }\n\n    // 开区间写法\n    private int lowerBound(List<Integer> nums, int target) {\n        int left = -1, right = nums.size(); // 开区间 (left, right)\n        while (left + 1 < right) { // 区间不为空\n            // 循环不变量：\n            // nums[left] < target\n            // nums[right] >= target\n            int mid = (left + right) >>> 1;\n            if (nums.get(mid) < target) {\n                left = mid; // 范围缩小到 (mid, right)\n            } else {\n                right = mid; // 范围缩小到 (left, mid)\n            }\n        }\n        return right;\n    }\n}\n"}
{"task_id": "java/15", "content": "\nEnter the code in the box.\n\nTest example 1\nInput:\nk=1\nx=3\nOutput:\n3\nExplanation:\n1=>1，2=>10，3=>11，1 + 1 + 2 + 1 = 5 <= 1，The greatest cheap number is 3.\n\nTest example 2\nInput:\nk=11\nx=2\nOutput:\n10\nExplanation:\n1=>1，2=>10，3=>11，4=>100，5=>101，6=>110，7=>111，8=>1000，9=>1001，10=>1010，1 + 1 + 2 + 2 + 2 + 3 + 3 + 4 + 4 + 4 = 21 <= 11，The greatest cheap number is 10./src/com/leetCode/string/Code_1738.java\npackage com.leetCode.string;\n\npublic class Code_1738 {\n\tpublic int kthLargestValue(int[][] matrix, int k) {\n        int row = matrix.length;\n        int col = matrix[0].length;\n        int maxHeap[] = new int[k];\n        maxHeap[0] = matrix[0][0];\n        int index = 1;\n        int m = 0;\n        for (int i = 0; i < row; i++) {\n            for (int j = 0; j < col; j++) {\n                if (i == 0 && j == 0) {\n                    continue;\n                }\n                if (j == 0) {\n                    matrix[i][j] ^= matrix[i - 1][j];\n                }\n                if (i == 0) {\n                    matrix[i][j] ^= matrix[i][j - 1];\n                }\n                if (i!= 0 && j!= 0) {\n                    matrix[i][j] ^= matrix[i - 1][j] ^ matrix[i][j - 1] ^ matrix[i - 1][j - 1];\n                }\n                m = index++;\n                while (m!= 0 && maxHeap[(m - 1) / 2] < matrix", "groundtruth": "class Solution {\n    public long findMaximumNumber(long k, int x) {\n        this.x = x;\n        long left = 0;\n        long right = (k + 1) << x;\n        while (left + 1 < right) {\n            long mid = (left + right) >>> 1;\n            if (countDigitOne(mid) <= k) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n\n    private int x;\n    private long num;\n    private long memo[][];\n\n    private long countDigitOne(long num) {\n        this.num = num;\n        int m = 64 - Long.numberOfLeadingZeros(num);\n        memo = new long[m][m + 1];\n        for (long[] row : memo) {\n            Arrays.fill(row, -1);\n        }\n        return dfs(m - 1, 0, true);\n    }\n\n    private long dfs(int i, int cnt1, boolean isLimit) {\n        if (i < 0) return cnt1;\n        if (!isLimit && memo[i][cnt1] != -1) return memo[i][cnt1];\n        int up = isLimit ? (int) (num >> i & 1) : 1;\n        long res = 0;\n        for (int d = 0; d <= up; d++) {\n            res += dfs(i - 1, cnt1 + (d == 1 && (i + 1) % x == 0 ? 1 : 0), isLimit && d == up);\n        }\n        if (!isLimit) memo[i][cnt1] = res;\n        return res;\n    }\n}\n"}
{"task_id": "java/16", "content": "\nThere are 15 test cases. For 13 test cases, the solution will execute within 10 seconds. For 2 test cases, the solution will execute within 30 seconds.\n\nPlease note that this is the description of the problem, not the data. The data is generated by the solution itself.\n\nExample:\ninput: n = 3\noutput: [\"011\", \"110\", \"111\"]\ninput: n = 4\noutput: [\"0111\", \"1011\", \"1101\", \"1110\", \"1111\"]\n*/\n\n\nclass Solution {\n    public List<String> validStrings(int n) {\n        List<String> ans = new ArrayList<>();\n        int mask = (1 << n) - 1;\n        for (int i = 0; i < (1 << n); i++) {\n            int x = mask ^ i;\n            if (((x >> 1) & x) == 0) {\n                ans.add(Integer.toBinaryString((1 << n) | i).substring(1));\n            }\n        }\n        return ans;\n    }\n}/java/99-20161230/src/com/github/blind/leetcode/Solution.java\n/*\nYou are given a set of coordinates of a rectangle, which consists of two diagonally-opposed points. Each of them is represented by an integer pair {X, Y}, where X is the X coordinate and Y is the Y coordinate. The coordinates of the left upper point are {X1, Y1}, and the right bottom point is {X2, Y2}. Write a function that checks whether a point belongs to the rectangle or not.\nNote:\nEach of X1 and Y1 <= X2 and Y2.\nEach of X1, Y1, X2, Y2 >= -1000.\nThe function must return \"true\" if and only if the point belongs to the rectangle.\nThe description above is the description of the problem. There is no correct and incorrect input and output format.\nThe incomplete code is as follows:\npublic class Solution {\n    public static void main(String[] args) {\n        int x1, y1, x2, y2, x3, y3;\n        x1 =", "groundtruth": "class Solution {\n    public List<String> validStrings(int n) {\n        List<String> ans = new ArrayList<>();\n        int mask = (1 << n) - 1;\n        for (int i = 0; i < (1 << n); i++) {\n            int x = mask ^ i;\n            if (((x >> 1) & x) == 0) {\n                ans.add(Integer.toBinaryString((1 << n) | i).substring(1));\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/17", "content": "Please input the standard error as the answer.\n(For example, if the standard error is 0, then the answer is 0.)\nThe score of the test is 100 points.\n*/\n\nclass Solution {\n    public int numberOfSubmatrices(char[][] grid) {\n        int ans = 0;\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][][] sum = new int[m + 1][n + 1][2];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                sum[i + 1][j + 1][0] = grid[i][j] == 'X'? sum[i][j + 1][0] + 1 : 0;\n                sum[i + 1][j + 1][1] = grid[i][j] == 'Y'? sum[i + 1][j][1] + 1 : 0;\n                if (grid[i][j]!= '.') {\n                    ans += Math.min(sum[i + 1][j + 1][0], sum[i + 1][j + 1][1]);\n                }\n            }\n        }\n        return ans;\n    }\n}/Data Structures and Algorithms/Algorithms/LeetCode Algorithms/486. Predict the Winner.java\n/**\n * 486. Predict the Winner\n * \n * 动态规划(dp)\n * \n * 给定一个整数数组 nums，两个玩家分别从数组的两端开始，并根据数字大小进行选择，使得其和较大。判断谁的最终得分较高。\n * \n * 示例 1:\n * \n * 输入: nums = [1, 5, 2]\n * 输出: False\n * 解释: 一开始，玩家1可以从1和2中进行选择。\n * 如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。\n * 所以，玩家", "groundtruth": "class Solution {\n    public int numberOfSubmatrices(char[][] grid) {\n        int ans = 0;\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][][] sum = new int[m + 1][n + 1][2];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                sum[i + 1][j + 1][0] = sum[i + 1][j][0] + sum[i][j + 1][0] - sum[i][j][0];\n                sum[i + 1][j + 1][1] = sum[i + 1][j][1] + sum[i][j + 1][1] - sum[i][j][1];\n                if (grid[i][j] != '.') {\n                    sum[i + 1][j + 1][grid[i][j] & 1]++;\n                }\n                if (sum[i + 1][j + 1][0] > 0 && sum[i + 1][j + 1][0] == sum[i + 1][j + 1][1]) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/18", "content": "*/\n\npublic class Solution {\n    public int minimumCost(String target, String[] words, int[] costs) {\n        char[] t = target.toCharArray();\n        int n = t.length;\n\n        final int MOD = 1_070_777_777;\n        final int BASE = (int) 8e8 + new Random().nextInt((int) 1e8); // 随机 base，防止 hack\n        int[] powBase = new int[n + 1]; // powBase[i] = base^i\n        int[] preHash = new int[n + 1]; // 前缀哈希值 preHash[i] = hash(target[0] 到 target[i-1])\n        powBase[0] = 1;\n        for (int i = 0; i < n; i++) {\n            powBase[i + 1] = (int) ((long) powBase[i] * BASE % MOD);\n            preHash[i + 1] = (int) (((long) preHash[i] * BASE + t[i]) % MOD);\n        }\n\n        Map<Integer, Map<Integer, Integer>> minCost = new TreeMap<>(); // 长度 -> 哈希值 -> 最小成本\n        for (int i = 0; i < words.length; i++) {\n            long h = 0;\n            for (char b : words[i].toCharArray()) {\n                h = (h * BASE + b) % MOD;\n            }\n            minCost.computeIfAbsent(words[i].length(), k -> new HashMap<>())\n                  .merge((int) h, costs[i], Integer::min);\n        }\n\n        int[] f = new int[n + 1];\n        Arrays.fill(f, Integer.MAX_VALUE / 2);\n        f[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            for (Map.Entry<Integer, Map<Integer, Integer>> e : minCost.entrySet()) {\n                int len = e.getKey();\n                if (len > i) {\n                    break;\n                }\n                int subHash = (int) (((preHash[i] - (long) preHash[i - len] * powBase[len]) % MOD + MOD) % MOD);\n                f[i] = Math.min", "groundtruth": "class Solution {\n    public int minimumCost(String target, String[] words, int[] costs) {\n        char[] t = target.toCharArray();\n        int n = t.length;\n\n        final int MOD = 1_070_777_777;\n        final int BASE = (int) 8e8 + new Random().nextInt((int) 1e8);\n        int[] powBase = new int[n + 1];\n        int[] preHash = new int[n + 1];\n        powBase[0] = 1;\n        for (int i = 0; i < n; i++) {\n            powBase[i + 1] = (int) ((long) powBase[i] * BASE % MOD);\n            preHash[i + 1] = (int) (((long) preHash[i] * BASE + t[i]) % MOD);\n        }\n\n        Map<Integer, Map<Integer, Integer>> minCost = new TreeMap<>();\n        for (int i = 0; i < words.length; i++) {\n            long h = 0;\n            for (char b : words[i].toCharArray()) {\n                h = (h * BASE + b) % MOD;\n            }\n            minCost.computeIfAbsent(words[i].length(), k -> new HashMap<>())\n                   .merge((int) h, costs[i], Integer::min);\n        }\n\n        int[] f = new int[n + 1];\n        Arrays.fill(f, Integer.MAX_VALUE / 2);\n        f[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            for (Map.Entry<Integer, Map<Integer, Integer>> e : minCost.entrySet()) {\n                int len = e.getKey();\n                if (len > i) {\n                    break;\n                }\n                int subHash = (int) (((preHash[i] - (long) preHash[i - len] * powBase[len]) % MOD + MOD) % MOD);\n                f[i] = Math.min(f[i], f[i - len] + e.getValue().getOrDefault(subHash, Integer.MAX_VALUE / 2));\n            }\n        }\n        return f[n] == Integer.MAX_VALUE / 2 ? -1 : f[n];\n    }\n}\n"}
{"task_id": "java/19", "content": "\nExample 1:\nInput: nums = [1,2,3,4], head = [1,2,3,4]\nOutput: [2,3,4]\nExplanation: No value exists in nums that exists in the list, so we return the head of the linked list as our modified linked list.\n\nExample 2:\nInput: nums = [2,1], head = [1,2,3,4]\nOutput: [1,3,4]\nExplanation: The nodes with values 2 and 1 exist in nums, so the first two nodes are removed from the list and returned in the modified list.\n\nConstraints:\n1 <= nums.length, head.length <= 1000\n-100 <= nums[i], head.val <= 100\nBoth nums and the list are in sorted order.\n\n给定一个整数数组 nums 和链表的头节点 head，将链表中节点的值和 nums 中的元素进行比较，如果链表中的值在 nums 中存在则删除该节点。返回修改后的链表的头节点。\n\n题目分析：\n题目要求去掉和给定数组中元素相同的节点，只要用HashSet把数组中的元素存储起来，再判断HashSet中是否包含ListNode的val，如果包含就删除此节点，否则保留此节点即可。\n注意：在删除指定节点时，要把该节点的prev.next指向指定节点的next。\n*/\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode modifiedList(int[] nums, ListNode head) {\n        Set<Integer> set = new HashSet<>(nums.length); // 预分配空间\n        for (int x : nums) {\n            set.add(x);\n        }\n        ListNode dummy = new ListNode(0, head);\n        ListNode cur = dummy;\n        while (cur.next!= null) {\n            if (set.contains(cur.next.val)) {\n                cur.next = cur.next.next; // 删除\n            } else {", "groundtruth": "class Solution {\n    public ListNode modifiedList(int[] nums, ListNode head) {\n        Set<Integer> set = new HashSet<>(nums.length); // 预分配空间\n        for (int x : nums) {\n            set.add(x);\n        }\n        ListNode dummy = new ListNode(0, head);\n        ListNode cur = dummy;\n        while (cur.next != null) {\n            if (set.contains(cur.next.val)) {\n                cur.next = cur.next.next; // 删除\n            } else {\n                cur = cur.next; // 向后移动\n            }\n        }\n        return dummy.next;\n    }\n}\n"}
{"task_id": "java/20", "content": "Sample output\nEnter the values of m and n:\n3 3\nPlease enter the values of horizontalCut:\n4 4 4\nPlease enter the values of verticalCut:\n2 3 2\nThe solution is 39.\n\n\n\nimport java.util.*;\nclass MinimumCost{\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"Enter the values of m and n: \");\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        System.out.println(\"Please enter the values of horizontalCut: \");\n        int[] horizontalCut = new int[m-1];\n        for(int i=0;i<m-1;i++)\n            horizontalCut[i] = sc.nextInt();\n        System.out.println(\"Please enter the values of verticalCut: \");\n        int[] verticalCut = new int[n-1];\n        for(int i=0;i<n-1;i++)\n            verticalCut[i] = sc.nextInt();\n        MinimumCost mc = new MinimumCost();\n        System.out.println(\"The solution is \"+mc.minimumCost(m,n,horizontalCut,verticalCut));\n    }\n\n    public int minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {\n        int[][][][] dp = new int[m][n][m][n];\n        for (int i1 = 0; i1 < m; i1++) {\n            for (int j1 = 0; j1 < n; j1++) {\n                for (int i2 = 0; i2 < m; i2++) {\n                    Arrays.fill(dp[i1][j1][i2], Integer.MAX_VALUE);\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[i][j][i][j] = 0;\n            }\n        }\n        for (int rowCount = 1; rowCount <= m; rowCount++) {\n            for (int colCount = 1; colCount <= n; colCount++) {\n                for (int i1 = 0, i2 = rowCount - 1; i2 < m; i1++, i2++) {", "groundtruth": "class Solution {\n    public int minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {\n        int[][][][] dp = new int[m][n][m][n];\n        for (int i1 = 0; i1 < m; i1++) {\n            for (int j1 = 0; j1 < n; j1++) {\n                for (int i2 = 0; i2 < m; i2++) {\n                    Arrays.fill(dp[i1][j1][i2], Integer.MAX_VALUE);\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[i][j][i][j] = 0;\n            }\n        }\n        for (int rowCount = 1; rowCount <= m; rowCount++) {\n            for (int colCount = 1; colCount <= n; colCount++) {\n                for (int i1 = 0, i2 = rowCount - 1; i2 < m; i1++, i2++) {\n                    for (int j1 = 0, j2 = colCount - 1; j2 < n; j1++, j2++) {\n                        for (int midRow = i1; midRow < i2; midRow++) {\n                            dp[i1][j1][i2][j2] = Math.min(dp[i1][j1][i2][j2], horizontalCut[midRow] + dp[i1][j1][midRow][j2] + dp[midRow + 1][j1][i2][j2]);\n                        }\n                        for (int midCol = j1; midCol < j2; midCol++) {\n                            dp[i1][j1][i2][j2] = Math.min(dp[i1][j1][i2][j2], verticalCut[midCol] + dp[i1][j1][i2][midCol] + dp[i1][midCol + 1][i2][j2]);\n                        }\n                    }\n                }\n            }\n        }\n        return dp[0][0][m - 1][n - 1];\n    }\n}\n"}
{"task_id": "java/21", "content": "```java\npublic class Solution {\n    public boolean doesAliceWin(String s) {\n        int len = s.length();\n        int n = 1;\n        for (int i = 0; i < len; i++) {\n            if (s.charAt(i) == 'a' || s.charAt(i) == 'e' || s.charAt(i) == 'i' || s.charAt(i) == 'o' || s.charAt(i) == 'u') {\n                n++;\n            }\n        }\n        if (n % 2 == 0) return false;\n        else return true;\n    }\n}\n```\n\n## 945、使数组唯一的最小增量\n```\n给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。返回使 A 中的每个值都是唯一的最少操作次数。\n思路：按照思路进行代码编写，先对数组进行从小到大排序，对每一个数字进行遍历，如果比前一个数字大则不需要进行操作，直接+1，否则继续循环，将其赋值为前一个数加1即可。\n\n/**\n * 给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。返回使 A 中的每个值都是唯一的最少操作次数。\n * 思路：按照思路进行代码编写，先对数组进行从小到大排序，对每一个数字进行遍历，如果比前一个数字大则不需要进行操作，\n * 直接+1，否则继续循环，将其赋值为前一个数加1即可。\n */\nclass Solution {\n    public int minIncrementForUnique(int[] A) {\n        int size = A.length;\n        if (size < 1) return 0;\n        //从小到大排序\n        Arrays.sort(A);\n        int res = 0, j = 0;\n        //循环\n        for (int i = 1; i < size; i++) {\n            //如果比前一个数字大则不需要进行操作，直接+1\n            if (A[i] <= A[j]) {\n                res += A[j] + 1 - A[i];\n                A[i] = A[j] + 1;\n            }\n            j", "groundtruth": "class Solution {\n    public boolean doesAliceWin(String s) {\n        for (char c : s.toCharArray()) {\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"task_id": "java/22", "content": "Please copy the completed code after the following complete information:\n*/\n\nclass Solution {\n    public int maxOperations(String S) {\n        char[] s = S.toCharArray();\n        int ans = 0;\n        int cnt1 = 0;\n        for (int i = 0; i < s.length; i++) {\n            if (s[i] == '1') {\n                cnt1++;\n            } else if (i > 0 && s[i - 1] == '1') {\n                ans += cnt1;\n            }\n        }\n        return ans;\n    }\n}\n/src/test/java/com/daphile/LeetCode/algorithm/leetcode/editor/cn/[1319]连通网络的操作次数-connectivity-of-nodes.java\npackage com.daphile.LeetCode.algorithm.leetcode.editor.cn;\n\nimport org.junit.Test;\n\npublic class ConnectivityOfNodes {\n\n    @Test\n    public void test() {\n        Solution solution = new Solution();\n        solution.makeConnected(6, new int[][]{});\n    }\n\n    /*\n[1319] 连通网络的操作次数\n请你计算并返回使所有节点都连通的最少操作次数。若不可行则返回 -1 。\n操作步骤如下：\n删除连通网络中的一条边，连通性可能会发生改变。\n选择一个节点，并将与它连接的边进行删改，使得所有不是该节点的组件都成为树（即剩余组件中每个节点都与该组件中的一个节点连通，但不与其他的组件中的节点连通）。\n将所有组件变成某一组件中的节点。\n题目保证可以实现上述操作。\n示例 1：\n输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]\n输出：2\n示例 2：\n输入：n = 5, connections = [[0,1],[0,2],[3,4],[2,3]]\n输出：0\n提示：\n1 <= n <= 10^5\n1 <= connections.length <= min(n*(n-1)/2, 10^5)\nconnections[i].length == 2\n0 <= connections[i][0], connections[i", "groundtruth": "class Solution {\n    public int maxOperations(String S) {\n        char[] s = S.toCharArray();\n        int ans = 0;\n        int cnt1 = 0;\n        for (int i = 0; i < s.length; i++) {\n            if (s[i] == '1') {\n                cnt1++;\n            } else if (i > 0 && s[i - 1] == '1') {\n                ans += cnt1;\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/23", "content": "\nThe test case is as follows:\n[1,2,3,4]\n[2,3,4,5]\n[3,1,1,2]\n[4,4]\n[1,1,1,1]\n[3,4,5,6]\n[100,99,98,97]\n[100,99,98,97]\n\nThe expected result is as follows:\n1\n6\n6\n0\n1337\n0\n401\n401\n```\nt.next!= nil && head!= nil {\n\t\tstart = start.next\n\t\thead = head.next\n\t}\n\tif start.next!= nil {\n\t\tstart = start.next\n\t} else {\n\t\treturn\n\t}\n\n\tvar pre = start\n\tfor start.next!= nil {\n\t\tif start.Val == n {\n\t\t\tpre.Next = start.Next\n\t\t\tstart.Next = nil\n\t\t\tbreak\n\t\t}\n\t\tpre = start\n\t\tstart = start.Next\n\t}\n\tif start.Val == n {\n\t\tpre.Next = start.Next\n\t}\n}\n/algorithms/removeNthFromEnd.go\npackage algorithms\n\nimport \"leetcode-golang/types\"\n\n/*\n19. Remove Nth Node From End of List\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/\nGiven the head of a linked list, remove the nth node from the end of the list and return its head.\n*/\n\nfunc removeNthFromEnd(head *types.ListNode, n int) *types.ListNode {\n\tvar s = []*types.ListNode{nil, head}\n\tvar index int\n\tfor index = 0; head!= nil; index++ {\n\t\tif index >= n {\n\t\t\ts[0] = s[1]\n\t\t}\n\t\tif index > n {\n\t\t\ts[0] = s[0].Next\n\t\t}\n\t\ts[1] = head\n\t\thead = head.Next\n\t}\n\tif s[0] == nil {\n\t\treturn s[1].Next\n\t}\n\ts[0].Next = s[0].Next.", "groundtruth": "class Solution {\n    public long minimumOperations(int[] nums, int[] target) {\n        long s = target[0] - nums[0];\n        long ans = Math.abs(s);\n        for (int i = 1; i < nums.length; i++) {\n            int k = (target[i] - target[i - 1]) - (nums[i] - nums[i - 1]);\n            if (k > 0) {\n                ans += s >= 0 ? k : Math.max(k + s, 0);\n            } else {\n                ans -= s <= 0 ? k : Math.min(k + s, 0);\n            }\n            s += k;\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/24", "content": "\nInput: l = 4, r = 4\n\nOutput: 3\n\nExplanation: There are 4 numbers between 4 and 4 inclusive.\nThe only number is 4. No divisor of 4 is 2.\n\nInput: l = 10, r = 10\n\nOutput: 1\n\nExplanation: There are 1 number between 10 and 10 inclusive.\n10 has only 1 divisor, 10.\n\nInput: l = 5, r = 10\n\nOutput: 5\n\nExplanation: There are 6 numbers between 5 and 10 inclusive.\n5, 6, 7, 8, 9, and 10 have 0 special divisors.\n\nInput: l = 1000000, r = 1500000\n\nOutput: 990000\n\nLimits\n\nTime limit: 10X normal.\nMemory Limit: 256MB\n\n```java\npublic static void main(String[] args) {\n    int l = 4;\n    int r = 4;\n    int res = new Solution().nonSpecialCount(l,r);\n    System.out.println(res);\n}\n\nstatic class Solution {\n    private static final int MX = 31622;\n    private static final int[] PI = new int[MX + 1];\n\n    static {\n        for (int i = 2; i <= MX; i++) {\n            if (PI[i] == 0) {\n                PI[i] = PI[i - 1] + 1;\n                for (int j = i * i; j <= MX; j += i) {\n                    PI[j] = -1;\n                }\n            } else {\n                PI[i] = PI[i - 1];\n            }\n        }\n    }\n\n    public int nonSpecialCount(int l, int r) {\n        return r - l + 1 - PI[r] + PI[l - 1];\n    }\n}\n```\n\n## 1592 字符串处理\n\n<https://atcoder.jp/contests/abc243/tasks/abc243_e>\n\n字符串处理\n时间限制: 2sec /", "groundtruth": "class Solution {\n    private static final int MX = 31622;\n    private static final int[] PI = new int[MX + 1];\n\n    static {\n        for (int i = 2; i <= MX; i++) {\n            if (PI[i] == 0) { // i 是质数\n                PI[i] = PI[i - 1] + 1;\n                for (int j = i * i; j <= MX; j += i) {\n                    PI[j] = -1; // 标记 i 的倍数为合数\n                }\n            } else {\n                PI[i] = PI[i - 1];\n            }\n        }\n    }\n\n    public int nonSpecialCount(int l, int r) {\n        return r - l + 1 - (PI[(int) Math.sqrt(r)] - PI[(int) Math.sqrt(l - 1)]);\n    }\n}\n"}
{"task_id": "python/0", "content": "\nTest case:\nneighborSum = NeighborSum([[1,2,3],[3,4,5],[5,6,7]])\nprint(neighborSum.adjacentSum(1))\nprint(neighborSum.diagonalSum(1))\n\nExpected output:\n26\n15\n\n## Question 10 [Python]\n\nGiven a number n, if the n-th Fibonacci number is even, return true. Otherwise, return false.\nThe Fibonacci number is defined as follows:\n\nf(0) = 0\nf(1) = 1\nf(n) = f(n-1) + f(n-2) for any n > 1\nThe description of the question is shown above, and the description is as follows:\n\ndef fibo(n):\n    # code goes here\n\nInput description:\nn is a positive integer and does not exceed 1000.\nOutput description:\nReturn true if the n-th Fibonacci number is even, otherwise return false.\n\nExample:\nfibo(0) -> 0\nfibo(1) -> 1\nfibo(10) -> 55\n\n## Question 11 [Python]\n\nGiven a 32-bit signed integer, reverse digits of an integer.\n\nNote: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.\n\nPlease fill in the following incomplete code according to the description. The description is as follows:\n\nclass Solution:\n    def reverse(self, x: int) -> int:\n        # code goes here\n\nGive only the completed code. Do not output any additional information.\n\nTest case:\nprint(Solution().reverse(123))\nprint(Solution().reverse(-123))\nprint(Solution().reverse(210))\nprint(Solution().reverse(-210))\n\nExpected output:\n321\n-321\n12\n-21\n/Question6 [JavaScript].md\n# Given a string s, return the longest palindromic substring in s.\n\n\n\n## Example:", "groundtruth": " DIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n    "}
{"task_id": "python/1", "content": "\"\"\"\nDIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i+dx, j+dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n\n\ntest1 = neighborSum([[5, 2, 9, 11, 10, 14, 5, 12], [8, 3, 14, 2, 5, 10, 2, 7], [9, 2, 12, 12, 11, 12, 10, 13], [11, 10, 14, 7, 11, 14, 13, 10], [1, 11, 6, 11, 4, 11, 7, 12], [2, 12, 9, 13, 14, 7, 10, 9], [11, 1, 10, 10, 11, 11, 12, 14], [13, 14, 8, 13, 1, 10, 12, 14]])\nprint(test1.adjacentSum(7))\nprint(test1.diagonalSum(13))\n\n\n\"\"\"\nYou are given a 0-indexed binary string s consisting of only", "groundtruth": " DIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n "}
{"task_id": "python/2", "content": "\nExample 1:\nInput: grid = [[3,1], [4,0]]\nOutput: [5,4]\nExplanation: \nThe diagram above shows the number of adjacent neighbors for each element in the grid. The number of diagonal neighbors for each element in the grid is the same as the number of adjacent neighbors.\nThe neighborSum object is initialized with the grid.\nThe diagonalSum method is called with value = 3 and returns 0 + 1 + 1 + 0 = 2.\nThe diagonalSum method is called with value = 1 and returns 3 + 0 + 0 + 4 = 7.\n\nExample 2:\nInput: grid = [[1,1,1], [1,1,1], [1,1,1]]\nOutput: [8,8]\nExplanation: \nThe diagram above shows the number of adjacent neighbors for each element in the grid. The number of diagonal neighbors for each element in the grid is the same as the number of adjacent neighbors.\nThe neighborSum object is initialized with the grid.\nThe diagonalSum method is called with value = 1 and returns 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 = 8.\nThe diagonalSum method is called with value = 1 and returns 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 = 8.\n\nConstraints:\nn == grid.length == grid[i].length\n2 <= n <= 100\n0 <= grid[i][j] < n2\ngrid contains distinct elements.\nAt most 5000 calls are made to adjacentSum and diagonalSum.\n\"\"\"\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(", "groundtruth": " DIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n  "}
{"task_id": "python/3", "content": "The main function has been written.\n\nTest example:\nThere are several test cases, and the incomplete code is required to process them one by one.\nExample 1:\nInput: n = 3, queries = [[0,2],[2,2]]\nOutput: [2,1]\nExplanation: In the first query we add a road from city 0 to city 2, the distance between city 0 and city 2 is 2. In the second query the road between city 2 and city 2 has been added, thus there is only one way to get to city 2 from city 0 via this road and the distance is 1.\nExample 2:\nInput: n = 3, queries = [[0,2],[0,2],[0,2]]\nOutput: [2,1,0]\nExplanation: The distance from city 0 to city 2 in this case is 2 in the first query, and then 1 in the second and then 0 in the last.\nExample 3:\nInput: n = 3, queries = [[0,1],[1,2],[2,0],[0,1]]\nOutput: [1,2,3,1]\nExample 4:\nInput: n = 5, queries = [[1,0],[1,2],[0,2],[1,3]]\nOutput: [1,1,3,2]\n\nRelated topic: graph; search;\n\n@Author: Sivan\n\"\"\"\n\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[] for _ in range(n)]\n        vis = [0] * n\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y]!= i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n  "}
{"task_id": "python/4", "content": "\"\"\"\n/Python3/Array/1040. Move Stone Until Consecutive II/Solution.py\n# Copyright (c) 2019. All rights reserved.\n\"\"\"\nDescription\nThere are some stones in different positions along an axis - axis x.\nYou are given an integer array stones where stones[i] is the position of the ith stone.\nCall a stone an endpoint stone if it has the smallest or largest position.\nFrom a stone, you can move to an endpoint stone in the following way:\nIf the stone's position is x, it can only be moved to x - 1 and x + 1.\nThis move consumes 1 unit of energy.\nYou need to find out the smallest number of units of energy you need to spend to move all the stones to an endpoint stone.\n\nExample\nInput: [5,4,9]\nOutput: 2\nExplanation:\nWe can move the stones as follows 5 -> 4 -> 6 -> 9 or 5 -> 6 -> 4 -> 9 from stone 5 and stone 9. The total cost is 2.\n\nInput: [4,2,9,7,2,5]\nOutput: 3\nExplanation:\nWe can move the to an endpoint stone as follows 2 -> 7 -> 9 -> 2 -> 5 or 2 -> 5 -> 9 -> 7 -> 2 from stone 2 and stone 2. The total cost is 3.\n\"\"\"\nimport collections\n\n\nclass Solution:\n    \"\"\"\n    @param stones: a list of stones' positions in sorted order\n    @return: return a integer the minimum cost of shifting all stones until they are in consecutive position\n    \"\"\"\n\n    def minimumStone(self, stones):\n        ans, stk = 0, []\n        # 利用栈寻找最左最右边界, 从而找到消耗的最小花费\n        for x in stones + [float('inf')]:\n            while stk and x > stk[-1][0]:\n                k, y = stk.pop()\n                # ans 记录消耗的最小花费\n                ans = max(ans, x - y - 1 - k)\n            if stk and x == stk[-1][0]:\n               ", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n "}
{"task_id": "python/5", "content": "\nExample 1:\n\nEnter n = 3, queries = [[0,1],[1,2],[0,2]]\nReturn [3,5,7]\nExplanation: the graph is as follows:\ngraph0\nAfter querying [0,1] we have the graph:\ngraph1\nAfter querying [1,2] we have the graph:\ngraph2\nAfter querying [0,2] we have the graph:\ngraph3\nThe shortest distance from node 0 to node 2 is 3 in graph 1, and we return 3 after the first query;\nThe shortest distance from node 0 to node 2 is 5 in graph 2, and we return 5 after the second query;\nThe shortest distance from node 0 to node 2 is 7 in graph 3, and we return 7 after the third query.\nExample 2:\n\nEnter n = 2, queries = [[0,1]]\nReturn [1]\nExplanation: the graph is as follows:\ngraph\nThe shortest distance from node 0 to node 1 is 1, and we return 1 after the first query.\n\nRestrictions:\n\n1 <= n <= 500\nqueries.length == n - 1\n0 <= queries[i][0], queries[i][1] < n\nqueries[i][0]!= queries[i][1]\nYou can create any number of edges.\nIt is guaranteed that there is a way to go from city 0 to city n - 1.\n\"\"\"\nimport sys, os\nfrom typing import List\nfrom collections import deque, Counter, defaultdict, OrderedDict\nfrom math import sqrt, hypot, factorial, pi, sin, cos, radians, tan, asin\nfrom itertools import permutations, combinations, product, accumulate\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef S_MAP(): return map(str, input().split())\ndef LIST(): return list", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n "}
{"task_id": "python/6", "content": "\nThe correct code is as follows:\n class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt]!= rt:\n                rt = fa[rt]\n            while fa[x]!= rt:\n                fa[x], x = rt, x\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n#!/usr/bin/python3\n#-*- coding: utf-8 -*-\n# @time  : 10/20/20 9:28 PM\n# @Author: \n# @Email : \n\nimport math\nn=math.sqrt(5)\nprint(n)\nprint(n%1)\nclass UnionFind:\n    def __init__(self, n):\n        # 构建并查集，每个元素的父结点就是自己\n        self.parents = list(range(n))\n        self.size = [1] * n\n\n    def find(self, x):\n        # 若元素x的父结点不等于它自己，说明x不是根结点，需要将x更新为它父结点所在集合的根结点\n        if self.parents[x]!= x:\n            self.parents[x] = self.find(self.parents[x])\n        # 返回x所在集合的根结点\n        return self.parents[x]\n\n    def union(self, x, y):\n        # 找到x和y所在集合的根结点\n        rx, ry = self.find(x), self.find(y)\n        # 小集合合并到大集合\n        if self.size[rx] < self.size[ry]:\n            self.parents[rx] = ry\n            self.size[ry] += self.size[rx]\n        else:\n            self.parents[ry] = rx", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/7", "content": "'''\nimport collections\n\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt]!= rt:\n                rt = fa[rt]\n            while fa[x]!= rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(l)\n            i = l\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans'''\nYou are given the preorder traversal of a binary search tree of unique values, you need to construct this binary tree. You are allowed to write the completed code and use standard input and output to print the answers.\nThe incomplete code is as follows:\nclass Solution:\n    def buildTree(self, preorder: List[int]) -> TreeNode:\n        if len(preorder) == 0:\n            return None\n\n        root = TreeNode(preorder[____])\n        lt = ____\n        for i in range(1, len(preorder)):\n            if preorder[i] > root.val:\n                lt = i\n                break\n        root.left = ____\n        root.right = ____\n        return root\n\nGive only the completed code. Do not output any additional information.\n'''\nimport collections\n\n\nclass Solution:\n    def buildTree(self, preorder: List[int]) -> TreeNode:\n        if len(preorder) == 0:\n            return None\n\n        root = TreeNode(preorder[0])\n        lt = 0\n        for i in range(1, len(preorder)):\n            if preorder[i] > root.val:\n                lt = i\n                break\n        root.left = self.buildTree(preorder[1:lt])\n        root.right = self.buildTree(preorder[lt:])\n        return root'''\nYou are given a positive integer n representing the total number of cities of the country. Your task is to construct a complete undirected graph which contains", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/8", "content": "\n''''''\n\n链接：https://ac.nowcoder.com/acm/contest/9636/D\n来源：牛客网\n\n给定两个整数 n 和 m 。 0 \\leq n,m \\leq 100000 。要求从数列 a=[a1,a2,...,an,am] 中找出一个子序列，使得这个子序列不管删除、移动位置还是不变，得到的最大值最小。输出这个最小值。\n\n样例解释\n可以选出这样一个子序列：[2,10,2,10]。删除两个2，2和10都不变。得到的最大值是10。\n\n数据范围\n0 \\leq n,m \\leq 100000 ：\n30%的数据：0 \\leq n,m \\leq 10000\n100%的数据：0 \\leq n,m \\leq 100000\n\n输入描述:\n第一行有两个正整数 n 和 m。\n\n第二行有 n 个数，即 a_1,a_2,...,a_n 。\n\n第三行有 m 个数，即 b_1,b_2,...,b_m 。\n\n输出描述:\n输出仅一行，一个数，即答案。\n\n示例1\n输入\n4 4\n2 4 2 10\n10 2 3 8\n输出\n10\n'''\ndef func():\n    # write your code here\n    import sys\n    n, m = map(int, sys.stdin.readline().strip().split())\n    a = list(map(int, sys.stdin.readline().strip().split()))\n    b = list(map(int, sys.stdin.readline().strip().split()))\n    print(max(a+b))\n    return\nfunc()'''\n1094. 拼车\n假设你是一位顺风车司机，车上最初有 capacity 个空座位可以用来载客。由于道路的限制，车只能向一个方向行驶（也就是说，不允许掉头或改变方向，你可以将其想象为一个向量）。\n\n这儿有一份乘客行程计划表 trips", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/9", "content": "You are required to submit the code to the corresponding problem on LeetCode.\n'''\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n    \n    \n# 1240.铺瓷砖(Hard)\n'''", "groundtruth": " from sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/10", "content": "\nThe code is completed and the result is as follows:\n from sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n,", "groundtruth": " from sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/11", "content": "'''/exam-final/python-final-19-zixing-10.py\n#!/usr/bin/env python3\n\n'''\nPython题目19:\n将两个一维数组按升序合并并去重\n\nGiven only the completed code. Do not output any additional information.\n'''\n\nclass Solution:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n    def func(self):\n        c = self.a + self.b\n        res = sorted(set(c))\n        return res\n\nif __name__ == \"__main__\":\n    a = [1, 3, 5, 7]\n    b = [2, 4, 5, 7, 8]\n    sol = Solution(a, b)\n    print(sol.func())/exam-practice/exam-20220729-1.py\n#!/usr/bin/env python3\n\n'''\nPython题目1:\n题目描述：有n个人围成一圈，依次标号0, 1,..., n - 1。第i个人的编号为i，每秒钟有一个整数的随机选择，然后向其左手和右手的人传递该随机数。如果某个时刻第i个人收到的两个数字相同，则第i个人会立即停止传递，并且永远为静止。第0个人的左手和右手的人分别为n-1和1；第n-1个人的左手和右手的人分别为n-2和0。请按收敛时间排序所有人的编号。如果收敛时间相同，则按照其初始编号升序排序。收敛时间为第i个人停止传递的时刻（从第1个时刻开始编号）。请输出有序的数组。\n\n请填写答案：\n给出一个包含n个整数的数组，如果每个数的下标与数值都满足：对于所有的x（x!=y), A[y]%x!= A[x]%y 就成立，那么输出true，否则输出false。\n'''\ndef func(n):\n    res = []\n    for i in range(n):\n        res.append(i)\n    return res\n\nprint(func(10))", "groundtruth": " from sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/12", "content": "You have to complete the two parts of the blank in the code.class Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        single=0\n        double=0\n        for it in nums:\n            if it>=10: \n                double+=1\n            else:\n                single+=1\n        \n        return single!=doubleGiven an integer array nums of size n, return the minimum number of moves required to obtain an array where nums[i] = i for all i from 0 to n - 1.\nIn one move, you may increment the value of any element in the array by 1.\n\nExample 1:\nInput: nums = [0,1,3,4,5]\nOutput: 2\n\nExplanation: Increment the values of nums at index 0 and 2 to make nums = [1,2,4,5,6].\nAll the elements are now equal to their index in the array. Therefore, 2 moves were required.\n\nExample 2:\nInput: nums = [1,2,3,4,5]\nOutput: 5\n\nExplanation: Increment the values of all indices in the array to make nums = [2,3,4,5,6].\nAll the elements are now equal to their index in the array. Therefore, 5 moves were required.\n\nExample 3:\nInput: nums = [1,1,0,1]\nOutput: 3\n\nExample 4:\nInput: nums = [0,3,2,1]\nOutput: 0\n\nConstraints:\nn == nums.length\n1 <= nums.length <= 105\n-109 <= nums[i] <= 109The example of input output for the problem is as follows:\nInput:\nnums = [0,1,3,4,5]\nOutput:\n2The example of input output for the problem is as follows:\nInput:\nnums = [1,2,3,4,5]\nOutput:\n5The example of input output for the problem is as follows:\nInput:\nnums = [1,1,0,1]\nOutput:\n3The example of input output for the problem is as follows:\nInput:\nnums = [0,3,2,1]\nOutput:\n0## Complete the", "groundtruth": " class Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        single=0\n        double=0\n        for it in nums:\n            if it>=10: \n                double=double+it \n            else:\n                single=single+it  \n        \n        return single !=double\n "}
{"task_id": "python/13", "content": "Input Format:\nEnter the value of l and r, respectively.\nOutput Format:\nThere is one output of one line.\nPrint the answer according to the description.\n\nSample 1\nInput:\n1\n1000\nOutput:\n327\n\nSample 2\nInput:\n6\n20\nOutput:\n10\n\"\"\"\nimport math\n\ndef isqrt(n):\n    return int(math.sqrt(n))\n\nMX = 31622\npi = [0] * (MX + 1)\nfor i in range(2, MX + 1):\n    if pi[i] == 0:  # i 是质数\n        pi[i] = pi[i - 1] + 1\n        for j in range(i * 2, MX + 1, i):\n            pi[j] = -1  # 标记 i 的倍数为合数\n    else:\n        pi[i] = pi[i - 1]\n\nn = int(input())\nm = int(input())\nprint(m - n + 1 - (pi[isqrt(m)] - pi[isqrt(n - 1)]))\neak\n        if not b:\n            break\n        a, b = b, a % b\n    return a\n\n\nprint(gcd_recursive(21, 35))\nprint(gcd_recursive(119, 247))\nprint(gcd_recursive(1001, 1000))\nprint(gcd_recursive(3, 6))\nprint(gcd_recursive(42, 56))\n# coding:utf-8\n#usr/bin/python3\n\n\"\"\"\n最大公约数: Greatest Common Divisor\n    12 = 2 * 2 * 3\n    20 = 2 * 2 * 5\n    24 = 2 * 2 * 2 * 3\n\n\"\"\"\n\n\ndef gcd(m, n):\n    while n:\n        m, n = n, m % n\n    return m\n\n\nprint(gcd(21, 35))\nprint(gcd(119, 247))\nprint(gcd(1001, 1000))\n", "groundtruth": " MX = 31622\npi = [0] * (MX + 1)\nfor i in range(2, MX + 1):\n    if pi[i] == 0:  # i 是质数\n        pi[i] = pi[i - 1] + 1\n        for j in range(i * i, MX + 1, i):\n            pi[j] = -1  # 标记 i 的倍数为合数\n    else:\n        pi[i] = pi[i - 1]\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        return r - l + 1 - (pi[isqrt(r)] - pi[isqrt(l - 1)])\n"}
{"task_id": "python/14", "content": "Answer:\nMX = 31622\npi = [0] * (MX + 1)\nfor i in range(2, MX + 1):\n    if pi[i] == 0:  # i 是质数\n        pi[i] = pi[i - 1] + 1\n        for j in range(i * i, MX + 1, i):\n            pi[j] = -1  # 标记 i 的倍数为合数\n    else:\n        pi[i] = pi[i - 1]\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        return pi[r] - pi[l - 1]\n\n\nif __name__ == '__main__':\n    solu = Solution()\n    print(solu.nonSpecialCount(1, 10))\n    print(solu.nonSpecialCount(3, 6))\n    print(solu.nonSpecialCount(3, 12))\n    print(solu.nonSpecialCount(6434, 8880))\n    print(solu.nonSpecialCount(31415, 92653))\n    print(solu.nonSpecialCount(58815, 68583))\n\n```\n\n### 方法一\n首先，枚举 i 是否是质数，如果是，pi[i] = pi[i-1] + 1，否则 pi[i] = pi[i-1]。然后，枚举合数 j ，标记 pi[j] = -1。最后，返回 pi[r] - pi[l-1] 即可。\n\n\nPython Code:\n```python\nMX = 31622\npi = [0] * (MX + 1)\nfor i in range(2, MX + 1):\n    if pi[i] == 0:  # i 是质数\n        pi[i] = pi[i - 1] + 1\n        for j in range(i * i, MX + 1, i):\n            pi[j] = -1  # 标记 i 的倍数为合数\n    else:\n        pi[i] = pi[i - 1]\n\nclass Solution:\n    def nonSpecialCount", "groundtruth": " MX = 31622\npi = [0] * (MX + 1)\nfor i in range(2, MX + 1):\n    if pi[i] == 0:  # i 是质数\n        pi[i] = pi[i - 1] + 1\n        for j in range(i * i, MX + 1, i):\n            pi[j] = -1  # 标记 i 的倍数为合数\n    else:\n        pi[i] = pi[i - 1]\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        return r - l + 1 - (pi[isqrt(r)] - pi[isqrt(l - 1)])\n "}
{"task_id": "python/15", "content": "You can submit this problem to judge directly from the platform.\nYou can submit this problem to judge directly from the platform.\n'''\n\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b =='0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    s = \"101110101\"\n    print(sol.numberOfSubstrings(s))\n\n/contest/LeetCodeWeeklyContest-198/5462.py\n'''\n5462. 最多 K 次交换相邻数位后得到的最小整数（中等）\n小扣注意到秋日市集上有一个创作幻方的摊位。\n幻方是指由 0-1 共 2 个数字组成的 N x N 矩阵，其中每一行皆由 0-1 两数字组成，且每一行的 0-1 数各不相同。\n小扣最开始拥有数字 0，且希望能利用秋日市集上创作的幻方（n 为偶数）完成一个数字「0」到数字「N*N - ", "groundtruth": " class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n "}
{"task_id": "python/16", "content": "\nSample input 1:\n100010\n\nSample output 1:\n9\n\nSample input 2:\n11011001\n\nSample output 2:\n14\n\"\"\"\n\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k + 1] - a[k] - cnt0\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n\n\nif __name__ == '__main__':\n    pass\n\"\"\"\n477. Total Hamming Distance\nhttps://leetcode.com/problems/total-hamming-distance/\n\nThe Hamming distance between two integers is the number of positions at which the corresponding bits are different.\nGiven an integer array nums, return the sum of Hamming distances between all the pairs of the integers in nums.\nExample 1:\n\nInput: nums = [4,14,2]\nOutput: 6\nExplanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just\nshowing the four bits relevant in this case).\nThe answer will be:\nHammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(1", "groundtruth": " class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n    "}
{"task_id": "python/17", "content": "The correct and complete code is as follows:\n\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += (a[k] - left - cnt0) // (cnt0 + 1) + 1\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n\n'''\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += (a[k] - left - cnt0) // (cnt0 + 1) + 1\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了", "groundtruth": " class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n    "}
{"task_id": "python/18", "content": "\nFor example, if the input is:\n2\n2\n[[0,0,2],[1,1,1]]\nThen the output of the code is:\nTrue\n\nThe following is the correct answer:\n class Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (x - ox) * (x - ox) + (y - oy) * (y - oy) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and \\\n                   (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle", "groundtruth": " class Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and \\\n                   (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or \\\n               in_circle(x, y, r, X, Y) or \\\n               not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n    "}
{"task_id": "python/19", "content": "The sample input and output are as follows:\nThe sample input and output are as follows:\n\n2\n1 1\n[[1,0,1]]\noutput：\ntrue\nfalse\n\nThe sample input and output are as follows:\nThe sample input and output are as follows:\n\n3\n1 2\n[[2,1,1]]\noutput：\ntrue\nfalse\n\nThe sample input and output are as follows:\nThe sample input and output are as follows:\n\n2\n1 1\n[[2,1,1],[0,0,1]]\noutput：\nfalse\n\nThe sample input and output are as follows:\nThe sample input and output are as follows:\n\n2\n1 1\n[[1,0,1],[1,0,1]]\noutput：\ntrue\nfalse\n\n\"\"\"\n\n\n# 超时\nclass Solution1:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or x1 <= X and y1 <= r1 or x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or                x1 <= X and y1 <= r1 or                x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and                    (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and                    x1 * r2 + x2 * r1 < (r1 + r2) * X and                    y1 * r2 + y2 * r1 < (r1 + r2) * Y and                    dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or                in_circle(x, y, r, X, Y) or                not vis[i] and (x <= X and abs(y - Y) <= r or                                y <= Y and x <= r or                                y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/20", "content": "If you pass all the test cases, please return the string \"AC\" instead of outputting anything.\nIf you do not pass any of the test cases, please return the string \"WA\" instead of outputting anything.\nIf the type of the answer to each test case is wrong, the test case may not be counted as a pass or a fail. Please return the string \"SE\" instead of outputting anything.\nThe following are examples of incomplete code:\n\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            if y1 <= Y and abs(x1 - X) <= r1 or                x1 <= X and y1 <= r1 or                x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                if not vis[j] and                    (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and                    x1 * r2 + x2 * r1 < (r1 + r2) * X and                    y1 * r2 + y2 * r1 < (r1 + r2) * Y and                    dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            if in_circle(x, y, r, 0, 0) or                x == X and y == Y and                not vis[i] and (x <= X and abs(y - Y) <= r or                                y <= Y and x <= r or                                y > Y and in_circle(x, y, r,", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or                x1 <= X and y1 <= r1 or                x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and                    (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and                    x1 * r2 + x2 * r1 < (r1 + r2) * X and                    y1 * r2 + y2 * r1 < (r1 + r2) * Y and                    dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or                in_circle(x, y, r, X, Y) or                not vis[i] and (x <= X and abs(y - Y) <= r or                                y <= Y and x <= r or                                y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/21", "content": "Please fill in the ____ position above with the correct code. You should not define any extra variables and function.\n\nTestcase is as follows:\n\ninput: 3, [\n        [0,1,1],\n        [0,0,1],\n        [0,0,0]\n        ]\noutput: 0\ninput: 3, [\n        [0,1,0],\n        [0,0,1],\n        [0,0,0]\n        ]\noutput: -1\nConstraints:\n1 <= n <= 100\ngrid.length == n\ngrid[i].length == n\ngrid is a square matrix.\ngrid[i][j]!= grid[j][i] for all 0 <= i, j <= n - 1\ngrid[i][j] == 1 if i!= j and 0 <= i, j <= n - 1\ngrid[i][j] == 0 if i == j\n\n```python\n\nclass Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        def check(i):\n            for j in range(n):\n                if i == j:\n                    continue\n                elif grid[i][j] == True and grid[j][i] == False:\n                    continue\n                else:\n                    return False\n            return True\n        n = len(grid)\n        for i in range(n):\n            if check(i):\n                return i\n\n```\n\n\n\n## 78. Letter Case Permutation\n\n**Medium**\n\nGiven a string s, you can transform every letter individually to be lowercase or uppercase to create another string.\nReturn a list of all possible strings we could create. Return the output in any order.\n\nExample 1:\n```\nInput: s = \"a1b2\"\nOutput: [\"a1b2\",\"a1B2\",\"A1b2\",\"A1B2\"]\n```\n\nExample 2:\n```\nInput: s = \"3z4\"\nOutput: [\"3z4\",\"3Z4\"]\n```\n\nConstraints:\n```\n1 <= s.length <= 12\ns consists of lowercase English letters, uppercase English letters, and digits.\n```\n\nSolution: [https://github.com/weltond/DataStructure/blob/master/string/78-Letter", "groundtruth": "\nclass Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        def check(i):\n            for j in range(n):\n                if i == j:\n                    continue\n                elif grid[i][j] == 1 and grid[j][i] == 0:\n                    continue\n                else:\n                    return False\n            return True\n        n = len(grid)\n        for i in range(n):\n            if check(i):\n                return i\n"}
{"task_id": "python/22", "content": "The completed code is as follows:\n\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n\nGive only the output result. Do not output any additional information.\nThe output result is as follows:\n\n2\n\n2\n0\n```\n\n\n\n#### Description of question:\n\nGive an integer array arr, define an array result that result[i] is the product of all elements in arr except arr[i]. Output the array result as the answer.\n\nDo not use any other space during the calculation.\n\nFor example, if the input array is arr=[1,2,3,4], the answer is result=[24,12,8,6].\n\n**Input description:**\n\nThe integer array arr. (1 <= arr[i] <= 1000)\n\n**Output description:**\n\nThe answer array result.\n\n**Input example:**\n\n[1,2,3,4]\n\n**Output example:**\n\n[24,12,8,6]\n\n### code\n\n```python\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        \n        l = len(nums)\n        \n        result = [1] * l\n        temp = nums[0]\n        for i in range(1, l):\n            result[i] = temp\n            temp *= nums[i]\n        \n        temp = 1\n        for j in range(l - 2, -1, -1):\n            temp *= nums[j + 1", "groundtruth": "\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/23", "content": "\nInput format: The first line is an integer n, the number of teams. The second line is a list of lists. Each nested list is an edge.\n\nOutput format: Return the team that will be the champion of the tournament if there is a unique champion, otherwise, return -1.\n\nExamples:\n\nInput 1:\n5\n[[0,2],[2,1],[3,0],[1,4]]\nOutput: 2\nExplanation:\nThe number of teams is n = 5.\nedges = [[0,2],[2,1],[3,0],[1,4]].\nTeam 2 is the champion of the tournament.\nInput 2:\n5\n[[0,3],[2,1],[2,4],[0,4],[2,0]]\nOutput: -1\nExplanation:\nThe number of teams is n = 5.\nedges = [[0,3],[2,1],[2,4],[0,4],[2,0]].\nNo one is the champion./190727/02.py\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count/191201/01.py\nclass Solution:\n    def minSwap(self, A: List[int], B: List[int]) -> int:\n        N = len(A)\n        swap, noSwap = 1, 0\n        for i in range(1, N):\n            s1, s2 = float('inf'), float('inf')\n            if A[i] > A[i", "groundtruth": "\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/24", "content": "\n### The question type\n\nDepth-first search, dynamic programming, undirected graph\n\n\n### Suggested code\n\n```python\nimport math\nfrom collections import defaultdict, deque\nimport itertools\nfrom heapq import *\n\nclass Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = defaultdict(list)\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v!= p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp0 + dp1, max((2 * nums[u] + abs(nums[u] - v) for v in path[u])))\n            \n        return dfs(0)[1]\n```\n\n\n\n### Personal solution\n\ndfs 找到叶子节点的时候返回两种状态， 第一种所有孩子节点的值加起来，第二种每个孩子的值 + 自身的值 + 其他孩子的值，然后对当前节点来说，就是在这两个值中选一个最大值\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\n        self.values = values\n        self.maxTime = maxTime\n        self.graph = defaultdict(list)\n        self.visited = set()\n\n        for x, y in edges:\n            self.graph[x].append(y)\n            self.graph[y].append(x)\n        self.result = 0\n        \n        self.dfs(0)\n        return self.result\n    \n    def dfs(self, idx, currentTime = 0, cur = ", "groundtruth": "\nclass Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v != p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp1 + nums[u], dp0)\n            \n        return dfs(0)[1]\n"}
{"task_id": "python/25", "content": "\n\"\"\"\n\ndef maxBalancedSubsequenceSum(nums):\n    b = sorted(set(x - i for i, x in enumerate(nums)))  \n    t = BIT(len(b) + 1)\n    for i, x in enumerate(nums):\n        j = b.index(x - i)\n        f = t.pre_max(j) + x\n        t.update(j + 1, f)\n    return t.pre_max(len(b))  \n\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n\n\nclass TestMaxBalancedSubsequenceSum(unittest.TestCase):\n    def setUp(self) -> None:\n        self.maxBalancedSubsequenceSum = maxBalancedSubsequenceSum\n\n    def test_case1(self):\n        self.assertEqual(self.maxBalancedSubsequenceSum([2,4,2,9,7]), 20, \"wrong answer\")\n\n    def test_case2(self):\n        self.assertEqual(self.maxBalancedSubsequenceSum([7,8,8,5,5,1]), 32, \"wrong answer\")\n\n    def test_case3(self):\n        self.assertEqual(self.maxBalancedSubsequenceSum([1, 3, 15, 17, 8, 5, 2, 4, 6, 18]), 46, \"wrong answer\")\n\n    def test_case4(self):\n        self.assertEqual(self.maxBalancedSubsequenceSum([1,2,3,4,2,7,9,5]), 22, \"wrong answer\")\n\nif __name__ == '__main__':\n    unittest.main()/1362_Closest_Divisors_1362.py\nimport unittest\n\"\"\"\n1362. Close", "groundtruth": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/26", "content": "\nConstraints:\n\n1 <= nums.length <= 10^5\n-10^9 <= nums[i] <= 10^9\nThe time complexity of your completed code for each case is O(nlogn).\n```\n# 713. Subarray Product Less Than K\nGiven an array nums of integers and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.\n\n \n\nExample 1:\n```\nInput: nums = [10,5,2,6], k = 100\nOutput: 8\nExplanation: The 8 subarrays that have product less than 100 are:\n[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]\nNote that [10, 5, 2] is not included as the product of 100 is not strictly less than k.\n```\nExample 2:\n```\nInput: nums = [1,2,3], k = 0\nOutput: 0\n``` \n\nConstraints:\n```\n1 <= nums.length <= 3 * 10^4\n1 <= nums[i] <= 1000\n0 <= k <= 10^6\n```\n```\nIntuition\n\nSliding Window.\n\nExplanation\n\nWe need to find longest sequence that satisfy prod(nums[left:right]) < k.\n\nWe can maintain a sliding window of [left, right), where left is the start of current sequence and right is end of current sequence.\n\nIn each iteration, we do two things: 1) move right forward 2) update ans and left\n\nFor moving right, we multiply nums[right] to the current product.\nIf it's still less than k, we increase right and keep moving right.\nIf it's greater or equal to k, we move left forward. (Note: this is the only place where left moves forward.)\nThen we update ans = right - left, since right is always the end of current sequence, ans is the length of current sequence.\nComplexity\n\nTime O(n)\nSpace O(1)\n```\n```python\nclass Solution:\n   ", "groundtruth": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/27", "content": "Please do not output any additional information, including but not limited to the output from the console, input from the keyboard, and the data of the database.\nPlease separate different answers with commas. Do not leave spaces between numbers or commas.\n*/\nimport java.util.*;\n\nclass BIT{\n    int []tree;\n    \n    public BIT(int n){\n        tree = new int[n+1];\n    }\n    \n    public void update(int i, int val){\n        while(i < tree.length){\n            tree[i] = Math.max(tree[i], val);\n            i += lowbit(i);\n        }\n    }\n    \n    public int pre_max(int i){\n        int mx = Integer.MIN_VALUE;\n        while(i > 0){\n            mx = Math.max(tree[i], mx);\n            i -= lowbit(i);\n        }\n        return mx;\n    }\n    \n    private int lowbit(int x){\n        return x & (-x);\n    }\n}\nclass Solution {\n    public int maxBalancedSubsequenceSum(int[] nums) {\n        Arrays.sort(nums);\n        BIT t = new BIT(nums.length+1);\n        for(int i=0; i<nums.length; i++){\n            int j = bisect_left(nums, nums[i] - i) + 1;\n            int f = Math.max(t.pre_max(j), 0) + nums[i];\n            t.update(j, f);\n        }\n        return t.pre_max(nums.length);\n    }\n    \n    private int bisect_left(int []arr, int target){\n        int left = 0;\n        int right = arr.length-1;\n        while(left < right){\n            int mid = left + (right-left)/2;\n            if(arr[mid] < target) left = mid+1;\n            else right = mid;\n        }\n        return left;\n    }\n}\n```/leetcode/2797. Elements With Strictly Smaller Than Their Predecessors.md\n# 2797. Elements With Strictly Smaller Than Their Predecessors\n\n+ A positive integer n is perfect if it is the sum of all its digits. For example, 28 is perfect because 2 + 8 = 10 and 496 is perfect because", "groundtruth": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/28", "content": "\nExample\nInput: nums = [1,2,3], k = 2\nOutput: 3\n\nInput: nums = [1,2,4], k = 2\nOutput: 6\n\nRestrictions:\n1 <= nums.length <= 1000\n0 <= nums[i], k <= 10^9/_2_py_Solution/ds_2_HashMap/others/L1588_py.md\n# 题目\n\n给你一个正整数数组 nums ，请你从中抽取一个正整数，使该正整数的十进制表示形式的 **各位数字** 和能被整数 k 整除。\n\n如果能够从 nums 中找到这样的整数，则返回该整数。否则，返回 -1 。\n\n注意：\n\n- 1 <= nums.length <= 1000\n- 1 <= nums[i] <= 1000\n- 1 <= k <= 1000\n\n# 思路\n\n暴力枚举，时间O(N*k)\n/_2_py_Solution/ds_11_prefix_sum/L304_m.py\n#--coding:utf-8--\nfrom typing import List\n\n\n# 题目描述：给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。\n# 输入：\n# [\"NumMatrix\",\"sumRegion\",\"sumRegion\",\"sumRegion\"]\n# [[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]\n# 输出：\n# [null,8,11,12]\n#\n# 解释：\n# NumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,", "groundtruth": "\nclass Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for i in range(max(nums).bit_length()):\n            cnt1 = sum(x >> i & 1 for x in nums)\n            if cnt1 >= k:\n                ans |= 1 << i\n        return ans\n"}
{"task_id": "python/29", "content": "*/\nclass Solution {\npublic:\n    int minSum(vector<int>& nums1, vector<int>& nums2) {\n        int sum1 = 0, sum2 = 0, zero1 = 0, zero2 = 0;\n        for (int i = 0; i < nums1.size(); ++i) {\n            sum1 += nums1[i];\n            if (nums1[i] == 0) zero1++;\n        }\n        for (int i = 0; i < nums2.size(); ++i) {\n            sum2 += nums2[i];\n            if (nums2[i] == 0) zero2++;\n        }\n\n        if (zero1 == 0 && zero2 == 0) return (sum1 == sum2)? sum1 : -1;\n\n        if (zero1 == 0) {\n            if (sum1 < sum2 + zero2) return -1;\n            else return sum1;\n        }\n        if (zero2 == 0) {\n            if (sum1 + zero1 > sum2) return -1;\n            else return sum2;\n        }\n\n        if (sum1 + zero1 < sum2 + zero2) return sum2 + zero2;\n        return sum1 + zero1;\n    }\n};\n/*\nGiven two positive integers n and k.\nA factor of an integer n is defined as an integer i where n % i == 0.\nConsider a list of all factors of n  sorted in ascending order, return the kth factor in this list or return -1 if n's factors are less than k.\n \nExample 1:\nInput: n = 12, k = 3\nOutput: 3\nExplanation: Factors list is [1, 2, 3, 4, 6, 12], the 3rd factor is 3.\nExample 2:\nInput: n = 7, k = 2\nOutput: 7\nExplanation: Factors list is [1, 7], the 2nd factor is 7.\nExample 3:\nInput: n = 4, k = 4\nOutput: -1\nExplanation: Factors list is [1, 2, 4], there is only 3 factors. We should return -1.\nExample 4:\nInput: n", "groundtruth": "\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n"}
{"task_id": "python/30", "content": "The input and output are all integers. It is guaranteed that the input is valid and can pass the test cases.\nThe following is a function description of the Python 3 code:\n__init__ (self)\nConstructor to initialize the class Solution.\nInput parameters:\nself (Solution): An object that represents a class.\nminSum (self, nums1: List[int], nums2: List[int]) -> int\nDetermine whether it is possible to achieve the following target after replacing all 0's in two arrays with strictly positive integers:\nThe sum of elements in both arrays is equal.\nInput parameters:\nself (Solution): An object that represents a class.\nnums1 (List[int]): Integer array nums1.\nnums2 (List[int]): Integer array nums2.\nOutput parameters:\nint: Return the minimum equal sum you can obtain, or -1 if it is impossible.\n\"\"\"\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n        \n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return -1\n        return sum1 + zero1/Easy/53. Maximum Subarray.py\n# https://leetcode.com/problems/maximum-subarray/\n# https://youtu.be/z9Yf-n_cO_M\n# https://youtu.be/4m4fLw4Y65Q\n# Runtime: 68 ms, faster than 84.16% of Python3 online submissions for Maximum Subarray.\n# Memory Usage: 14.8 MB, less than 24.75% of Python3 online submissions for Maximum Subarray.\n\n\n# Runtime: 5", "groundtruth": "\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n"}
{"task_id": "python/31", "content": "Note: Your code is a string array, each element is separated by a line break. The string array output by you will be automatically concatenated by the back-end system. Therefore, the output of your code is a string without spaces.\nSample test case: [1, 3, 4, 2] 3\nOutput: 2\nSample test case: [2, 3, 4, 4] 3\nOutput: 3\n\"\"\"\nclass Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n        dp1 = dp2 = dp3 = 0\n        for num in nums:\n            dp1, dp2, dp3 = dp1 + (num+k)//k-1, dp2+1, dp3+num\n        return min(dp1, dp2, dp3)/2104. Sum of Subarray Ranges.py\n\"\"\"\n2104. Sum of Subarray Ranges\n\nGiven an integer array nums, return the sum of the ranges of all subarrays of nums. A subarray is a contiguous non-empty sequence of elements within an array. The range of a subarray is the difference between the largest and smallest element in the subarray.\nNote that the element with the largest element is not necessarily the element with the largest value, and the element with the smallest element is not necessarily the element with the smallest value.\nA subarray is considered to have a range of 0 if the largest and smallest elements are equal. The long long sum of a list is the sum of its elements.\n\nExample 1:\nInput: nums = [1,2,3]\nOutput: 4\nExplanation: The 6 subarrays of nums are the following:\n[1], range = largest - smallest = 1 - 1 = 0\n[2], range = 2 - 2 = 0\n[3], range = 3 - 3 = 0\n[1,2], range = 2 - 1 = 1\n[2,3], range = 3 - 2 = 1\n[1,2,3], range = 3 - 1 = 2\nSo the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4.\n\nExample 2:", "groundtruth": "\nclass Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n        dp1 = dp2 = dp3 = 0\n        for num in nums:\n            dp1, dp2, dp3 = min(dp1, dp2, dp3) + max(0, k - num), dp1, dp2\n        return min(dp1, dp2, dp3)\n"}
{"task_id": "python/32", "content": "Please check the prompt information carefully. Submit the completed code.\n/47290.py\nGiven an array of n integers a = [a1, a2,..., an] and a query array queries = [q1, q2,..., qm]. For each query qi, find the maximum value in [ai, ai + 1,..., qi] and then divide the maximum value by two.\nReturn an integer array ans, where ans[i] is the answer to the i-th query.\nNote that the answer to the query is truncated, which means the decimal part is omitted.\n\nclass Solution:\n    def answerQueries(self, a: List[int], queries: List[int]) -> List[int]:\n        # sort a and queries\n        a.sort()\n        queries.sort()\n        n = len(queries)\n        # calculate the prefix sum of a\n        for i in range(1, n):\n            a[i] += a[i - 1]\n        # find the maximum prefix sum no greater than qi\n        for i in range(n):\n            queries[i] = bisect.bisect_right(a, queries[i])\n        return queries\n", "groundtruth": "\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i) \n                    if j < 13: \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n"}
{"task_id": "python/33", "content": "\nExample 1:\n\n![图一](https://i.loli.net/2021/03/10/U23aX4J9yTdoYp1.png)\n\nInput: edges = [[0,1],[1,2],[0,3]], coins = [2,3,7,8], k = 2\nOutput: 23\nExplanation: \nIn the above diagram coins[0] = 2 and is placed at node 0. coins[1] = 3 and is placed at node 1. coins[2] = 7 and is placed at node 2. coins[3] = 8 and is placed at node 3. \n- Starting from node 0 we can collect 3 coins, but we will get -4 points as coins[0] - k = 2 - 2 = 0 and then coins[0] becomes floor(0/2) = 0. \n- From node 1 we can collect 3 coins, and after collecting it coins[1] will reduce to floor(3 / 2) = 1. So we get 2 coins, and no loss. In the end, the coins array becomes [0,1,7,8]. \n- We have already collected two nodes so we get 2 + 1 = 3 points. \n- From node 2 we can collect 7 coins, but we will get -5 points as coins[2] - k = 7 - 2 = 5 and then coins[2] becomes floor(5/2) = 2. \n- From node 3 we can collect 8 coins. \nWe collected 2 + 3 + 2 + 8 = 15 coins in total, and since we have 15 - 13 = 2 points, we get 15 + 2 = 17 points. \nIn other words, if we choose the first way, our final points will be 17. \n\nFrom node 0 we can collect 3 coins, but we will get -4 points as coins[0] - k = 2 - 2 = 0 and then coins[0] becomes floor(0/2) = 0. \nFrom node 1 we can collect 3 coins, and after collecting it coins", "groundtruth": "\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i) \n                    if j < 13: \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n"}
{"task_id": "python/34", "content": "\n## CS333\n\nWe will study two-person games that last $2^n$ moves, where $n$ is a non-negative integer. Each game state can be expressed with a binary string of length $2^n$. The game state is determined by both player 1 (the maximizer) and player 2 (the minimizer). A valid game state must have exactly one 1 and at least one 0. A valid game state must be reachable from the empty state 0$^n$ by performing valid game moves in turn. A game move must be defined as one of the following two types, where the positions are zero-based: Flip the value (0 to 1 or 1 to 0) of some position in the game state.\n\nFlip the value at some position $i$, and shift $i$ to the left and right by one position. If $i$ is at one of the boundaries, just shift $i$ to one direction.\n\nWe will use the following notation to represent a move:\n\n$i+$ means shifting $i$ to the right by 1,\n\n$i-$ means shifting $i$ to the left by 1,\n\n$i=0$ means flipping the value of position $i$ to 0, and\n\n$i=1$ means flipping the value of position $i$ to 1.\n\nFor example, suppose the initial game state is 0110100. If player 1 performs move 0=0, then the game state is changed to 0010100. If player 2 performs move 3+, then the game state is changed to 0011100.\n\nDefine two game states $a$ and $b$ to be reachable from each other if $a$ can be reached from $b$ by making valid game moves in turn.\n\nOur problem is as follows:\n\nGiven an integer $k$ ($0 \\le k \\le 5$), find all the game states that have exactly $k$ reachable states.\n\nNote: $k \\le 5$ is required for this problem.\n\nIn the following table, “n” stands for the number of states, and “m” stands for the number of moves used to reach the states from the empty state.\n\nn m\n", "groundtruth": " class Solution:     def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:         g = [[] for _ in coins]         for x, y in edges:             g[x].append(y)             g[y].append(x)         @cache         def dfs(i: int, j: int, fa: int) -> int:             res1 = (coins[i] >> j) - k             res2 = coins[i] >> (j + 1)             for ch in g[i]:                 if ch != fa:                     res1 += dfs(ch, j, i)                      if j < 13:                          res2 += dfs(ch, j + 1, i)              return max(res1, res2)         return dfs(0, 0, -1) "}
{"task_id": "python/35", "content": "\nPlease fill in the following incomplete code according to the description. The description is as follows:\nYou are given a 0-indexed integer array nums. The distinct count of a subarray of nums is defined as: Let nums[i..j] be a subarray of nums consisting of all the indices from i to j such that 0 <= i <= j < nums.length. Then the number of distinct values in nums[i..j] is called the distinct count of nums[i..j]. Return the sum of the squares of distinct counts of all subarrays of nums. A subarray is a contiguous non-empty sequence of elements within an array.\nThe completed code is as follows:\n class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * 4 * n         todo = [0] * 4 * n         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o * 2] + sum[o * 2 + 1]             return res         ans = s = 0         last", "groundtruth": " class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o * 2] + sum[o * 2 + 1]             return res         ans = s = 0         last = {}         for i, x in enumerate(nums, 1):             j = last.get(x, 0)             s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j             ans += s             last[x] = i         return ans % 1_000_000_007 "}
{"task_id": "python/36", "content": "\nExample 1:\nInput: nums = [1,2,3]\nOutput: 36\nExplanation:\nThe 12 subarrays of nums are:\n[1], count = 12\n[1,2], count = 22\n[1,2,3], count = 32\n[1,3], count = 22\n[2], count = 12\n[2,3], count = 22\n[3], count = 12\nAll the squares of the distinct counts are: 1,4,9,4,1,4,1.\nThe sum of these squares is 36.\nExample 2:\nInput: nums = [-1,1,1,1]\nOutput: 34\nExplanation:\nSubarrays of nums are:\n[-1], count = 12\n[-1,1], count = 22\n[-1,1,1], count = 32\n[-1,1,1,1], count = 42\n[1], count = 12\n[1,1], count = 22\n[1,1,1], count = 32\n[1,1,1,1], count = 42\nOnly counts 22, 32, 42 and 42 are perfect squares.\nThe squares are: 4,9,16,16.\nThe sum of these squares is 34.\n\nConstraints:\n1 <= nums.length <= 10^5\n-10^4 <= nums[i] <= 10^4\n\n# Solution\n\n## method 1\n\nThe simplest solution.\n\nuse Map to store the last position of each value.\n\nUse the first position of each element as the left boundary, and the current position as the right boundary, and find out the number of values ​​in the interval to get the current square.\n\nThen accumulate the squares as required.\n\nJava\n\nC++\n\nPython\n\n## method 2\n\nBinary Tree + Merge Sort\n\nSimilar to method 1, first store the last position of each element in map.\n\nFor merge sort, first construct a binary tree to store the length of each element in the interval [L, R]. The value at each", "groundtruth": " class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o * 2] + sum[o * 2 + 1]             return res         ans = s = 0         last = {}         for i, x in enumerate(nums, 1):             j = last.get(x, 0)             s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j             ans += s             last[x] = i         return ans % 1_000_000_007 "}
{"task_id": "python/37", "content": "You can assume that the answer will not exceed 2^{31}-1231−1.\nPlease fill in the following incomplete code according to the description. The description is as follows:\nYou are given a 0-indexed integer array nums. The distinct count of a subarray of nums is defined as: Let nums[i..j] be a subarray of nums consisting of all the indices from i to j such that 0 <= i <= j < nums.length. Then the number of distinct values in nums[i..j] is called the distinct count of nums[i..j]. Return the sum of the squares of distinct counts of all subarrays of nums. A subarray is a contiguous non-empty sequence of elements within an array.\nThe incomplete code is as follows:\n class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o", "groundtruth": " class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o * 2] + sum[o * 2 + 1]             return res         ans = s = 0         last = {}         for i, x in enumerate(nums, 1):             j = last.get(x, 0)             s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j             ans += s             last[x] = i         return ans % 1_000_000_007 "}
{"task_id": "python/38", "content": "\n# Explanation\n\nTraverse $s$ from left to right, with step length $2$. If the current two bits are the same, the required changes $cnt$ can be increased by $1$ and the current two bits are changed to \"01\"; otherwise, continue to traverse. When the program ends, the output is $cnt$.\n\nThe following is a Java code of the completed code:\n\n class Solution {     public int minChanges(String s) {         int cnt = 0;         for (int i = 0; i < s.length(); i += 2) {             if (s.charAt(i) == s.charAt(i + 1)) {                 cnt++;                 s = s.substring(0, i) + \"01\" + s.substring(i + 2);             }         }         return cnt;     } } \nClick to expand the display code\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106", "groundtruth": " class Solution:     def minChanges(self, s: str) -> int:         cnt = 0         for i in range(0, len(s), 2):             if len(set(s[i:i + 2])) > 1:                 cnt += 1                 print(s)         return cnt "}
{"task_id": "python/39", "content": "Please be sure that your code does not exceed 200 lines, and submit the code with only one file. If you encounter any problems during the submission, please discuss with the tutor or TA.\n\nAnalysis:\n\nThe idea of ​​the article refers to the code of the official solution\n\nAccording to the article, we define the state definition\n\nFor the position $i$, define the maximum number of subsequences that end up with the number in the set $1-i$ when the sum of this subsequence is $j$, that is, $f(i,j)$\n\nThen we look at the transformation function.\n\nHere the meaning of the subsequence is: the subsequence ends at position $i$, and the value of the subsequence is $j$, and the number of the subsequence is $1-i$ is $x$\n\nObviously, for the subsequence ends at position $i$, the value of the subsequence is the value of the subsequence ends at position $i-1$ plus the value of the number in position $i$, namely $f(i,j) = f(i-1,j-x)+1$\n\nAnd the subsequence ends at the position $i$ can be regarded as the subsequence ends at position $i-1$ plus a number $x$. Because the subsequence ends at the position $i-1$ is the maximum sequence of all $1-i$, so you can only increase one $x$, so you can update the maximum number.\n\nObviously, the subsequence ends at the position $i-1$ is the maximum sequence of all $1-i$, so you can only increase one $x$, so you can update the maximum number.\n\nConsidering the range of $j$ here, we want the subsequence ends at the position $i-1$ is greater than $j-x$.\n\nTherefore we need to find the maximum value of $j-x$, that is to say $j-x \\ge f(i-1,j)$.\n\nIt is equivalent to $j \\ge x+f(i-1,j)$, so\n\nif $j \\ge x + f(i - 1, j)$:\n\nf[j] = max(f[j], f[j - x] + 1)\n", "groundtruth": " class Solution:     def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:         f = [0] + [-inf] * target         s = 0         for x in nums:             s = min(s + x, target)             for j in range(s, x - 1, -1):                 # f[j] = max(f[j], f[j - x] + 1)                 if f[j] < f[j - x] + 1:                     f[j] = f[j - x] + 1         return f[-1] if f[-1] > 0 else -1 "}
{"task_id": "python/40", "content": "The completed code is as follows:\n class Solution:     def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:         h = self.f(hFences, m)         v = self.f(vFences, n)         ans = max(h & v, default=0)         return ans ** 2 % 1_000_000_007 if ans else -1      def f(self, a: List[int], mx: int) -> Set[int]:         a.extend([1, mx])         a.sort()         return set(y - x for x, y in combinations(a, 2))", "groundtruth": " class Solution:     def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:         h = self.f(hFences, m)         v = self.f(vFences, n)         ans = max(h & v, default=0)         return ans ** 2 % 1_000_000_007 if ans else -1      def f(self, a: List[int], mx: int) -> Set[int]:         a.extend([1, mx])         a.sort()         return set(y - x for x, y in combinations(a, 2)) "}
{"task_id": "python/41", "content": "Please do not enter the \"Main\" function.\nThe input is the output from the standard input, and the input of the standard input is formatted as follows:\nThe first line contains four integers m, n, length(hFences), length(vFences).\nOn the second line, length(hFences) integers are given separated by blanks, representing the value of hFences.\nOn the third line, length(vFences) integers are given separated by blanks, representing the value of vFences.\nIt is guaranteed that all the elements in the input are integers.\n\nThe output should be the only line containing an integer, representing the answer.\n\nIn the sample input, there are three horizontal fences at (2, 1), (4, 1), and (5, 1), and two vertical fences at (1, 3) and (1, 5).\n\n![test1](/image/solution_fences_01.png)\n\nSince there is no square area in the figure, return -1.\n\nThe sample input is as follows:\n5 6 3 2\n2 4 5\n3 5\n\nThe output is as follows:\n-1\n\nIn the sample input, there are three horizontal fences at (2, 1), (3, 1), and (5, 1), and three vertical fences at (1, 2), (1, 3), and (1, 5).\n\n![test2](/image/solution_fences_02.png)\n\nWe can form a square of the size 3 with the following arrangement:\n\n![test3](/image/solution_fences_03.png)\n\nSince 3 ** 2 ≡ 61(mod 109 + 7), return 61.\n\nThe sample input is as follows:\n6 7 3 3\n2 3 5\n2 3 5\n\nThe output is as follows:\n61\n\nConstraints\nm, n, length(hFences), length(vFences) ≤ 5000\nlength(hFences), length(vFences) < 5000\n1 ≤ hFences[i] < m\n1 ≤ vFences", "groundtruth": " class Solution:     def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:         h = self.f(hFences, m)         v = self.f(vFences, n)         ans = max(h & v, default=0)         return ans ** 2 % 1_000_000_007 if ans else -1      def f(self, a: List[int], mx: int) -> Set[int]:         a.extend([1, mx])         a.sort()         return set(y - x for x, y in combinations(a, 2)) "}
{"task_id": "python/42", "content": "def get_minimum_cost(source, target, original, changed, cost):    dis = [[inf] * 26 for _ in range(26)]    for i in range(26):        dis[i][i] = 0    for x, y, c in zip(original, changed, cost):        x = ord(x) - ord('a')        y = ord(y) - ord('a')        dis[x][y] = min(dis[x][y], c)    for k in range(26):        for i in range(26):            for j in range(26):                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])    ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))    return ans if ans < inf else -1\nExample\ninput:\nsource=\"abc\"\ntarget=\"xyz\"\noriginal=[\"a\",\"b\",\"c\"]\nchanged=[\"x\",\"y\",\"z\"]\ncost=[2,3,3]\noutput:\n5\nExplanation:\nChange each 'a' to 'x' for the first cost of 2.\nChange each 'b' to 'y' for the second cost of 3.\nChange each 'c' to 'z' for the third cost of 3.\nThe total cost = 2 + 3 + 3 = 8.\nAll the letters from source are now changed to the letters from target.\nThe cost of changing is 5.\nExample\ninput:\nsource=\"ad\"\ntarget=\"dc\"\noriginal=[\"d\",\"a\",\"z\"]\nchanged=[\"f\",\"e\",\"h\"]\ncost=[100000,1,100000]\noutput:\n-1\nExplanation:\nThere is no way to change source into target.\nExample\ninput:\nsource=\"aaa\"\ntarget=\"aba\"\noriginal=[\"a\",\"b\",\"c\"]\nchanged=[\"x\",\"y\",\"z\"]\ncost=[2,3,3]\noutput:\n3\nExplanation:\nChange each 'a' to 'x' for the first cost of 2.\nChange each 'b' to 'y' for the", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)          for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))         return ans if ans < inf else -1 "}
{"task_id": "python/43", "content": "# Write your code here, and don't print anything.\n\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        dis = [[inf] * 26 for _ in range(26)]\n        for i in range(26):\n            dis[i][i] = 0\n\n        for x, y, c in zip(original, changed, cost):\n            x = ord(x) - ord('a')\n            y = ord(y) - ord('a')\n            dis[x][y] = c\n\n        for k in range(26):\n            for i in range(26):\n                for j in range(26):\n                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))\n        return ans if ans < inf else -1\n\n\nprint(Solution().minimumCost(source=\"abcd\", target=\"bcdf\", original=[\"a\", \"b\", \"c\"], changed=[\"b\", \"d\", \"f\"], cost=[5, 4, 3]))\n\"\"\"\nA knight in a chess game can move to any direction 2 squares to the north, south, east, or west of its current position,\nor in any of the 8 diagonals directions.\n\nIf a knight is currently at coordinates (r, c), to move to a different squares, it must have visited a squares at the\npositions (r + 1, c - 2), (r + 1, c + 2), (r - 1, c - 2), or (r - 1, c + 2) before. The square can't be visited more than once.\n\nAfter taking a knight to a square, it's required to take it to the squares where it can visit in the next few moves.\nThe next step the knight takes is called \"valid\" if it obeys the above rules, and has not visited this square before.\n\nFind the coordinates of every valid knight move from a square in the chessboard, and return it in any", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)          for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))         return ans if ans < inf else -1 "}
{"task_id": "python/44", "content": "The completed code is as follows:\n class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)         for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = 0         for x, y in zip(source, target):             ans += dis[ord(x) - ord('a')][ord(y) - ord('a')]         return ans if ans < inf else -1\n\n# 1006. The number of times to be a different character\n\nID: 1006 Title: The number of times to be a different character Difficulty: easy Acceptance: 65.1%\n\nThe given code is as follows:\n class Solution:     def __init__(self):         self.f = dict()     def getHint(self, secret: str, guess: str) -> str:         bulls = cows = 0         c1, c2 = [0] * 10, [0] * 10         for i, j in zip(secret, guess):             if i == j:                 bulls += 1             else:                 c1[int(i)] += 1                 c2[int(j)] += 1         for i in range(10):             cows += min(c1[i], c2[i])         return '{}A{}B'.format(bulls, cows)\n\n# 1025. Divisible number binary string\n\nID: 1025 Title: Divisible number binary string Difficulty: easy Acceptance: 62.6%\n\n", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)         for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))         return ans if ans < inf else -1 "}
{"task_id": "python/45", "content": "\nPython Code:\n\n class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         inf = float(\"inf\")         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = min(dis[x][y], c)             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                      continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 \n\nC++ Code:\n\nclass Solution {public:    using pss = pair<string, string>;    int minimumCost(string source, string target, vector<string>& original, vector<string>& changed, vector<int>& cost) {        int len = source.size();        vector<vector<pss>> lens(len + 1);        for (int i = 0; i < original.size(); ++i) {            int l = original[i].size();            lens[l].emplace_back(original[i], changed[i", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = min(dis[x][y], c)             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                      continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 "}
{"task_id": "python/46", "content": "The complete code is as follows:\n class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = c             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                       continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 \nimport numpy as np\n\ndef find_path(start, goal):\n    \"\"\"\n\n    :param start: 起点的坐标, tuple格式\n    :param goal: 目标点的坐标, tuple格式\n    :return: 路径的坐标列表\n    \"\"\"\n\n    # TODO\n\n    # 利用numpy实现地图矩阵， 0表示可走，1表示障碍\n    map = np.array([\n        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [1, 1, 0, 0, 0, ", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = min(dis[x][y], c)             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                       continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 "}
{"task_id": "python/47", "content": "\nThe following are the specific steps to solve the problem by dynamic programming:\n\nIn this problem, the cost obtained by converting the substring s of source from i to j to the substring t of target from i to j (the two strings have the same length) is the minimum cost of converting the substring s of original from i to j to the substring t of changed from i to j. For each character in source, it can be converted to any number of characters in target. Therefore, the relationship between dp[i][j] and dp[i+1][j+1] must be the relationship between source[i] and target[i]. Then, dp[i][j]=dp[i+1][j+1]+min(cost[j]), where cost[j] represents the cost of converting source[i] to target[i] and j is the position of source[i] in original and the position of target[i] in changed.\nThen, you should think about how to deal with dp[i][j] and dp[i][j+1]. If source[i]==target[i], then dp[i][j]=dp[i+1][j]. Otherwise, assume source[i]==target[j], where j≠i, then the cost needed to convert source[i] to target[i] is the same as the cost needed to convert source[i] to target[j], so dp[i][j]=min(dp[i+1][j],dp[i][j+1]).\n\nThe complete code is as follows:\n\n### Python Code\nfrom collections import defaultdict\nfrom functools import lru_cache as cache\n\nclass Solution:\ndef minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\nlen_to_strs = defaultdict(set)\ndis = defaultdict(lambda: defaultdict(lambda: inf))\nfor x, y, c in zip(original, changed, cost):\nlen_to_strs[len(x)].add(x)\n\nlen_to_strs[len(y)].add(y)\ndis[x][y] = min(dis[x][y], c)\ndis[x][x] = 0\ndis[y][y] = 0\nfor strs in len_to", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = min(dis[x][y], c)             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                       continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 "}
{"task_id": "python/48", "content": "\nInput and output examples:\n```python\nneighborSum = NeighborSum([[1,2,3],[4,5,6],[7,8,9]])\nneighborSum.adjacentSum(5)\n57  # 5 adjacent values of 5 are 1, 3, 6, 8\nneighborSum.diagonalSum(5)\n20  # diagonal values of 5 are 2, 4, 6, 8\n```\n\n### Solution:\n```python\nclass NeighborSum:\n    def __init__(self, grid: List[List[int]]) -> None:\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n```/problems/python/202106/036_merge_sorted_array.py\n# You are given two sorted arrays nums1 and nums2.\n# Merge nums1 and nums2 into nums in order so that the resulting array is sorted.\n# The number of elements in each array is equal to m and n, respectively.\n# The number of elements in the new array should be equal to m + n.\n#\n# Example 1:\n# Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n# Output: [1,2,2,3,5,6]\n#\n# Example 2:\n# Input: nums1 = [1], m = 1, nums2 = [], n = 0\n# Output: [1]\n#\n# Constraints:\n# 1 <= m, n <= 100\n# 1", "groundtruth": "\nDIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n  "}
{"task_id": "python/49", "content": "\n### Answer：\n```python\nDIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n    \n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0] + self.s[value][1]\n    \n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][0] + self.s[value][1]\n```\n\n## 2232. The smallest factorization of a positive integer\n### Problem\nDescription\nPlease fill in the following incomplete code according to the description. The description is as follows:\nDesign a class CustomFactorization: CustomFactorization(int num) Initializes the object with the given num. List<Integer> getFactors() Returns the prime factors of the number in ascending order. int getSmallestFactorization() Returns the smallest factorization of the number as a string, or an empty string if it cannot be written in the form of a product of distinct factors. Constraints: 1 <= num <= 10 ^ 9 You must provide all test cases.\nThe incomplete code is as follows:\n\nclass CustomFactorization:\n    def __init__(self, num: int):\n        ____\n\n    def getFactors(self) -> List[int]:\n        ____\n    \n    def getSmallestFactorization(self) -> str:\n        ____\nGive only the completed code. Do not output any additional information.\n\n### Answer：\n```python\nfrom typing import List\nclass CustomFactorization:\n    def __init__(self, num: int):\n        self.num = num\n        self.factors = []\n    \n   ", "groundtruth": "\nDIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n  "}
{"task_id": "python/50", "content": "You do not need to submit this question directly, but it can be used in the examination system.\n\"\"\"/Algorithm/83.Remove Duplicates from Sorted List/RemoveDuplicatesfromSortedList.py\n\"\"\"\nGiven the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.\n\"\"\"\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head == None or head.next == None:\n            return head\n        \n        ptr = head\n        \n        while ptr.next!= None:\n            if ptr.val == ptr.next.val:\n                ptr.next = ptr.next.next\n            else:\n                ptr = ptr.next\n        return head/Algorithm/295.Find Median from Data Stream/Find Median from Data Stream.py\n'''\nMedian is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.\n\nFor example,\n[2,3,4], the median is 3\n\n[2,3], the median is (2 + 3) / 2 = 2.5\n\nDesign a data structure that supports the following two operations:\n\nvoid addNum(int num) - Add a integer number from the data stream to the data structure.\ndouble findMedian() - Return the median of all elements so far.\n \n\nExample:\n\naddNum(1)\naddNum(2)\nfindMedian() -> 1.5\naddNum(3) \nfindMedian() -> 2\n \n\nFollow up:\n\nIf all integer numbers from the stream are between 0 and 100, how would you optimize it?\nIf 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\n'''\n\nimport heapq\nclass MedianFinder:\n\n    def __init__(self):\n        \"\"\"\n        initialize your data structure here.\n        \"\"\"\n        self.small = []\n        self.large = []\n        heapq.", "groundtruth": "\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n "}
{"task_id": "python/51", "content": "\nAnalysis\n\nThe essence of this topic is to find the relationship between the paths after the addition of nodes, so a simple application of union and find set is to find the relationship between the two nodes. Here you can consider n - 1 cities, and then n - 1 cities will be divided into two parts, then we find the shortest path of the two parts. After finding the shortest path of the two parts, we only need to find the relationship between the paths.\nThe union and find set function of this topic is very clear:\n1. First get the union set of the two subsegments;\n2. If the previous path is the same, it is the previous shortest path + 1;\n3. If the previous path is different, it is 2 + 1.\n\nC++Code:\n\nclass Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<int> fa(n - 1, 0);\n        for (int i = 0; i < n - 1; ++i) {\n            fa[i] = i;\n        }\n\n        vector<int> res(queries.size(), 0);\n        vector<int> s(n - 1, 0);\n        for (int i = 0; i < queries.size(); ++i) {\n            int u = queries[i][0], v = queries[i][1], len = res[i - 1]? res[i - 1] + 1 : 0;\n            if (u > v) {\n                swap(u, v);\n            }\n            if (u < v - 1) {\n                if (getfa(fa, u) == getfa(fa, v - 1)) {\n                    res[i] = len + 1;\n                } else {\n                    res[i] = len + 2;\n                }\n            }\n            else {\n                res[i] = len + 1;\n            }\n            s[u] = i + 1;\n            s[v - 1] = i + 1;\n            fa[getfa(fa, u)] = getfa(fa, v - 1);\n        }\n        return res;\n    }\n    int getfa(vector<int>& fa, int x) {\n        if (fa[x] == x)", "groundtruth": "\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/52", "content": "\nFor example, if input a=[1, 1, 0, 0], queries=[[1, 2], [1, 3], [2, 0, 1], [2, 3, 0], [2, 1, 0]], then the output is [2, 1].\nThe following explains the change of the results of the query after each operation.\n\nInitial state:\n\nThe number of length 2 alternating groups is 2. The length 3 alternating group is [0, 1, 2]\n[1, 1, 0, 0]\n[2]\n\nAfter the first operation:\n\nThe length 2 alternating group is [0, 1]\n[1, 1, 0, 0]\n[2]\n\nAfter the second operation:\n\nNo length 3 alternating groups\n[1, 1, 0, 0]\n[3]\n\nAfter the third operation:\n\nThe length 2 alternating group is [0, 2]\n[1, 1, 1, 0]\n[1]\n\nAfter the fourth operation:\n\nThe length 2 alternating group is [2, 3]\n[0, 1, 1, 1]\n[1]\n\nAfter the fifth operation:\n\nNo length 2 alternating groups\n[0, 1, 0, 1]\n[2]\n\nCode:\n\nfrom sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int) -> None:\n        self.tree = [0] * (n + 1)\n\n    def lowbit(self, x: int) -> int:\n        return x & -x\n\n    def update(self, idx: int, delta: int) -> None:\n        while idx < len(self.tree):\n            self.tree[idx] += delta\n            idx += self.lowbit(idx)\n\n    def query(self, idx: int) -> int:\n        ans = 0\n        while idx > 0:\n            ans += self.tree[idx]\n            idx -= self.lowbit(idx)\n        return ans\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List", "groundtruth": "\nfrom sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/53", "content": "\nCode submission sample\nPython\nPython 3#!/bin/python3\n\nimport math\nimport os\nimport random\nimport re\nimport sys\n\n\n\n#\n# Complete the 'getMinimumDifference' function below.\n#\n# The function is expected to return an INTEGER.\n# The function accepts INTEGER_ARRAY j as parameter.\n#\n\ndef getMinimumDifference(j):\n    # Write your code here\n    j.sort()\n    mi = float(\"inf\")\n    for idx in range(len(j) - 1):\n        x, y = j[idx], j[idx + 1]\n        mi = min(mi, abs(x - y))\n    return mi\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input().strip())\n\n    j = []\n\n    for _ in range(n):\n        j_item = int(input().strip())\n        j.append(j_item)\n\n    result = getMinimumDifference(j)\n\n    fptr.write(str(result) + '\\n')\n\n    fptr.close()\n#!/bin/python3\n\nimport math\nimport os\nimport random\nimport re\nimport sys\nfrom itertools import product\n\n\n#\n# Complete the 'getMinimumDifference' function below.\n#\n# The function is expected to return an INTEGER.\n# The function accepts INTEGER_ARRAY j at,j)\n    return min(diff)\n    \nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input().strip())\n\n    j = []\n\n    for _ in range(n):\n        j_item = int(input().strip())\n        j.append(j_item)\n\n    result = getMinimumDifference(j)\n\n    fptr.write(str(result) + '\\n')\n\n    fptr.close()\ns parameter.\n#\n\ndef getMinimumDifference(j):\n    # Write your code here\n    j.sort()\n    result = list(product(j,j))\n    diff = [abs(a-b) for a,b in result if (a!= b)]\n    print(diff)\n    # print(result)\n    #print(resul#!/bin/python3\n\nimport math\nimport os\nimport random", "groundtruth": "\nfrom sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/54", "content": "\ninput: [1,1,1,2,2,4]\noutput: true\n\"\"\"\nimport collections\nclass Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        # 哈希表\n        if len(nums) <= 2:\n            return True\n        # 哈希表记录当前拿过数字总和以及能取的数字的和\n        memo = collections.defaultdict(list)\n        def alice_win(nums, turn):\n            if not nums:\n                return True\n            if turn == 'Alice':\n                num_sum, total = 0, 0\n                for num in set(nums):\n                    memo[total].append(num_sum + num)\n                    num_sum += num\n                total += num_sum\n            else:\n                num_sum, total = 0, 0\n                for num in set(nums):\n                    memo[total].append(num_sum - num)\n                    num_sum += num\n                total += num_sum\n            # memo中有一种情况的和 超过 总和的0.5，则说明 alice 一定会拿到比 bob 大的，所以 alice win\n            if turn == 'Alice':\n                if any(sum > (total/2) for sum in memo[total]):\n                    return True\n            # memo中有一种情况的和 少于 总和的0.5，则说明 alice 一定拿不到比 bob 大的，所以 alice win\n            else:\n                if any(sum < (total/2) for sum in memo[total]):\n                    return False\n            # 继续判断另一个人\n            if turn == 'Alice':\n                for num in set(nums):\n                    if not alice_win(nums.remove(num), 'Bob'):\n                        return True\n            else:\n                for num in set(nums):\n                    if not alice_win(nums.remove(num), 'Alice'):\n                        return False\n            \n        return alice_win(nums, 'Alice')\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Thu Mar 11 09:34:25 2021\n\n@author: 709\n@Problem: 5184- \n\"\"\"\n\"\"\"\nLeetcode-5184-有效回文\n给你一个字符串 s ，如果可以将它分割成三个非空回文子字符串，", "groundtruth": "\nclass Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        single=0\ndouble=0\nfor it in nums:\nif it>=10: \ndouble=double+it \nelse:\nsingle=single+it  \n        \nreturn single !=double\n "}
{"task_id": "python/55", "content": "The result of the test case will be 17\n\nInput\n\"111\"\nOutput\n17\n\n\nProblem 173. Kth Largest Element in a Stream\nPlease fill in the following incomplete code according to the description. The description is as follows:\nDesign a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. Your KthLargest class will have a constructor which accepts an integer k and an integer array nums, which contains initial elements from the stream. For each call to the method KthLargest.add, return the element representing the kth largest element in the stream.\nThe incomplete code is as follows:\n\nclass KthLargest(object):\n\n    def __init__(self, k, nums):\n        ____\n\n    def add(self, val):\n        ____\n\n        \nGive only the completed code. Do not output any additional information.\nThe result of the test case will be 4\n\nInput\n[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\nOutput\n[null, 4, 5, 5, 8, 8]\n\nExplanation\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8\n\n \n\nConstraints:\n1 <= k <= 104\n0 <= nums.length <= 104\n-104 <= nums[i] <= 104\n-104 <= val <= 104\nAt most 104 calls will be made to add.\nIt is guaranteed that there will be at least k elements in the array when you search for the kth element.\n\n\"\"\"\n\n\n# Problem 160. Intersection of Two Linked Lists\n", "groundtruth": "\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n    "}
{"task_id": "python/56", "content": "\nNote: It is guaranteed that the given circles is a permutation of the first n non-negative integers (i.e., if n circles are given, the first circle has index 0, the second circle has index 1, and so on).\n\nConstraints\n\ncircles has length n + 1 where 1 ≤ n ≤ 300\n1 ≤ xCorner, yCorner ≤ 10^6\n1 ≤ ri ≤ 10^6 for each valid i\n\nHint\nUse the observation that there can be at most one circle containing the two corners (0, 0) and (xCorner, yCorner) at the same time.\n\nIn addition, for each circle, there are only two cases: either it intersects the rectangle in the middle or it lies completely inside the rectangle.\n\nIf any circle intersects the middle, then it intersects one of the two sides of the rectangle. For the top side, we can just check if it’s a tangent circle, and for the left side, we need to check whether a point on the line is in the circle and whether the point is inside the rectangle. In total, we need at most 4 checks for each circle to determine whether it intersects the middle of the rectangle.\n\nIf it does not intersect the middle, it is a candidate to completely contain the rectangle.\nFor each circle, we can iterate over each circle and check whether this circle completely contains the rectangle.\nAs the original task has been simplified to the task of detecting whether two circles intersect, we can use DFS to do so.\n\"\"\"\n\n\nfrom typing import *\n\n\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            if i == 0 and in_circle(0, 0, X, Y, X):\n                return True\n            vis", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and \\\n                   (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or \\\n               in_circle(x, y, r, X, Y) or \\\n               not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/57", "content": "\nTest examples:\n\n[0, 1, 1, 0, 2, 2]\n\nTrue\n\n\n\n[1, 2, 1, 0, 2, 2]\n\nTrue\n\n\n\n[1, 1, 1, 0, 2, 2]\n\nFalse\n\n\n\n[1, 2, 2, 0, 2, 2]\n\nFalse\n\nSolution:\nimport math\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        vis = [False]*len(circles)\n        def dfs(i,x,y):\n            if x==X and y==Y:\n                return True\n            vis[i]=True\n            for j,c in enumerate(circles):\n                ox,oy,r=c[0],c[1],c[2]\n                if math.sqrt((ox-x)**2+(oy-y)**2)>r:\n                    if not vis[j]:\n                        if dfs(j,ox,oy):\n                            return True\n            vis[i]=False\n            return False\n        return dfs(0,0,0)/src/剑指offer/44_翻转单词.java\npackage 剑指offer;\n\nimport java.util.Stack;\n\n/**\n * @author kai.wang\n * @description\n * @date 2020-09-10 10:29:00\n */\npublic class 翻转单词序列 {\n    public String ReverseSentence(String str) {\n        if (str.trim().length()==0) {\n            return str;\n        }\n        String[] s = str.trim().split(\" \");\n        StringBuffer sb = new StringBuffer();\n        for (int i = s.length - 1; i >= 0; i--) {\n            sb.append(s[i] + \" \");\n        }\n        return sb.substring(0, sb.length() - 1);\n    }\n}\n\n/**\n * @author kai.wang\n * @description\n * @date 2020-09-10 10:29:00\n */\nclass Solution45 {\n    public String reverseWords(String s) {\n        Stack<String", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and \\\n                   (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or \\\n               in_circle(x, y, r, X, Y) or \\\n               not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/58", "content": "\nThe expected return value is a positive integer.\n\"\"\"\n\n# -*- coding: utf-8 -*-\n# @Author  : SunQianFeng\n\n\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]) -> int:\n        if visited[start]:\n            return 0\n        visited[start] = True\n        count = 1\n        for i in range(len(graph[start])):\n            count += self.dfs(graph, graph[start][i], visited)\n        return count\n/LeetCode/246.回文排列.py\n\"\"\"\n246. 回文排列\n\n给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。\n\n回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。\n\n回文串不一定是字典当中的单词。\n\n示例1：\n输入：\"tactcoa\"\n输出：true（排列有\"tacocat\"、\"atcocta\"，等等）\n\"\"\"\n\n\nclass Solution:\n    def canPermutePalindrome(self, s: str) -> bool:\n        s_dict = dict()\n        for i in s:\n            if i not in s_dict:\n                s_dict[i] = 1\n            else:\n                s_dict[i] += 1\n        count = 0\n        for i in s_dict:\n            if s_dict[i] % 2 == 1:\n                count += 1\n            if count > 1:\n                return False\n        return True\n\n\n# 解法二\nclass Solution2:\n    def canPermutePalindrome(self, s: str) -> bool:\n        odd = set()\n        for i in s:\n            if i not in odd:\n                odd", "groundtruth": "class Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/59", "content": "Here, you need to submit the completed code of the class Solution.\n*/\n#include <iostream>\n#include <climits>\n#include <vector>\n#include <algorithm>\n#include <list>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj = new Solution(n, edges);\n * int param_1 = obj->findChampion();\n */\n\nclass Solution {\npublic:\n    int n = 0;\n    vector<vector<int>> graph;\n    vector<int> in;\n    int findChampion() {\n        queue<int> q;\n        for (int i = 0; i < this->n; i++) {\n            if (in[i] == 0) {\n                q.push(i);\n            }\n        }\n        int res = 0, cnt = 0;\n        while (q.size() > 0) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                int cur = q.front();\n                q.pop();\n                if (graph[cur].size() == 0) {\n                    cnt++;\n                    res = cur;\n                    continue;\n                }\n                for (int next : graph[cur]) {\n                    if (--in[next] == 0) {\n                        q.push(next);\n                    }\n                }\n            }\n            if (cnt > 1) {\n                return -1;\n            }\n        }\n        return cnt == 1? res : -1;\n    }\n\npublic:\n    Solution(int n, vector<vector<int>>& edges) : n(n), in(vector<int>(n, 0)), graph(vector<vector<int>>(n)) {\n        for (auto & edge : edges) {\n            graph[edge[0]].push_back(edge[1]);\n            in[edge[1]]++;\n        }\n    }\n};/1-Algorithm_test/leetcode/1-数据结构/3-散列表/389-找不同.cpp\n#include<iostream> \n#include<vector>\n#include <unordered_map>\nusing namespace std;\n\nvoid PrintVector(vector<int> v){\n\tfor(auto it", "groundtruth": "class Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/60", "content": "Please select the code that has the highest score.\n/LeetCode/978. Longest Turbulent Subarray.py\nclass Solution:\n    def maxTurbulenceSize(self, nums: List[int]) -> int:\n        ans = 1\n        n = len(nums)\n        status = 0 # 1表示当前是升序，-1表示当前是降序\n        for i in range(1, n):\n            if nums[i] == nums[i - 1]: # 如果相等，则状态设置为0\n                status = 0\n            elif nums[i] > nums[i - 1]: # 如果大于，则状态设置为1\n                status = 1\n            elif nums[i] < nums[i - 1]: # 如果小于，则状态设置为-1\n                status = -1\n            # 计算答案\n            if status == 1 and nums[i] < nums[i - 1] or status == -1 and nums[i] > nums[i - 1]: # 如果当前状态等于1并且之前是-1，表示满足题意，则答案加1\n                ans += 1\n            else:\n                ans = 1\n        return ans\n/LeetCode/942. DI String Match.py\nclass Solution:\n    def diStringMatch(self, s: str) -> List[int]:\n        l = 0\n        r = len(s)\n        ans = []\n        for i in s:\n            if i == \"I\":\n                ans.append(l)\n                l += 1\n            else:\n                ans.append(r)\n                r -= 1\n        ans.append(l)\n        return ans\n/LeetCode/988. Smallest String Starting From Leaf.py\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def smallestFromLeaf(self, root: TreeNode) -> str:\n        @lru_cache(None)\n        def dfs(node):\n            if not node.left and not node.right:\n                return chr(node.val + 97)\n            else:\n                l, r = dfs(node.left), dfs(node.", "groundtruth": "class Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v != p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp1 + nums[u], dp0)\n            \n        return dfs(0)[1]\n"}
{"task_id": "python/61", "content": "'''\n\nclass Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        self.vis = set()\n        self.nums = nums\n        def dfs(u, p=-1):\n            tot, summ = 0, 0\n            for v, w in edges:\n                if v!= p and v not in self.vis:\n                    # 取子树的最大值与路径和\n                    a, b = dfs(v, u)\n                    if b!= 0:\n                        self.vis.add(u)\n                        self.vis.add(v)\n                    tot += a\n                    summ += abs(b)\n            self.vis.add(u)\n            # 以当前点为根的树的和为该树的路径和与和非0子树和的最大值\n            return max(tot + nums[u], summ), nums[u]\n        return dfs(0)[0]\n\n/python/085. 计数质数.py\n# -*- coding: utf-8 -*-\n'''\n请你帮忙统计一下我们已经储备了的优质证券里共有多少种不同类的股票？\n示例：\n输入: nums = \n[\n  [1,2],\n  [2,3],\n  [3,4],\n]\n输出: 1\n\n解释: \n只有一个唯一的优质证券，对应的股票编号组合为 [1,2]。\n提示：\n\nnums的长度范围为 [1, 500]。\nnums[i]的长度范围为 [1, 500]。\nnums[i][j]是一个介于 0 到 10^9 之间的整数。\n'''\n\n# 输入: nums = [[1,2],[2,3],[3,4]]\n# nums[0].append(6)\n# nums[1].append(9)\n# nums[2].append(10)\n# print(nums)\n# [[1, 2, 6], [2, 3, 9], [3, 4, 10]]\n# nums.append([2, 3, 4])\n# print(nums)\n# [[1, 2, 6], [2,", "groundtruth": "class Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v != p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp1 + nums[u], dp0)\n            \n        return dfs(0)[1]\n"}
{"task_id": "python/62", "content": "Output Specification\nThe output is an integer, denoting the maximum sum of a balanced subsequence of nums.\nExample\nInput\n12 4 4 2 5 3\nOutput\n9/Codeforces/Round 695 - Div. 2/C.cpp\n#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n\nint n;\nint arr[1000001] = {0};\nint k[1000001] = {0};\n\nmap<int, int> m;\nvector<pair<int, int>> p;\nvector<int> q;\nvector<pair<int, int>> r;\n\nint main()\n{\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        cin >> arr[i];\n    for (int i = 0; i < n; i++)\n        cin >> k[i];\n    for (int i = 0; i < n; i++)\n    {\n        p.push_back(make_pair(k[i], arr[i]));\n        r.push_back(make_pair(k[i], arr[i]));\n    }\n    sort(p.begin(), p.end());\n    int j = 0;\n    int t = -1;\n    for (int i = 0; i < n; i++)\n    {\n        if (t!= p[i].first)\n        {\n            j = 0;\n            q.push_back(p[i].first);\n            t = p[i].first;\n            m[q.back()] = q.size() - 1;\n        }\n        while (j < p[i].first)\n        {\n            j++;\n            arr[j] = p[i].second;\n        }\n    }\n\n    for (int i = 0; i < n; i++)\n        cout << arr[r[i].first] <<'';\n}\n/BOJ/9370.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint t, n, m, s, g, h;\nbool used[2002];\nbool vis[2002];\nvector<pair<int, int>> v;\nvector", "groundtruth": "class Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/63", "content": "The test data is as follows:\nExample 1:\nEnter: nums = [1,1,2], k = 2\nOutput: 3\nThe explanation: The bit positions 2 and 3 of the result are set to 1, because at least 2 numbers in nums have a 1 in that position.\n\nExample 2:\nEnter: nums = [3,4,5,2], k = 3\nOutput: 5\nThe explanation: The bit position 2 of the result is set to 1, because at least 3 numbers in nums have a 1 in that position.\n\nExample 3:\nEnter: nums = [2,2,3,5], k = 2\nOutput: 5\nThe explanation: All the numbers in nums have a 1 in the bit position 2, so this bit in the result is also set to 1.\n\n\nHint: Bit Operations, Enumeration, Prefix Sum\n\"\"\"\nclass Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        length = len(nums[0])\n        result = 0\n        for i in range(length):\n            count = 0\n            for j in range(len(nums)):\n                if nums[j] & (1 << i):\n                    count += 1\n            if count >= k:\n                result = result | (1 << i)\n        return result\n       l -= 1\n        r = size-1\n        while l >= 0 and nums[l] == nums[r]:\n            l -= 1\n        if l >= 0:\n            nums[index], nums[l] = nums[l], nums[index]\n        nums[index+1:] = nums[index+1:][::-1]\n        return\n\"\"\"\n46. Permutations\nMedium\n\n1566\n\n128\n\nAdd to List\n\nShare\nGiven an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\n\n\n\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\nExample 2:\n\nInput: nums =", "groundtruth": "class Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for i in range(max(nums).bit_length()):\n            cnt1 = sum(x >> i & 1 for x in nums)\n            if cnt1 >= k:\n                ans |= 1 << i\n        return ans\n"}
{"task_id": "python/64", "content": "There are 1 point for completing the question, 0 for each additional incorrect answer, and 0 for not completing the question.\n'''\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n\n        if zero1 + zero2!= len(nums1) + len(nums2):\n            return -1\n\n        if zero1 == zero2 == 0:\n            return max(sum1, sum2)\n\n        if sum1 > sum2:\n            sum1, sum2 = sum2, sum1\n            nums1, nums2 = nums2, nums1\n            zero1, zero2 = zero2, zero1\n\n        # print(sum1, sum2)\n        # print(zero1, zero2)\n\n        l, r = 0, 5001\n        while l < r:\n            mid = (l + r) // 2\n            new_sum = sum1 + mid * zero1\n            if new_sum < sum2:\n                l = mid + 1\n            else:\n                r = mid\n\n        return r\n\n\nnums1 = [1, 2, 5, 0, 0, 0, 0, 0]\nnums2 = [2, 6, 10]\nprint(Solution().minSum(nums1, nums2))import pymysql\n\nclass MysqlHelper():\n\tdef __init__(self, host, port, db, user, passwd, charset=\"utf8\"):\n\t\tself.host = host\n\t\tself.port = port\n\t\tself.db = db\n\t\tself.user = user\n\t\tself.passwd = \n\t\tself.charset = charset\n\n\tdef connect(self):\n\t\tself.conn = pymysql.Connect(\n\t\t\thost=self.host,\n\t\t\tport=self.port,\n\t\t\tdb=self.db,\n\t\t\tuser=self.user,\n\t\t\tpasswd=,\n\t\t\tcharset=self.charset\n\t\t)\n\n\tdef get_one(self, sql, params=()):\n\t\tcursor = self.conn.", "groundtruth": "class Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n\n"}
{"task_id": "python/65", "content": "\nSample input:\n[5,3,2,4,1]\n3\nSample output:\n3\n\n* 题目大意: 给定一个长度为 N 的数组，初始值全为 0，有两种操作。\n第一种操作，选取 [0..n-1] 中的任意一个数，让其 +1。第二种操作，选取 [0..n-1] 中的任意两个数，令其中较小的数加 1。\n\n问最少多少次操作，使得数组中所有数都大于等于 K。\n\n* 考察知识点：Greedy + 优先队列\n```cpp\n/**\n * 贪心 + 优先队列\n */\nclass Solution {\npublic:\n    int minIncrementForUnique(vector<int>& A) {\n        sort(A.begin(), A.end());\n        \n        // 取一个比数组里所有元素都要大的值，作为「哨兵」元素，这样就可以不考虑数组元素超过 INT_MAX 的情况了\n        priority_queue<int, vector<int>, greater<int>> pq;\n        pq.push(100000);\n        \n        int ret = 0, cur = 0;\n        for (int i = 0; i < A.size(); i++) {\n            // 因为要保证元素互不相同，所以如果要取一个大于等于当前值的数作为「哨兵」，当前值和哨兵的值一定会有重复\n            // 如果当前值没有被用过，那就不要让它参与到「哨兵」的计算了\n            if (pq.top() == cur) {\n                // 使用了重复的元素，就再取一个\n                cur = A[i];\n                pq.push(A[i] + 1);\n            } else {\n                // 没用重复元素，直接用\n                int diff = A[i] - cur;\n                ret += diff;\n                pq.pop();\n                pq.push(pq.top() + diff + 1);\n                cur = pq.top();\n            }\n        }\n        \n        return ret;\n    }\n};\n```\n\n\n### 14. 分糖果\n\n请在下面填写完成本题目对应的函数，分糖果。\n\n问题描述: 请在下面填写完成本题目", "groundtruth": "class Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n        dp1 = dp2 = dp3 = 0\n        for num in nums:\n            dp1, dp2, dp3 = min(dp1, dp2, dp3) + max(0, k - num), dp1, dp2\n        return min(dp1, dp2, dp3)\n"}
{"task_id": "python/66", "content": "Please complete this function according to the requirement.\n\n\nSample input and output format\nSample 1:\n\nInput:\n[[0,2],[2,1],[0,3],[0,4],[0,5],[3,7],[3,6],[4,8]]\n[10,2,1,6,4,10,3,5,5]\n2\nOutput:\n21\nExplanation:\nCoins in the tree are as follows:\n     10\n     / \\\n  2   1   \n  / \\    \n(6)  4 \n / \\ \n3  5 \n \\ \n  5 \nIf we collect coins on the nodes with red labels, we will get 3 + floor(2 / 2) + floor(4 / 2) + 5 + 5 = 21.\nCoins at node 2 will be 10 and k = 2, so if we use coins[2] - k, we will get 8 points. If we use floor(coins[2] / 2), then coins[6] and coins[7] will be 1 and we will get 8 - 6 + 3 = 5 points, but the coins at node 2 will be reduced to 1.\nSample 2:\n\nInput:\n[[0,4],[0,3],[0,2],[0,1],[1,5],[1,6],[4,7],[4,8],[8,9],[3,10],[3,11],[3,12]]\n[10,10,10,4,6,4,2,5,3,10,4,5]\n3\nOutput:\n32\nExplanation:\nCoins in the tree are as follows:\n              10\n             / \n          4 \n         /  \n      10\n      / \\\n  6      4\n  / \\\n2   5  3 \n \\\n  10\n    /  \\\n4     5 \nIf we collect coins on the nodes with red labels, we will get 10 + 2 + 10 + 4 + 10 = 32.\nFor example, coins[2] is 4 and k = 3, so if we use coins[2] - k, we will get 1 point. If we use floor(coins[2] / 2), then", "groundtruth": "class Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i) \n                    if j < 13: \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n"}
{"task_id": "python/67", "content": "The code should be clear and easy to understand. Do not use too many external libraries, especially those used to solve math-related problems. (If you need to use a library, please write the required code and explain in detail how to use it. But it is better not to use it.)\nThe code must be completed within 5 minutes, and the completed code must be able to run without error.\n\n\n## Solution\n\n### 1. Segment Tree\n\n> https://leetcode.cn/problems/sum-of-squared-lengths-of-unique-segments/solutions/2264906/by-lcbin-4s2q/\n\n```py\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = [0] * (n * 4)\n        todo = [0] * (n * 4)\n\n        def do(o: int, l: int, r: int, add: int) -> None:\n            sum[o] += add * (r - l + 1)\n            todo[o] += add\n\n        # o=1  [l,r] 1<=l<=r<=n\n        # 把 [L,R] 加一，同时返回加一之前的区间和\n        def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:\n            if L <= l and r <= R:\n                do(o, l, r, 1)\n                return sum[o]\n            ans = 0\n            mid = (l + r) // 2\n            if L <= mid:\n                ans += query_and_add1(o * 2, l, mid, L, R)\n            if R > mid:\n                ans += query_and_add1(o * 2 + 1, mid + 1, r, L, R)\n            sum[o] = sum[o * 2] + sum[o * 2 + 1]\n            sum[o] += todo[o] * (r - l + 1)\n            return ans\n\n        ans = s = 0\n        last = {}\n        for i, x in enumerate(nums, 1):\n            j = last.get(x, 0)\n            s += query_and", "groundtruth": "\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = [0] * (n * 4)\n        todo = [0] * (n * 4)\n\n        def do(o: int, l: int, r: int, add: int) -> None:\n            sum[o] += add * (r - l + 1)\n            todo[o] += add\n\n        # o=1  [l,r] 1<=l<=r<=n\n        # 把 [L,R] 加一，同时返回加一之前的区间和\n        def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:\n            if L <= l and r <= R:\n                res = sum[o]\n                do(o, l, r, 1)\n                return res\n\n            m = (l + r) // 2\n            add = todo[o]\n            if add:\n                do(o * 2, l, m, add)\n                do(o * 2 + 1, m + 1, r, add)\n                todo[o] = 0\n\n            res = 0\n            if L <= m: res += query_and_add1(o * 2, l, m, L, R)\n            if m < R:  res += query_and_add1(o * 2 + 1, m + 1, r, L, R)\n            sum[o] = sum[o * 2] + sum[o * 2 + 1]\n            return res\n\n        ans = s = 0\n        last = {}\n        for i, x in enumerate(nums, 1):\n            j = last.get(x, 0)\n            s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j\n            ans += s\n            last[x] = i\n        return ans % 1_000_000_007\n"}
{"task_id": "python/68", "content": "You can only output the code provided in the answer box.\nYou are not allowed to change the code for other variables.\nNote: The judger will call the test data you input, and check the value of the sum of squares of distinct counts of all subarrays.\nIf the output you want is the sum of squares of all distinct counts of subarrays (which is obviously wrong), the result is 0.\nIf the output is within 10^-6 of the correct answer, it will be judged as correct.\nThe value of n, and the values in nums[i] in the test case data satisfy 1 <= n <= 10^4.\nIf the output is within 10^-6 of the correct answer, the result is judged as correct.\n*/\n#pragma once\n#include \"leetcode.h\"\n\n//暴力法\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> res;\n        // 枚举 a\n        for (int first = 0; first < nums.size(); ++first) {\n            // 需要和上一次枚举的数不相同\n            if (first > 0 && nums[first] == nums[first - 1]) {\n                continue;\n            }\n            // c 对应的指针初始指向数组的最右端\n            int third = nums.size() - 1;\n            int target = -nums[first];\n            // 枚举 b\n            for (int second = first + 1; second < nums.size(); ++second) {\n                // 需要和上一次枚举的数不相同\n                if (second > first + 1 && nums[second] == nums[second - 1]) {\n                    continue;\n                }\n                // 需要保证 b 的指针在 c 的指针的左侧\n                while (second < third && nums[second] + nums[third] > target) {\n                    --third;\n                }\n                // 如果指针重合，随着 b 后续的增加\n                // 就不会有满足 a+b+c=0 并且 b<c 的 c 了，可以退出循环\n                if (second == third) {\n                    break;\n                }\n                if (nums[second] + nums[third] == target) {\n                    res.push_", "groundtruth": "\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = [0] * (n * 4)\n        todo = [0] * (n * 4)\n\n        def do(o: int, l: int, r: int, add: int) -> None:\n            sum[o] += add * (r - l + 1)\n            todo[o] += add\n\n        # o=1  [l,r] 1<=l<=r<=n\n        # 把 [L,R] 加一，同时返回加一之前的区间和\n        def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:\n            if L <= l and r <= R:\n                res = sum[o]\n                do(o, l, r, 1)\n                return res\n\n            m = (l + r) // 2\n            add = todo[o]\n            if add:\n                do(o * 2, l, m, add)\n                do(o * 2 + 1, m + 1, r, add)\n                todo[o] = 0\n\n            res = 0\n            if L <= m: res += query_and_add1(o * 2, l, m, L, R)\n            if m < R:  res += query_and_add1(o * 2 + 1, m + 1, r, L, R)\n            sum[o] = sum[o * 2] + sum[o * 2 + 1]\n            return res\n\n        ans = s = 0\n        last = {}\n        for i, x in enumerate(nums, 1):\n            j = last.get(x, 0)\n            s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j\n            ans += s\n            last[x] = i\n        return ans % 1_000_000_007\n"}
{"task_id": "python/69", "content": "\nAnalysis of the algorithm:\nDefine dp[i] to be the number of changes required to make the first 2 ^ i bits of s beautiful, and dp[i][j] to be the number of changes when the number of 0's and 1's is j in the 2 ^ i bits.\nObviously, for each 2 ^ i bits, the number of 0's and 1's should always be equal, so only dp[i][2 ^ (i - 1)] needs to be calculated.\nFor each state dp[i][j], we try to add a 0 bit or a 1 bit to it to make it a beautiful string, which will correspond to dp[i + 1][j + 2 ^ i], dp[i + 1][j] or dp[i + 1][j - 2 ^ i] to be changed.\nFinally, the answer is obtained through the dp array.\n\nCode implementation:\n\nclass Solution:\n    def minChanges(self, s: str) -> int:\n        n = 1 << len(s)\n        dp = [n for _ in range(n // 2)]\n        m = len(s)\n\n        for i in range(m):\n            cnt_0, cnt_1 = 0, 0\n            # Count 0's and 1's in the 2^i bits\n            for j in range(n):\n                if s[i] == '0' and j & (1 << i):\n                    cnt_0 += 1\n                if s[i] == '1' and j & (1 << i):\n                    cnt_1 += 1\n\n            # Try to add a 0 bit or 1 bit to dp[i][j] and make it a beautiful string\n            for j in range(n // 2):\n                add_one = dp[j] + cnt_0 + n - cnt_1 - j\n                add_zero = dp[j] + cnt_1 + n - cnt_0 - j\n\n                # Update dp[i + 1][j + 2 ^ i], dp[i + 1][j] and dp[i + 1][j - 2 ^ i]\n                dp[j + 2 ** i] = min(dp[j + 2 ** i], min(add_one, add_zero))\n                dp[j", "groundtruth": "\nclass Solution:\n    def minChanges(self, s: str) -> int:\n        cnt = 0\n        for i in range(0, len(s), 2):\n            if len(set(s[i:i + 2])) > 1:\n                cnt += 1\n                \n        print(s)\n        return cnt\n"}
{"task_id": "python/70", "content": "\n\"\"\"\n\n\nclass Solution:\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        dp = [[0 for _ in range(target+1)] for _ in range(n+1)]\n        for i in range(n):\n            for j in range(target+1):\n                dp[i+1][j] = dp[i][j]\n                if j>=nums[i]:\n                    dp[i+1][j] = max(dp[i+1][j],dp[i][j-nums[i]]+1)\n        return dp[n][target] if dp[n][target] else -1\n\n\"\"\"\n\nGiven a string s consists of some words separated by some number of spaces, return the length of the last word in the string. If the last word does not exist, return 0.A word is a maximal substring consisting of non-space characters only.\n\nThe incomplete code is as follows:\n\nclass Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        ____\n\nGive only the completed code. Do not output any additional information.\n\n\"\"\"\n\n\nclass Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        words = s.split(' ')\n        index = len(words)-1\n        while index>=0:\n            if words[index]:\n                return len(words[index])\n            index -= 1\n        return 0\n\"\"\"\n\nThere are n people standing in a line and each person is assigned a unique id from 0 to n - 1.The players are arranged in increasing order of their ids by default.\nEach person wants to change his position in the line to optimize his happiness. The happiness of a person is the difference between the number of people that stand before him and the number of people that stand after him.\nNow you are given an array of integers where the i-th element is the id of the person standing at the i-th position.\nEach person is happy initially, and you need to make the minimum number of happy person unhappy, and return the number of people who remain happy after the adjustment.\nThe incomplete code is as follows:\n\nclass Solution:\n    def minimumMoves(self, nums: List[int]) -> int:\n       ", "groundtruth": "\nclass Solution:\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        f = [0] + [-inf] * target\n        s = 0\n        for x in nums:\n            s = min(s + x, target)\n            for j in range(s, x - 1, -1):\n                # f[j] = max(f[j], f[j - x] + 1)\n                if f[j] < f[j - x] + 1:\n                    f[j] = f[j - x] + 1\n        return f[-1] if f[-1] > 0 else -1\n"}
{"task_id": "python/71", "content": "\ndef f(a: List[int], mx: int) -> Set[int]:\n    ans = set()\n    s = set()\n    for x in a:\n        s ^= {x}\n        ans |= {y - x for y in s} & {x - y for y in s}\n        for y in ans:\n            ans |= {y - x + mx}\n    return ans\n\n\nif __name__ == '__main__':\n    print(Solution().maximizeSquareArea(5, 4, [3, 1], [1, 4]))  # 4\n    print(Solution().maximizeSquareArea(5, 5, [2, 1, 5], [1, 3, 4]))  # 16\n    print(Solution().maximizeSquareArea(3, 3, [1], [1]))  # -1\nimport sys\n\nsys.setrecursionlimit(int(1e9))\nimport io, os, math\n\nfrom collections import *\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nOUTPUT_PATH = \"OUTPUT.txt\"\nsys.stdout = open(OUTPUT_PATH, \"w\")\n\nMOD = 998244353\n\ndef my_main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    d = {}\n    for i in a:\n        d[i] = d.get(i,0) + 1\n    for i in range(max(a),0,-1):\n        x = i\n        while x <= max(a):\n            if d.get(x) == 1:\n                x = x+i\n            else:\n                break\n        if x == max(a)+i:\n            print(i)\n            exit()\n            \n\n\n# 0-indexed\ndef solve_binary_indexed_tree():\n    n, m, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.insert(0, 0)  # 1-indexed\n\n    def lowbit(x: int):\n        return x & -x\n\n    bi_tree = [0 for _ in range(n + 1)]\n    def add(x: int):\n        while x <= n:\n            bi_tree[x] +=", "groundtruth": "\nclass Solution:\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n        h = self.f(hFences, m)\n        v = self.f(vFences, n)\n        ans = max(h & v, default=0)\n        return ans ** 2 % 1_000_000_007 if ans else -1\n\n    def f(self, a: List[int], mx: int) -> Set[int]:\n        a.extend([1, mx])\n        a.sort()\n        return set(y - x for x, y in combinations(a, 2))\n"}
{"task_id": "python/72", "content": "The correct code is as follows:\n\nclass Solution:\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n        res = 1\n        MOD = 10 ** 9 + 7\n\n        def f(a: List[int], mx: int) -> Set[int]:\n            res = set()\n            n = len(a)\n            g = [[-1] * (n + 1) for _ in range(mx + 1)]\n            for i in range(1, n + 1):\n                for j in range(1, mx + 1):\n                    if a[i - 1] <= j:\n                        g[j][i] = max(g[j - a[i - 1]][i - 1] + 1, g[j][i - 1])\n                    else:\n                        g[j][i] = g[j][i - 1]\n            for j in range(mx, -1, -1):\n                if g[j][n] > 0:\n                    res.add(j)\n            return res\n\n        b1, b2 = f(hFences, n), f(vFences, m)\n\n        for i in b1:\n            if i in b2 and i ** 2 > res:\n                res = i ** 2\n        return res % MOD\n\nDescription of the problem solution:\nFirst of all, all the gaps on the horizontal and vertical sides are calculated, and then find a maximum value that exists at the same time on the horizontal and vertical sides.\nThe above solution uses dynamic programming to find the maximum value that meets the horizontal and vertical conditions.\n\nIn the code, the res variable is set to 1 to prevent the res variable from becoming 0. The value of MOD is 10 ** 9 + 7. Then define the function f(a: List[int], mx: int) -> Set[int], which finds the maximum values that meets the horizontal and vertical conditions, and the return type is Set[int].\n\nres = set() is used to initialize the results set. The n variable is the length of the a array. g = [[-1] * (n + 1) for _ in range(mx + 1)] is used to initialize the two", "groundtruth": "\nclass Solution:\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n        h = self.f(hFences, m)\n        v = self.f(vFences, n)\n        ans = max(h & v, default=0)\n        return ans ** 2 % 1_000_000_007 if ans else -1\n\n    def f(self, a: List[int], mx: int) -> Set[int]:\n        a.extend([1, mx])\n        a.sort()\n        return set(y - x for x, y in combinations(a, 2))\n"}
{"task_id": "python/73", "content": "The output is 7. You start with source and one operation, changing the first character from 'e' to 'y', in 2 dollars. This gives us \"you\". Next, one operation, changing the second character from 'u' to 'f', in 5 dollars. This gives us target \"yof\".\n\nExample 2:\n\nInput: source = \"abc\", target = \"abcbc\", original = [\"a\",\"b\"], changed = [\"z\",\"w\"], cost = [4,7]\nOutput: -1\nExplanation: source cannot be converted to target using any number of operations. Note that changing \"a\" to \"z\" and \"b\" to \"w\" in a single operation is possible.\n\nExample 3:\n\nInput: source = \"abc\", target = \"acdbc\", original = [\"a\"], changed = [\"z\"], cost = [1]\nOutput: 3\nExplanation: We can change 'c' in source to 'd' for 1 dollar, then change 'b' to 'c' for 1 dollar, and change 'c' to 'd' for 1 dollar. The total cost is 3 dollars. Note that we could make the change for 1 dollar in a single operation.\n\nConstraints:\n\nn == source.length == target.length\nn == original.length == changed.length\n1 <= n <= 10^5\n1 <= original[i].length, changed[i].length <= 10\nsource, target, original[i] and changed[i] consist of only lowercase English letters.\n1 <= cost.length <= 10^5\n0 <= cost[i] <= 10^9\n'''\n\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        dic = collections.defaultdict(int)\n        for i in range(len(original)):\n            dic[original[i]] = (cost[i],changed[i])\n        total = 0\n        for i in range(len(source)):\n            if source[i]!= target[i] and source[i] not in dic:\n                return -1\n            if source[i]!= target[i] and source[i] in dic:\n                if (dic[", "groundtruth": "\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        dis = [[inf] * 26 for _ in range(26)]\n        for i in range(26):\n            dis[i][i] = 0\n\n        for x, y, c in zip(original, changed, cost):\n            x = ord(x) - ord('a')\n            y = ord(y) - ord('a')\n            dis[x][y] = min(dis[x][y], c)\n\n        for k in range(26):\n            for i in range(26):\n                for j in range(26):\n                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))\n        return ans if ans < inf else -1\n"}
{"task_id": "python/74", "content": "\nExamples\nExample 1:\n\nInput: source = \"ab\", target = \"cd\", original = [\"a\", \"b\", \"c\"], changed = [\"c\", \"d\", \"a\"], cost = [20, 6, 12]\n\nOutput: 22\n\nExplanation: In the first operation, we pick the substring \"a\" in \"ab\", and change it to \"c\". The cost of this operation is cost[1] = 6. The resulting string is \"cb\".\nIn the second operation, we pick the substring \"cb\" in \"cb\", and change it to \"cd\". The cost of this operation is cost[0] = 20. The resulting string is \"cd\".\nThe total cost is 6 + 20 = 26.\nNote that in the first operation, we could also pick the substring \"a\" and change it to \"d\". In this case, the total cost would be 20 + 6 = 26. We can show that it is impossible to obtain the string \"cd\" with a smaller cost, so it is optimal to change the \"a\" to \"c\".\nExample 2:\n\nInput: source = \"abc\", target = \"def\", original = [\"ab\",\"bc\",\"abc\"], changed = [\"de\",\"ef\",\"fed\"], cost = [11,5,6]\n\nOutput: 6\n\nExplanation: In the first operation, we pick the substring \"abc\" in \"abc\", and change it to \"fed\". The cost of this operation is cost[2] = 6. The resulting string is \"fed\".\nThe total cost is 6.\nIt can be shown that it is impossible to obtain the string \"def\" with a smaller cost, so it is optimal to change the \"abc\" to \"fed\".\nExample 3:\n\nInput: source = \"ad\", target = \"cb\", original = [\"ad\",\"cab\",\"bac\",\"abc\",\"ac\"], changed = [\"dc\",\"dcb\",\"cdb\",\"cbd\",\"cb\"], cost = [9,3,10,5,8]\n\nOutput: -1\n\nExplanation: It can be shown that it is impossible to obtain the string \"cb\" using any number of operations.\nFollow-up 1: Why do we initialize cost[i][i] to 0?\nFollow-up 2:", "groundtruth": "\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        len_to_strs = defaultdict(set)\n        dis = defaultdict(lambda: defaultdict(lambda: inf))\n        for x, y, c in zip(original, changed, cost):\n            len_to_strs[len(x)].add(x)  \n            len_to_strs[len(y)].add(y)\n            dis[x][y] = min(dis[x][y], c)\n            dis[x][x] = 0\n            dis[y][y] = 0\n\n        for strs in len_to_strs.values():\n            for k in strs:\n                for i in strs:\n                    if dis[i][k] == inf:  \n                        continue\n                    for j in strs:\n                        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        @cache\n        def dfs(i: int) -> int:\n            if i == 0:\n                return 0\n            res = inf\n            if source[i - 1] == target[i - 1]:\n                res = dfs(i - 1) \n            for size, strs in len_to_strs.items():  \n                if i < size:\n                    continue\n                s = source[i - size: i]\n                t = target[i - size: i]\n                if s in strs and t in strs:  \n                    res = min(res, dis[s][t] + dfs(i - size))\n            return res\n        ans = dfs(len(source))\n        return ans if ans < inf else -1\n"}
{"task_id": "python/75", "content": "\nSample Input 1 Copy\nsource = \"abcd\"\ntarget = \"acdb\"\noriginal = [\"a\",\"b\",\"c\",\"d\",\"abcd\"]\nchanged = [\"aaaa\",\"bb\",\"ccc\",\"d\",\"cdabcd\"]\ncost = [1,9,3,4,5]\nSample Output 1\n8\nExplanation\nWe perform the following operations (indices are 0-indexed):\n\nSubstring \"cd\" can be converted to changed[2] == \"ccc\" at a cost of cost[2] == 3.\nSubstring \"ccc\" can be converted to changed[4] == \"cdabcd\" at a cost of cost[4] == 5.\nSubstring \"cdabcd\" can be converted to changed[1] == \"bb\" at a cost of cost[1] == 9.\nSubstring \"bb\" can be converted to changed[0] == \"aaaa\" at a cost of cost[0] == 1.\nThere are no more operations to be performed, so the total cost is 1 + 3 + 5 + 9 = 18.\nThus, we return 8.\n\nSample Input 2 Copy\nsource = \"abcd\"\ntarget = \"abcd\"\noriginal = [\"abcd\",\"acbd\",\"aaaa\"]\nchanged = [\"aaaa\",\"acbd\",\"acdb\"]\ncost = [0,1,1]\nSample Output 2\n0\nExplanation\nThere are no characters to be converted, so we return 0.\n\nSample Input 3 Copy\nsource = \"abcd\"\ntarget = \"cbad\"\noriginal = [\"a\",\"b\",\"c\",\"d\",\"abcd\"]\nchanged = [\"aaaa\",\"bb\",\"ccc\",\"d\",\"cdabcd\"]\ncost = [1,9,3,4,5]\nSample Output 3\n-1\nExplanation\nSince it is not possible to convert all characters, we return -1.\n \nConstraints:\n\n1 <= source.length == target.length == original.length == changed.length <= 50\n1 <= cost.length <= 105\n1 <= original[i].length <= 2\n1 <= changed[i].length <= 2\ncost.length == the number of unique strings in original\ncost.length == the number of unique strings in changed\n1 <= cost[i] <= 109\nsource, target, original[i", "groundtruth": "\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        len_to_strs = defaultdict(set)\n        dis = defaultdict(lambda: defaultdict(lambda: inf))\n        for x, y, c in zip(original, changed, cost):\n            len_to_strs[len(x)].add(x)  \n            len_to_strs[len(y)].add(y)\n            dis[x][y] = min(dis[x][y], c)\n            dis[x][x] = 0\n            dis[y][y] = 0\n\n        for strs in len_to_strs.values():\n            for k in strs:\n                for i in strs:\n                    if dis[i][k] == inf:  \n                        continue\n                    for j in strs:\n                        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        @cache\n        def dfs(i: int) -> int:\n            if i == 0:\n                return 0\n            res = inf\n            if source[i - 1] == target[i - 1]:\n                res = dfs(i - 1) \n            for size, strs in len_to_strs.items():  \n                if i < size:\n                    continue\n                s = source[i - size: i]\n                t = target[i - size: i]\n                if s in strs and t in strs:  \n                    res = min(res, dis[s][t] + dfs(i - size))\n            return res\n        ans = dfs(len(source))\n        return ans if ans < inf else -1\n"}
{"task_id": "cpp/0", "content": "\nInput Format:\nAn integer array describing n (0 < n < 20).\n\nOutput Format:\nThe answer to the problem, modulo 109 + 7.\n\nExplanation:\nThe completed code is as follows:\n\nclass Solution {public:\nstatic const int mod = 1e9 + 7;\n\nint specialPerm(vector<int>& nums) {\nint n = nums.size();\nvector<vector<int>> f(1 << n, vector<int>(n, -1));\nfunction<int(int, int)> dfs = [&](int state, int i) {\nif (f[state][i]!= -1) {\nreturn f[state][i];\n}\nif (state == (1 << i)) {\nreturn 1;\n}\nf[state][i] = 0;\nfor (int j = 0; j < n; j++) {\nif (i == j ||!(state >> j & 1)) {\ncontinue;\n}\nif (nums[i] % nums[j]!= 0 && nums[j] % nums[i]!= 0) {\ncontinue;\n}\nf[state][i] = (f[state][i] + dfs(state ^ (1 << i), j)) % mod;\n}\nreturn f[state][i];\n};\nint res = 0;\nfor (int i = 0; i < n; i++) {\nres = (res + dfs((1 << n) - 1, i)) % mod;\n}\nreturn res;\n}\n};\n\n## 2. Description\n\nGive a positive integer n and q query array a. The problem is to count how many integers i in the range [1, n] such that i&a[j] > 0, 1 ≤ j ≤ q. For the final answer please output the sum of all answers modulo 1000000007.\n\nn, q ≤ 10^5, each a[i] ≤ 10^6.\n\n## 1.Title\n\n1. There are m nodes in the undirected network. Label the i-th node as 1 �", "groundtruth": "class Solution {public:static const int mod = 1e9 + 7;int specialPerm(vector<int>& nums) {int n = nums.size();vector<vector<int>> f(1 << n, vector<int>(n, -1));function<int(int, int)> dfs = [&](int state, int i) {if (f[state][i] != -1) {return f[state][i];}if (state == (1 << i)) {return 1;}f[state][i] = 0;for (int j = 0; j < n; j++) {if (i == j || !(state >> j & 1)) {continue;}if (nums[i] % nums[j] != 0 && nums[j] % nums[i] != 0) {continue;}f[state][i] = (f[state][i] + dfs(state ^ (1 << i), j)) % mod;}return f[state][i];};int res = 0;for (int i = 0; i < n; i++) {res = (res + dfs((1 << n) - 1, i)) % mod;}return res;}};"}
{"task_id": "cpp/1", "content": "\nAnalysis\n\nThe idea is to use dynamic programming. The state space is defined as $f[i][j]$ means that the painting cost for the wall painted by painter 0 to i is paid, and the time to paint the wall painter 1 to paint the jth wall. In the process of traversal, the time of the wall painted by the paid painter can only be a multiple of the time of the wall painted by the free painter.\n\n• If you want to paint the wall of painter 0 to paint the i-th wall, there are two options:\n1. painter 1 has finished painting, and then painter 0 paints the i-th wall.\n2. When painter 1 has not yet painted, painter 0 paints the i-th wall.\n• If you want to paint the wall of painter 1 to paint the j-th wall, there are two options:\n1. painter 0 has finished painting, and then painter 1 paints the j-th wall.\n2. When painter 0 has not yet painted, painter 1 paints the j-th wall.\n\nThe reason why it can be paid for $T[i][j]$ time is that you must pay both $T[i-1][j]$ time and $T[i][j-1]$ time, so for the option 1, you must have $f[i-1][j]$ price, pay option 2 for $f[i][j-1]$ price.\n\nFor the code:\n\nclass Solution {public:int paintWalls(vector<int>& cost, vector<int>& time) {int n = cost.size();vector<int> f(n * 2 + 1, INT_MAX / 2);f[n] = 0;for (int i = 0; i < n; ++i) {vector<int> g(n * 2 + 1, INT_MAX / 2);for (int j = 0; j <= n * 2; ++j) {if (j < n) {// 付费_g[j + 1] = min(g[j + 1], f[j] + cost[i] * time[i]);}// 免费if (j > 0) {g[j - 1", "groundtruth": "class Solution {public:int paintWalls(vector<int>& cost, vector<int>& time) {int n = cost.size();vector<int> f(n * 2 + 1, INT_MAX / 2);f[n] = 0;for (int i = 0; i < n; ++i) {vector<int> g(n * 2 + 1, INT_MAX / 2);for (int j = 0; j <= n * 2; ++j) {// 付费g[min(j + time[i], n * 2)] = min(g[min(j + time[i], n * 2)], f[j] + cost[i]);// 免费if (j > 0) {g[j - 1] = min(g[j - 1], f[j]);}}f = move(g);}return *min_element(f.begin() + n, f.end());}};"}
{"task_id": "cpp/2", "content": "Note:\n1 ≤ s.length ≤ 1000\nsonly consists of lowercase English letters\n\nInput Format:\nThe first line of the input is the positive integer T, indicating the number of test cases. The first line of each test case is the character string s.\nOutput Format:\nFor each test case, output on a new line after completion.\nSample Input:\n2\nbbaaaa\nasa\n\nSample Output:\nazzz\nasa\n\nExplanation:\n1\nThe character string of the second test case cannot be changed in any way.\n\n2\nFor the string \"bbaaaa\", the first substring after it is \"aaaa\". Each character of the substring \"aaaa\" is converted to the previous character of the English alphabet, which becomes \"zzzz\". Finally, the string is modified into \"azzz\".\n\n\n# C++\n\nThe input is a positive integer T(1≤T≤2000) indicating the number of test cases. Each line of the test case contains only lowercase English letters, and the length does not exceed 1000.\n\nThe output is a string consisting of lowercase English letters after completion.\n\nFor each test case, output a line of results after completion.\n\nSample Input:\n2\nbbaaaa\nasa\n\nSample Output:\nazzz\nasa\n\n### 思路\n\n（1）判断s的每一个字符c\n\n（2）如果当前字符等于’a’，说明当前的子字符串全为’a’\n\n（3）然后再判断s的下一个字符是否是’a’，如果不是’a’则跳出\n\n（4）将子字符串中的所有字符都减1，子字符串前面的不变，注意首字母要判断是否为’a’\n\n（5）如果子字符串中只含有’a’，那么将子字符串的最后一个字符‘a’修改为‘z’\n\n# Code\n\n#include <iostream>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\nstring smallestString(string s) {\nchar target = 'a';\nauto it = std::find_if(s.begin(), s.end(), [target](char c) {\nreturn c!= target;\n});\nint indexOfFirstNonA =", "groundtruth": "class Solution {public:string smallestString(string s) {char target = 'a';auto it = std::find_if(s.begin(), s.end(), [target](char c) {return c != target;});int indexOfFirstNonA = std::distance(s.begin(), it);if (indexOfFirstNonA == s.length()) {return s.substr(0, s.length() - 1) + 'z';}size_t indexOfFirstA_AfterFirstNonA = s.find('a', indexOfFirstNonA);if (indexOfFirstA_AfterFirstNonA == string::npos) {indexOfFirstA_AfterFirstNonA = s.length();}string res;for (int i = 0; i < s.length(); ++i) {if (indexOfFirstNonA <= i && i < indexOfFirstA_AfterFirstNonA) {res.push_back(static_cast<char>(s[i] - 1));} else {res.push_back(s[i]);}}return res;}};"}
{"task_id": "cpp/3", "content": "\n• input: \n[1,2,2]\n\n\n• output: \n5\n\n\nExplanation:\nThere are two options:\n1. One operation with a cost of 2, and then change the 2-indexed chocolate to the 0-indexed type. All chocolates are now collected. The cost is 2+2 = 4.\n2. One operation with a cost of 2, and then change the 1-indexed chocolate to the 2-indexed type. One more operation with a cost of 1, and then change the 2-indexed chocolate to the 0-indexed type. All chocolates are now collected. The cost is 2+1+2 = 5.\n5 is the minimum cost to collect all chocolates.\n\n\n• input: \n[5,6,4,3,2,3]\n\n\n• output: \n30\n\n\n• input: \n[6,5,4,2,6,2,5,3]\n\n\n• output: \n14\n\n\n */\n\n/**\nhttps://leetcode.com/problems/minimum-cost-to-change-the-final-value-of-expression/\n\nEvaluate the final value of an expression when given an integer, and also, when you are given the value of one single variable.\nThe expression is given as a string s, where only operations ('+', '-', '!', '&', '|' and '^') and open and close parentheses ('(' and ')') are used.\nAlso, \"!\" represents negation, and is always placed in front of a single variable.The string represents the final value of the expression, where each variable is replaced by its value in the 2-element array arr, and all occurrences of the operation! are negated.\nThere is only one single variable, namely, \"x\".\nReturn the integer value of the final expression.\nNote that a variable value of true is denoted by 1, and false by 0.\nThe operations are performed in the following order:\n\"!\" (negation)\n\"&\" (bitwise and)\n\"^\" (bitwise xor)\n\"|\" (bitwise or)\nAll calculations are done using 64-bit integers (signed integers).\nExample 1:\nInput: s = \"!(x)\", arr = [0,1]\n", "groundtruth": "class Solution {public:long long minCost(vector<int>& nums, int x) {int n = nums.size();vector<int> f(nums);long long ans = accumulate(f.begin(), f.end(), 0LL);for (int k = 1; k < n; ++k) {for (int i = 0; i < n; ++i) {f[i] = min(f[i], nums[(i + k) % n]);}ans = min(ans, static_cast<long long>(k) * x + accumulate(f.begin(), f.end(), 0LL));}return ans;}};"}
{"task_id": "cpp/4", "content": "\nNote:\nThe data range of this problem is large, and the data will be in the form of an encrypted document.\nIf you output the result of the ith query in the i row in the result document, it will not affect the scoring of the problem.\n*/\n\nclass Solution {\n    struct query {\n        int id;\n        int x, y;\n        query(int i, int x, int y) : id(i), x(x), y(y) {}\n    };\n    struct num {\n        int id;\n        int v1, v2;\n        num(int i, int v1, int v2) : id(i), v1(v1), v2(v2) {}\n    };\npublic:\n    vector<int> maximumSumQueries(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\n        vector<num> nums;\n        vector<query> qs;\n        int n1 = nums1.size(), n2 = queries.size();\n        for (int i = 0; i < n1; ++i) {\n            nums.emplace_back(i, nums1[i], nums2[i]);\n        }\n        for (int i = 0; i < n2; ++i) {\n            qs.emplace_back(i, queries[i][0], queries[i][1]);\n        }\n        sort(nums.begin(), nums.end(), [](const num& n1, const num& n2) {\n            if (n1.v1!= n2.v1) return n1.v1 > n2.v1;\n            return n1.v2 > n2.v2;\n        });\n        sort(qs.begin(), qs.end(), [](const query& q1, const query& q2) {\n            return q1.x > q2.x;\n        });\n        vector<int> ans(n2, -1);\n        int i1 = 0, i2 = 0;\n        stack<int> st;\n        while (i2 < n2) {\n            int v = qs[i2].x;\n            while (i1 < n1 && nums[i1].v1 >= v) {\n                int id = nums[i1].id;\n                while (!st.empty() && nums[st.top()].v2 <=", "groundtruth": "class Solution {public:vector<int> maximumSumQueries(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {vector<pair<int, int>> sortedNums;vector<tuple<int, int, int>> sortedQueries;for (int i = 0; i < nums1.size(); i++) {sortedNums.emplace_back(nums1[i], nums2[i]);}sort(sortedNums.begin(), sortedNums.end(), greater<pair<int, int>>());for (int i = 0; i < queries.size(); i++) {sortedQueries.emplace_back(i, queries[i][0], queries[i][1]);}sort(sortedQueries.begin(), sortedQueries.end(), [](tuple<int, int, int> &a, tuple<int, int, int> &b) {return get<1>(a) > get<1>(b);});vector<pair<int, int>> stk;vector<int> answer(queries.size(), -1);int j = 0;for (auto &[i, x, y] : sortedQueries) {while (j < sortedNums.size() && sortedNums[j].first >= x) {auto [num1, num2] = sortedNums[j];while (!stk.empty() && stk.back().second <= num1 + num2) {stk.pop_back();}if (stk.empty() || stk.back().first < num2) {stk.emplace_back(num2, num1 + num2);}j++;}int k = lower_bound(stk.begin(), stk.end(), make_pair(y, 0)) - stk.begin();if (k < stk.size()) {answer[i] = stk[k].second;}}return answer;}};"}
{"task_id": "cpp/5", "content": "The following are two possible output for the above example input:\n9\n9\n\n## Output explanation:\n\nThe longest semi-repetitive substring is \"0010\".\nclass Solution {\n    public int longestSemiRepetitiveSubstring(String s) {\n        int ans = 1, left = 0, same = 0, n = s.length();\n        for (int right = 1; right < n; right++) {\n            if (s.charAt(right) == s.charAt(right - 1) && ++same > 1) {\n                same = 1;\n            }\n            ans = Math.max(ans, right - left + 1);\n        }\n        return ans;\n    }\n}", "groundtruth": "class Solution {public:int longestSemiRepetitiveSubstring(string s) {int ans = 1, left = 0, same = 0, n = s.length();for (int right = 1; right < n; right++) {if (s[right] == s[right - 1] && ++same > 1) {for (left++; s[left] != s[left - 1]; left++);same = 1;}ans = max(ans, right - left + 1);}return ans;}};"}
{"task_id": "cpp/6", "content": "\nThere are two robots at positions nums[0] and nums[1] on a 1-dimensional number line. The starting positions of the robots are not equal. The initial directions of the robots are also not equal.Both robots move at the same speed (1 unit per second) and will never stop.\nThe command s[i] == 'R' means the robot on the ith position will move towards the right side, and 'L' means the robot will move towards the left side.After the command, the positions and directions of the robots are as follows:\nThe robot on the ith position changes direction (from 'R' to 'L' or from 'L' to 'R'), and the new direction is opposite to the old direction.\nThe robot on the ith position moves towards its new direction and will stop after t seconds.\nIf the two robots collide, they will start moving in opposite directions.\nGiven an integer array nums and a string s denoting the initial directions of the robots. Return the sum of distances between all the pairs of robots d seconds after the command. Since the sum can be very large, return it modulo 109 + 7.\nThe incomplete code is as follows:\nclass Solution {public:static constexpr int mod = 1e9 + 7;int sumDistance(vector<int>& nums, string s, int d) {int n = nums.size();vector<long long> pos(n);for (int i = 0; i < n; i++) {if (s[i] == 'L') {pos[i] = nums[i] - i;} else {pos[i] = nums[i] + i;}}sort(pos.begin(), pos.end());long long res = 0;for (int i = 1; i < n; i++) {res += (long long)(pos[i] - pos[i - 1]) * i * (n - i);res %= mod;}return res;}};\n\n### 6.13 The time complexity of the above code is as follows:\n\nThere are three robots at the positions of nums[0], nums[1], and nums[2] on the 1-dimensional number line. The initial direction of the robots can be 'R' or 'L', which does not affect the answer.", "groundtruth": "class Solution {public:static constexpr int mod = 1e9 + 7;int sumDistance(vector<int>& nums, string s, int d) {int n = nums.size();vector<long long> pos(n);for (int i = 0; i < n; i++) {if (s[i] == 'L') {pos[i] = (long long) nums[i] - d;} else {pos[i] = (long long) nums[i] + d;}}sort(pos.begin(), pos.end());long long res = 0;for (int i = 1; i < n; i++) {res += 1ll * (pos[i] - pos[i - 1]) * i % mod * (n - i) % mod;res %= mod;}return res;}};"}
{"task_id": "cpp/7", "content": "\nThis test case is given: grid = [[0,0,0,0,0,0,0,0,0,1],[0,1,0,1,1,0,1,0,0,0],[0,0,1,0,1,0,1,0,0,0],[1,1,1,0,0,0,1,1,1,0],[0,1,0,0,0,0,0,0,0,0]]The expected output is [0,3].\n\nThis C++ program has been compiled and executed on a macOS operating system.\n\nFirst of all, define an unordered_map of type unordered_map<int, int> called mp. Then, declare and initialize a variable named m of type int to the size of the grid vector. Next, declare and initialize a variable named n of type int to the size of the first vector in the grid vector.\n\nThen, iterate from 0 to m (the size of the grid vector) and for each column in the row, set the initial state to 0 by using the vertical bar (|) operator. Then, iterate from 0 to n (the size of the first vector in the grid vector) and for each column, shift the value in the grid vector to the left by the column index, and apply the bitwise OR operator (|) to the current state.\n\nNext, if the mp unordered_map does not contain a key with the value 0, return an empty vector as the answer. Then, iterate through the elements in the mp unordered_map using a range-based for loop, and for each element, check if the value for the current element is the same as the value for the next element. If so, return a vector containing the minimum and maximum values for the row indexes. If a match is not found, return an empty vector as the answer.\n\nThe code above is the completed code for this problem. To execute this program, you can use the following C++ code:\n\n#include <bits/stdc++.h>using namespace std;vector<int> goodSubset(vector<vector<int>>& grid) {vector<int> ans;unordered_map<int, int> mp;int m = grid.size();int n = grid[0].size();for (int j = 0; j < m; j++) {int st", "groundtruth": "class Solution {public:vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {vector<int> ans;unordered_map<int, int> mp;int m = grid.size();int n = grid[0].size();for (int j = 0; j < m; j++) {int st = 0;for (int i = 0; i < n; i++) {st |= (grid[j][i] << i);}mp[st] = j;}if (mp.count(0)) {ans.push_back(mp[0]);return ans;}for (auto [x, i]: mp) {for (auto [y, j]: mp) {if (!(x & y)) {return {min(i, j), max(i, j)};}}}return ans;}};"}
{"task_id": "cpp/8", "content": "The complete code is as follows:\nclass Solution {public:long long matrixSumQueries(int n, vector<vector<int>> &queries) {long long ans = 0;unordered_set<int> vis[2];for (int i = queries.size() - 1; i >= 0; i--) {auto &q = queries[i];int type = q[0], index = q[1], val = q[2];if (!vis[type].count(index)) { // 后面（>i）没有对这一行/列的操作// 这一行/列还剩下 n-vis[type^1].size() 个可以填入的格子ans += 1LL * val * (n - vis[type^1].size());vis[type].insert(index);}}return ans;}};\n\n## 1365.有多少小于当前数字的数字\n\n### Description\n\nGiven the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's such that j!= i and nums[j] < nums[i].\nReturn the answer in an array.\nThe incomplete code is as follows:\nclass Solution {public:vector<int> smallerNumbersThanCurrent(vector<int> &nums) {vector<int> res(nums.size());unordered_map<int, int> mp;for (int i = 0; i < nums.size(); i++) {if (!mp.count(nums[i])) mp[nums[i]] = 0;mp[nums[i]]++;}return res;}};\nGive only the completed code. Do not output any additional information.\nclass Solution {public:vector<int> smallerNumbersThanCurrent(vector<int> &nums) {vector<int> res(nums.size());unordered_map<int, int> mp;for (int i = 0; i < nums.size(); i++) {if (!mp.count(nums[i])) mp[nums[i]] = 0;mp[nums[i]]++;}for (int i = 0; i < nums.size(); i++) {res[i] = mp[nums[i] - 1];}return res;}};", "groundtruth": "class Solution {public:long long matrixSumQueries(int n, vector<vector<int>> &queries) {long long ans = 0;unordered_set<int> vis[2];for (int i = queries.size() - 1; i >= 0; i--) {auto &q = queries[i];int type = q[0], index = q[1], val = q[2];if (!vis[type].count(index)) { // 后面（>i）没有对这一行/列的操作// 这一行/列还剩下 n-vis[type^1].size() 个可以填入的格子ans += (long long) (n - vis[type ^ 1].size()) * val;vis[type].insert(index);}}return ans;}};"}
{"task_id": "cpp/9", "content": "Please read and complete the code, and do not change the main function. If you finish the challenge, click \"Run code\" to see whether you pass the tests. If the code is incomplete or the answer does not pass the test cases, click \"Debug\" to view the result of test 1.\nIn case of any problems, you can view the FAQ. If you feel that you have solved the problem and submitted the code, but the system says that you failed the test, you can click \"Submit\" and you will see the test details.\nYou will pass the test if you can get the output result of the sample test case.\n\nThe description of sample input and output of this problem is as follows:\nInput:\nnum1 = \"2\"\nnum2 = \"5\"\nmin_sum = 1\nmax_sum = 2\nOutput:\n1\nExplanation:\nThere is only one integer that is both between num1 and num2 and its digit sum is between min_sum and max_sum, which is 2 + 5 = 7.\n*/\n\n#include <cstdio>\n#include <string>\nusing namespace std;\n\nconstexpr int N = 23;\nconstexpr int M = 401;\nconstexpr int MOD = 1e9 + 7;\n\nclass Solution {\npublic:\n    int count(string num1, string num2, int min_sum, int max_sum) {\n        int sum1 = get(num1), sum2 = get(num2);\n        return (sum2 - sum1 + MOD) % MOD;\n    }\n\nprivate:\n    int get(string num) {\n        memset(d, -1, sizeof d);\n        return dfs(num.size() - 1, 0, true);\n    }\n\n    // 求解 num - 1，先把最后一个非 0 字符减去 1，再把后面的 0 字符变为 9\n    string sub(string num) {\n        int i = num.size() - 1;\n        while (num[i] == '0') {\n            i--;\n        }\n        num[i]--;\n        i++;\n        while (i < num.size()) {\n            num[i] = '9';\n            i++;\n        }\n        return num;\n    }\n\n    int d[N][M];\n    string num", "groundtruth": "class Solution {static constexpr int N = 23;static constexpr int M = 401;static constexpr int MOD = 1e9 + 7;int d[N][M];string num;int min_sum;int max_sum;int dfs(int i, int j, bool limit) {if (j > max_sum) {return 0;}if (i == -1) {return j >= min_sum;}if (!limit && d[i][j] != -1) {return d[i][j];}int res = 0;int up = limit ? num[i] - '0' : 9;for (int x = 0; x <= up; x++) {res = (res + dfs(i - 1, j + x, limit && x == up)) % MOD;}if (!limit) {d[i][j] = res;}return res;}int get(string num) {reverse(num.begin(), num.end());this->num = num;return dfs(num.size() - 1, 0, true);}// 求解 num - 1，先把最后一个非 0 字符减去 1，再把后面的 0 字符变为 9string sub(string num) {int i = num.size() - 1;while (num[i] == '0') {i--;}num[i]--;i++;while (i < num.size()) {num[i] = '9';i++;}return num;}public:int count(string num1, string num2, int min_sum, int max_sum) {memset(d, -1, sizeof d);this->min_sum = min_sum;this->max_sum = max_sum;return (get(num2) - get(sub(num1)) + MOD) % MOD;}};"}
{"task_id": "cpp/10", "content": "The completed code is as follows:\nclass Solution {public:int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {int n = mat.size();int m = mat[0].size();unordered_map<int, pair<int, int>> mp;for (int i = 0; i < n; ++i) {for (int j = 0; j < m; ++j) {mp[mat[i][j]] = {i, j};}}vector<int> rowCnt(n, 0);vector<int> colCnt(m, 0);for (int i = 0; i < arr.size(); ++i) {++rowCnt[mp[arr[i]].first];if (rowCnt[mp[arr[i]].first] == m) {return i;}++colCnt[mp[arr[i]].second];if (colCnt[mp[arr[i]].second] == n) {return i;}}return -1;}};\nAnalysis of algorithm:\nThis problem can be solved with a simple iteration. In the unordered_map mp, we store the coordinate of each number in the matrix mat. The time complexity of iterating the number in arr is O(N).\nclass Solution {public:int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {int n = mat.size();int m = mat[0].size();unordered_map<int, pair<int, int>> mp;for (int i = 0; i < n; ++i) {for (int j = 0; j < m; ++j) {mp[mat[i][j]] = {i, j};}}vector<int> rowCnt(n, 0);vector<int> colCnt(m, 0);for (int i = 0; i < arr.size(); ++i) {++rowCnt[mp[arr[i]].first];if (rowCnt[mp[arr[i]].first] == m) {return i;}++colCnt[mp[arr[i]].second];if (colCnt[mp[arr[i]].second] == n) {return i;}}return -1;}};\nCopy code\nTime complexity: O(nm)O(nm)\nSpace complexity: O(nm)O(", "groundtruth": "class Solution {public:int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {int n = mat.size();int m = mat[0].size();unordered_map<int, pair<int, int>> mp;for (int i = 0; i < n; ++i) {for (int j = 0; j < m; ++j) {mp[mat[i][j]] = {i, j};}}vector<int> rowCnt(n, 0);vector<int> colCnt(m, 0);for (int i = 0; i < arr.size(); ++i) {auto& v = mp[arr[i]];++rowCnt[v.first];if (rowCnt[v.first] == m) {return i;}++colCnt[v.second];if (colCnt[v.second] == n) {return i;}}return -1;}};"}
{"task_id": "cpp/11", "content": "\nInput description\nMultiple test cases, EOF end of file.\nFor each test case, the first line contains two positive integers $startX$ and $startY$, indicating the start point. The next line contains two positive integers $targetX$ and $targetY$, indicating the end point. The third line contains a positive integer $n$, indicating the number of special roads.\nNext $n$ lines, each contains five positive integers $x_1$, $y_1$, $x_2$, $y_2$, and $cost$, indicating the special road ( $(x_1, y_1)$ - $(x_2, y_2)$) with a cost of $cost$.\nIt is guaranteed that $0 < startX,startY,targetX,targetY < 2^{31}$, and $0 < n < 1000$, $0 < x_1,x_2,y_1,y_2 < 100$, and $0 < cost < 10^9$\n\nOutput description\nFor each test case, output an integer, the minimum cost from start to target.\n\nSample input\n3 35 343 5 62 4 6 3 31 6 4 5 52 6 4 5 63 4 6 3 71 5 4 6 22 5 3 3 31 2 2 6 62 5 5 6 24 1 4 1 2\n\nSample output\n46934424\n\n[Submit][Status]", "groundtruth": "class Solution {public:int minimumCost(vector<int> &start, vector<int> &target, vector <vector<int>> &specialRoads) {using LL = long long;LL t = (LL) target[0] << 32 | target[1];unordered_map<LL, int> dis = {{(LL) start[0] << 32 | start[1], 0}, {t, INT_MAX}};unordered_set<LL> vis;for (;;) {LL v = -1;int dv = -1;for (auto &[p, d]: dis)if (!vis.count(p) && (dv < 0 || d < dv))v = p, dv = d;if (v == t) return dv; // 到终点的最短路已确定vis.insert(v);int vx = v >> 32, vy = v & UINT32_MAX;// 更新到终点的最短路dis[t] = min(dis[t], dv + target[0] - vx + target[1] - vy);for (auto &r: specialRoads) {int d = dv + abs(r[0] - vx) + abs(r[1] - vy) + r[4];LL w = (LL) r[2] << 32 | r[3];if (!dis.count(w) || d < dis[w])dis[w] = d;}}}};"}
{"task_id": "cpp/12", "content": "\n/*\n2\nabcd\n2\nbabb\n4\n*/\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\nint t;\ncin>>t;\nwhile(t--)\n{\nstring s;\nint k;\ncin>>s;\ncin>>k;\ncout<<\"abcd\"<<endl;\n}\nreturn 0;\n}\n\n#### 题目来源\n\nPOJ3439\n\nposted @ 2021-03-11 20:45  一只大菜鸡  阅读(19)  评论(0编辑  收藏  举报", "groundtruth": "class Solution {public:string smallestBeautifulString(string s, int k) {for (int i = s.length() - 1; i >= 0; --i) {unordered_set<char> blockedCharacters;for (int j = 1; j <= 2; ++j) {if (i - j >= 0) {____}}for (int j = 1; j <= 3; ++j) {if (s[i] - 'a' + j + 1 <= k && blockedCharacters.find(s[i] + j) == blockedCharacters.end()) {return generate(s, i, j);}}}return \"\";}string generate(string s, int idx, int offset) {s[idx] += offset;for (int i = idx + 1; i < s.length(); ++i) {unordered_set<char> blockedCharacters;for (int j = 1; j <= 2; ++j) {if (i - j >= 0) {blockedCharacters.insert(s[i - j]);}}for (int j = 0; j < 3; ++j) {if (____) {s[i] = 'a' + j;break;}}}return s;}};"}
{"task_id": "cpp/13", "content": "1≤a[i],b[i]≤n. It can be proved that the number of elements in the common prefix array does not exceed 4∗10⁴.\nThe example of the input is as follows:\n7\n2 3 3 1 4 2 1\n4 7 1 3 2 1 6\nThe example of the output is as follows:\n4\n6\n7\n3\n1\n2\n1\n0\n4\n0\n0\n0\n0\n0\n0\n1\n3\n0\n0\n1\n4\n0\n0\n0\n1\n0\n0\n0\n0\n0\n0\n1\n5\n0\n0\n0\n0\n0\n0\n1\n6\n0\n0\n1\n0\n0\n0\n1\n7\n0\n0\n0\n0\n0\n0\n1\nThe complexity is O(n).\n*/\n\nclass Solution {\npublic:\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\n        int n = a.size();\n        vector<int> ans(n);\n        long long p = 0, q = 0;\n        for (int i = 0; i < n; ++i) {\n            p |= 1LL << a[i];\n            q |= 1LL << b[i];\n            ans[i] = __builtin_popcount(p&q);\n        }\n        return ans;\n    }\n};/*\r\nThe k-digit number N is an Armstrong number if and only if the k-th power of each digit sums to N.Given a positive integer N, return true if and only if it is an Armstrong number.\r\n\r\nExample 1:\r\nInput: 153\r\nOutput: true\r\nExplanation:\r\n153 is a 3-digit number, and 153 = 1^3 + 5^3 + 3^3.\r\n\r\nExample 2:\r\nInput: 123\r\nOutput: false\r\nExplanation:\r\n123 is a 3-digit number, and 123!= 1^3 + 2^3 + 3^3 = 36.\r\nNote:\r\n\r\n", "groundtruth": "class Solution {public:vector<int> findThePrefixCommonArray(vector<int> &a, vector<int> &b) {int n = a.size();vector<int> ans(n);long long p = 0, q = 0;for (int i = 0; i < n; ++i) {p |= 1LL << a[i];q |= 1LL << b[i];ans[i] = __builtin_popcountll(p & q);}return ans;}};"}
{"task_id": "cpp/14", "content": "Sample test cases and output\nSample input1\n[[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]]\nSample output1\n7\nSample input2\n[[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]]\nSample output2\n1\n\n/* The difficulty of the problem is Medium. The title does not describe the question accurately. It is recommended to read the original question. The title is the following:\nThere is an m x n grid where each cell is either a wall or empty. The robot is initially in the top-left corner (0, 0) facing the right. The robot can move in four directions: right, down, left, and up according to its direction. The robot can not enter a cell that is a wall.\nThe robot stops after a path that cannot move.\nThere is an m x n rectangular obstacle that the robot cannot step on. How many paths are there for the robot to reach the lower right corner? (0, 0) is upper left.\nThe incomplete code is as follows:\nclass Solution {public:int uniquePathsIII(vector<vector<int>> &grid) {int m = grid.size(), n = grid[0].size();function<int(int, int, int)> dfs = [&](int x, int y, int left) -> int {if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] < 0)return 0;if (grid[x][y] == 2)return left == 0? 1 : 0;grid[x][y] = -2;int res = dfs(x - 1, y, left - 1) + dfs(x + 1, y, left - 1) + dfs(x, y - 1, left - 1) + dfs(x, y + 1, left - 1);grid[x][y] = 0;return res;};int x = -1, y = -1, left = 1;for (int i = 0; i < m; ++i)for (int j = 0; j < n; ++j)", "groundtruth": "class Solution {static constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};public:int findMaxFish(vector<vector<int>> &grid) {int m = grid.size(), n = grid[0].size(), ans = 0;function<int(int, int)> dfs = [&](int x, int y) -> int {if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0)return 0;int sum = grid[x][y];grid[x][y] = 0; // 标记成访问过for (auto &d: dirs) // 四方向移动sum += dfs(x + d[0], y + d[1]);return sum;};for (int i = 0; i < m; ++i)for (int j = 0; j < n; ++j)ans = max(ans, dfs(i, j));return ans;}};"}
{"task_id": "cpp/15", "content": "The expected completed code is as follows:\n// 树状数组模板class BIT {vector<int> tree;public:BIT(int n) : tree(n) {}// 将下标 i 上的数加一void inc(int i) {while (i < tree.size()) {++tree[i];i += i & -i;}}// 返回闭区间 [1, i] 的元素和int sum(int x) {int res = 0;while (x > 0) {res += tree[x];x &= x - 1;}return res;}// 返回闭区间 [left, right] 的元素和int query(int left, int right) {return ____}};class Solution {public:long long countOperationsToEmptyArray(vector<int> &nums) {int n = nums.size(), id[n];iota(id, id + n, 0);sort(id, id + n, [&](int i, int j) {return nums[i] < nums[j];});long long ans = n; // 先把 n 计入答案BIT t(n + 1); // 下标从 1 开始int pre = 1; // 上一个最小值的位置，初始为 1for (int k = 0; k < n; ++k) {int i = id[k] + 1; // 下标从 1 开始if (i >= pre) // 从 pre 移动到 i，跳过已经删除的数ans += i - 1 - t.sum(i - 1); // sum(i-1) 是跳过 i-1 个数else // 从 pre 移动到 n，再从 1 移动到 i，跳过已经删除的数ans += i - 1 + n - pre - t.sum(i - 1);t.inc(i); // 删除 ipre = i;}return ans;}};\n\n• (156)3192673918\n\n• ### 360企业安全最新招聘信息\n\n热门职位：算法工程师\n\nc++语言\n\njava语言\n\n• (254)3050695138\n\n• ### 360企业安全最新招聘信息\n\n热门职位", "groundtruth": "// 树状数组模板class BIT {vector<int> tree;public:BIT(int n) : tree(n) {}// 将下标 i 上的数加一void inc(int i) {while (i < tree.size()) {++tree[i];i += i & -i;}}// 返回闭区间 [1, i] 的元素和int sum(int x) {int res = 0;while (x > 0) {res += tree[x];x &= x - 1;}return res;}// 返回闭区间 [left, right] 的元素和int query(int left, int right) {return sum(right) - sum(left - 1);}};class Solution {public:long long countOperationsToEmptyArray(vector<int> &nums) {int n = nums.size(), id[n];iota(id, id + n, 0);sort(id, id + n, [&](int i, int j) {return nums[i] < nums[j];});long long ans = n; // 先把 n 计入答案BIT t(n + 1); // 下标从 1 开始int pre = 1; // 上一个最小值的位置，初始为 1for (int k = 0; k < n; ++k) {int i = id[k] + 1; // 下标从 1 开始if (i >= pre) // 从 pre 移动到 i，跳过已经删除的数ans += i - pre - t.query(pre, i);else // 从 pre 移动到 n，再从 1 移动到 i，跳过已经删除的数ans += n - pre + i - k + t.query(i, pre - 1);t.inc(i); // 删除 ipre = i;}return ans;}};"}
{"task_id": "cpp/16", "content": "\n## Description of the problem\n\nGiven an integer array nums containing n integers, find the beauty of each subarray of size k.The beauty of a subarray is the xth smallest integer in the subarray if it is negative, or 0 if there are fewer than x negative integers.Return an integer array containing n - k + 1 integers, which denote the beauty of the subarrays in order from the first index in the array.A subarray is a contiguous non-empty sequence of elements within an array.\n\n• 1 <= k <= n <= 105\n• -50 <= nums[i] <= 50\n• 1 <= x <= k\n\n## Sample\n\nInput:[1,-2,-3,-4,2,-2], k= 2, x= 2Output:[1,-2,-3,-4,-2,-2]\n\n## hint\n\n1. First add k - 1 to the window, and then the window only has k - 1 members.\n2. Add k - 1 to the window one by one until the window has k members.\n3. Before entering the window, you need to find how many integers are in the range of [0, k], and which is the nth smallest integer in the range.\n\n## analysis\n\n1. Using multiset to sort, and then each time delete the first number and add a number to find the nth smallest number.\n2. Use an array of size 101 to calculate the number of each number, then find the nth smallest number in the range of [0, k], and then find the nth smallest number.\n3. The above method of counting array is too slow, we can use the difference array to speed up the counting.\n4. If we count from 0 to k, then we should enumerate the negative number to speed up.\n5. Finally, add BIAS (50) to each array element, which makes the array elements range from 0 to 100, which is the same as the position of the difference array.\n6. We can store the answer directly without creating any additional arrays.\n\n## code\n\n#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n// 1.\nclass Solution1 {\npublic:\nvector<int> getSubarrayBeauty(vector", "groundtruth": "class Solution {public:vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x) {const int BIAS = 50;int cnt[BIAS * 2 + 1]{}, n = nums.size();for (int i = 0; i < k - 1; ++i) // 先往窗口内添加 k-1 个数++cnt[nums[i] + BIAS];vector<int> ans(n - k + 1);for (int i = k - 1; i < n; ++i) {++cnt[nums[i] + BIAS]; // 进入窗口（保证窗口有恰好 k 个数）int left = x;for (int j = 0; j < BIAS; ++j) { // 暴力枚举负数范围 [-50,-1]left -= cnt[j];if (left <= 0) { // 找到美丽值ans[i - k + 1] = j - BIAS;break;}}--cnt[nums[i - k + 1] + BIAS]; // 离开窗口}return ans;}};"}
{"task_id": "cpp/17", "content": "\n## 输入\n\n### 第 1 行：\n\nA sequence of positive integers. Separate them by spaces. The size of nums is not greater than 500.\n\n## 输出\n\n### 第 1 行：\n\nThe minimum number of operations to make all elements of nums equal to 1. If it is impossible, return -1. The gcd of two integers is the greatest common divisor of the two integers.\n\n### 样例输入 1：\n\n2 4\n\n### 样例输出 1：\n\n2\n\n### 样例输入 2：\n\n10 6 14\n\n### 样例输出 2：\n\n5\n\n### 样例输入 3：\n\n360 48 60\n\n### 样例输出 3：\n\n3\n\n### 样例输入 4：\n\n360 24 12\n\n### 样例输出 4：\n\n-1\n\n## 题解\n\n### 第一种情况：nums数组中有一个数不为1\n\n• 直接进行交换的次数为n-1（每次把这个数和自己后面的数进行交换，可以得到1），这样只进行了一次直接交换；\n\n### 第二种情况：nums数组中全为1\n\n• 这个时候直接对nums数组中所有的数进行交换，得到全为1的情况的操作次数为$2*(n-1)$；\n• 在对全为1的数组进行交换的过程中，每次交换2个数，得到1，并重复此操作。对任意两个数进行交换，均可得到1。因此在得到全为1的数组的过程中，必须要对某两个数进行交换且至少为2次以上。\n• 这样对n个1进行交换的总操作数为$2*(n-1)+n$，即$3*(n-1)$；\n\n### 第三种情况：nums数组中既有不为1的数又有1\n\n• 这种情况其实可以分为两种，一是全为1的数组前还有其他的数，二是全为1的数组后还有其他的数。以第一种情况为例，全为1的数组前还有其他", "groundtruth": "class Solution {public:int minOperations(vector<int> &nums) {int n = nums.size(), gcd_all = 0, cnt1 = 0;for (int x: nums) {gcd_all = gcd(gcd_all, x);cnt1 += x == 1;}if (gcd_all > 1) return -1;if (cnt1) return n - cnt1;int min_size = n;for (int i = 0; i < n; ++i) {int g = 0;for (int j = i; j < n; ++j) {g = gcd(g, nums[j]);if (g == 1) {// 这里本来是 j-i+1，把 +1 提出来合并到 return 中min_size = min(min_size, j - i);break;}}}return min_size + n - 1;}};"}
{"task_id": "cpp/18", "content": "The correct code is as follows:\nclass Solution {public:int maxDivScore(vector<int>& nums, vector<int>& divisors) {int cnt = -1, ans = 0;for (int i = 0; i < divisors.size(); i++) {int tmp = 0;for (int j = 0; j < nums.size(); j++) {if (nums[j] % divisors[i] == 0) {tmp++;}}if (tmp > cnt || (tmp == cnt && divisors[i] < ans)) {cnt = tmp; ans = divisors[i];}}return ans;}};\n\n• page 1 of 1\n• 1", "groundtruth": "class Solution {public:int maxDivScore(vector<int>& nums, vector<int>& divisors) {int cnt = -1, ans = 0;for (int i = 0; i < divisors.size(); i++) {int tmp = 0;for (int j = 0; j < nums.size(); j++) {if (nums[j] % divisors[i] == 0) {tmp++;}}if (tmp > cnt || (tmp == cnt && divisors[i] < ans)) {ans = divisors[i];cnt = tmp;}}return ans;}};"}
{"task_id": "cpp/19", "content": "\n#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\n\nclass Solution {\npublic:\nint addMinimum(string word) {\nint n = word.size();\nvector<int> d(n + 1);\nfor (int i = 1; i <= n; i++) {\nif (i >= 3 && word.substr(i - 3, 3) == \"abc\")\n{\nd[i] = d[i - 1] - 1;\n}\nelse if (i >= 2 && word.substr(i - 2, 2) == \"bc\")\n{\nd[i] = d[i - 2];\n}\nelse if (i >= 1 && word.substr(i - 1, 1) == \"c\")\n{\nd[i] = d[i - 1];\n}\nelse\n{\nd[i] = d[i - 1] + 1;\n}\n}\nreturn d[n];\n}\n};\n\nint main()\n{\nstring word;\ncin >> word;\n\nSolution s;\nint d = s.addMinimum(word);\ncout << d << endl;\n\nsystem(\"pause\");\nreturn 0;\n}\n\n## 6. 2035. \n\nThis is a math problem which can be solved with the following steps:\n1. Enumerate all the primes below the square root of 5000000000.\n2. When enumerating, use the prime factorization to eliminate all the non-primes from the range.\n3. The remaining primes are all the primes below the square root of 5000000000.\n4. Since the product of the prime factors is a positive integer, the minimum product of any three consecutive primes is obtained by sorting the primes from small to large and taking the first three.\nThe following is the completed code:\n\n#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define LL long long\n\nvector<int> prime;\nbool isprime(LL num)\n{\nfor (int i = 2; i * i", "groundtruth": "class Solution {public:int addMinimum(string word) {int n = word.size();vector<int> d(n + 1);for (int i = 1; i <= n; i++) {d[i] = d[i - 1] + 2;if (i > 1 && word[i - 1] > word[i - 2]) {d[i] = d[i - 1] - 1;}}return d[n];}};"}
{"task_id": "cpp/20", "content": "\n输入描述\n\n输入包括四个部分：\n\n第一行包括四个整数：n, m, s, t，分别表示点数，边数，起始点，目标点。（1 ≤ n ≤ 2 * 105, 1 ≤ m ≤ 2 * 105, 1 ≤ s, t ≤ n, s ≠ t）\n第二行包括 n 个整数，第 i 个整数表示 i 号点的价格。（1 ≤ 价格 ≤ 2 * 105）\n第三行包括 m 个整数，第 i 个整数表示第 i 条边的两个端点 ai 和 bi。（1 ≤ ai, bi ≤ n, ai ≠ bi）\n第四行包括 t 个整数，第 i 个整数表示第 i 次旅行的起点和终点 xi 和 yi。（1 ≤ xi, yi ≤ n, xi ≠ yi）\n\n输出描述\n\n输出仅一行，包含一个整数，表示最小价格之和。\n\n输入\n\n输出\n6 5 1 61 2 3 4 5 61 22 33 44 55 651 31 41 51 6\n12\n\n输入\n\n输出\n6 5 1 61 2 3 4 5 61 22 33 44 55 651 31 41 51 6\n12\n\n输入\n\n输出\n3 3 2 33 2 11 22 33 1\n10\n\n输入\n\n输出\n3 3 2 33 2 11 22 33 1\n10\n\n输入\n\n输出\n1 0 1 111\n0\n\n输入\n\n输出\n1 0 1 111\n0\n\n提示\n\n对于30%的数据，保证 n ≤ 1000；对于 100% 的数据，保证 n ≤ 2 * 105，m ≤ 2 * 105，价格 ≤ 2 * 105", "groundtruth": "class Solution {public:int minimumTotalPrice(int n, vector<vector<int>> &edges, vector<int> &price, vector<vector<int>> &trips) {vector<vector<int>> next(n);for (auto &edge : edges) {next[edge[0]].push_back(edge[1]);next[edge[1]].push_back(edge[0]);}vector<int> count(n);function<bool(int, int, int)> dfs = [&](int node, int parent, int end) -> bool {if (node == end) {count[node]++;return true;}for (int child : next[node]) {if (child == parent) {continue;}if (dfs(child, node, end)) {count[node]++;return true;}}return false;};for (auto &trip: trips) {dfs(trip[0], -1, trip[1]);}function<pair<int, int>(int, int)> dp = [&](int node, int parent) -> pair<int, int> {pair<int, int> res = {price[node] * count[node], price[node] * count[node] / 2};for (int child : next[node]) {if (child == parent) {continue;}auto [x, y] = dp(child, node);res.first += min(x, y); // node 没有减半，因此可以取子树的两种情况的最小值res.second += x; // node 减半，只能取子树没有减半的情况}return res;};auto [x, y] = dp(0, -1);return min(x, y);}};"}
{"task_id": "cpp/21", "content": "Note: Please make sure your code runs successfully. When your code is wrong, please modify and run again.\n[Submit] [Testing Data] [All Testcase] [Program Source] [Reset]\nPlease input the code:\n\nC++[Copy]\nclass Solution {public:vector<long long> findPrefixScore(vector<int>& nums) {vector<long long> ans;int tmp = nums[0];ans.push_back(nums[0] * 2);for (int i = 1; i < nums.size(); ++i) {if (nums[i] > tmp) tmp = nums[i];ans.push_back(ans[i-1] + tmp);}return ans;}};\nCopy\n/*\n*\n* 题目描述：1857. 有向环的因子\n*\n* 本题为《今日算法一道》题解（2022年3月28日-2022年4月3日），仅用于学习和交流。\n*\n* 供小伙伴们参考，共同进步，每天都有所长进~\n*\n* 算法来源：力扣（LeetCode）\n*\n* 链接：https://leetcode-cn.com/problems/largest-color-value-in-a-directed-graph/\n*\n* GitHub代码：https://github.com/kuner/leetcode\n*\n*/\n\n#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\n/**\n * Definition for a Node.\n */\nclass Node {\npublic:\n    int val;\n    vector<Node*> neighbors;\n\n    Node() {\n        val = 0;\n        neighbors = vector<Node*>();\n    }\n\n    Node(int _val) {\n        val = _val;\n        neighbors = vector<Node*>();\n    }\n\n    Node(int _val, vector<Node*> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n};\n\nclass Solution {\npublic:\n    bool ans = true;\n    // 当前节点是否已经在队列中\n    vector<bool> visited;\n    // 记录前一个节点\n    vector<Node*> pre;\n\n    void bfs(Node *node) {\n        if (visited[node->", "groundtruth": "class Solution {public:vector<long long> findPrefixScore(vector<int>& nums) {vector<long long> ans;int tmp = nums[0];ans.push_back(nums[0] * 2);for (int i = 1; i < nums.size(); ++i) {if (nums[i] > tmp) tmp = nums[i];ans.push_back(nums[i] + tmp + ans[i - 1]);}return ans;}};"}
{"task_id": "cpp/22", "content": "\n## Sample input and output\n\nInput 1\n\nGiven the root of the tree as shown below:\n\n11 / \\ 21 22\n\nOutput 1\n\n[11 / \\ 11 11]\n\nInput 2\n\nGiven the root of the tree as shown below:\n\n21 / \\ 22 21\n\nOutput 2\n\n[21 / \\ 3 3]\n\nInput 3\n\nGiven the root of the tree as shown below:\n\n51 / \\ 55 5\n\nOutput 3\n\n[51 / \\ 0 0]\n\n## HINT\n\nYou can use BFS (Breadth-first search), traverse the node in the tree level by level, and update the value of the child node of each node as a time.\n\n## Solution\n\n/**\n\n* Definition for a binary tree node.\n\n* struct TreeNode {\n\n* int val;\n\n* TreeNode *left;\n\n* TreeNode *right;\n\n* TreeNode() : val(0), left(nullptr), right(nullptr) {}\n\n* TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n\n* TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n\n* };\n\n*/\n\nclass Solution {\n\npublic:\n\nTreeNode* replaceValueInTree(TreeNode* root) {\n\nvector<TreeNode*> q = {root};\n\nroot->val = 0;\n\nwhile (!q.empty()) {\n\nvector<TreeNode*> q2;\n\nint sum = 0;\n\nfor (auto fa : q) {\n\nif (fa->left) {\n\nq2.push_back(fa->left);\n\n}\n\nif (fa->right) {\n\nq2.push_back(fa->right);\n\n}\n\n}\n\nfor (auto fa : q) {\n\nint child_sum = (fa->left? fa->left->val : 0) +\n\n(fa->right? fa->right->val : 0);\n\nif (fa->left) {\n\nfa->left->val = child_sum;\n\n}", "groundtruth": "class Solution {public:TreeNode* replaceValueInTree(TreeNode* root) {vector<TreeNode*> q = {root};root->val = 0;while (!q.empty()) {vector<TreeNode*> q2;int sum = 0;for (auto fa : q) {if (fa->left) {q2.push_back(fa->left);sum += fa->left->val;}if (fa->right) {q2.push_back(fa->right);sum += fa->right->val;}}for (auto fa : q) {int child_sum = (fa->left ? fa->left->val : 0) +(fa->right ? fa->right->val : 0);if (fa->left) {fa->left->val = sum - child_sum;}if (fa->right) {fa->right->val = sum - child_sum;}}q = move(q2);}return root;}};"}
{"task_id": "cpp/23", "content": "\nCode 1: (25 points)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class Graph {public: using pii = pair; Graph(int n, vector>& edges) { this->graph = vector(n); for (auto& vec : edges) { int x = vec[0]; int y = vec[1]; int cost = vec[2]; graph[x].emplace_back(y, cost); } } void addEdge(vector edge) { int x = edge[0]; int y = edge[1]; int cost = edge[2]; graph[x].emplace_back(y, cost); } int shortestPath(int node1, int node2) { priority_queue pq; vector dist(graph.size(), INT_MAX); dist[node1] = 0; pq.emplace(0, node1); while (!pq.empty()) { auto [cost, cur] = pq.top(); pq.pop(); if (cur == node2) { return cost; } for (auto [next, ncost] : graph[cur]) { if (dist[next] > cost + ncost) { dist[next] = cost + ncost; pq.emplace(cost + ncost, next); } } } return -1; } private: vector> graph;", "groundtruth": "class Graph {public:using pii = pair<int, int>;Graph(int n, vector<vector<int>>& edges) {this->graph = vector<vector<pii>>(n);for (auto &vec : edges) {int x = vec[0];int y = vec[1];int cost = vec[2];graph[x].emplace_back(y, cost);}}void addEdge(vector<int> edge) {int x = edge[0];int y = edge[1];int cost = edge[2];graph[x].emplace_back(y, cost);}int shortestPath(int node1, int node2) {priority_queue<pii, vector<pii>, greater<pii>> pq;vector<int> dist(graph.size(), INT_MAX);dist[node1] = 0;pq.emplace(0, node1);while (!pq.empty()) {auto [cost, cur] = pq.top();pq.pop();if (cur == node2) {return cost;}for (auto [next, ncost] : graph[cur]) {if (dist[next] > cost + ncost) {dist[next] = cost + ncost;pq.emplace(cost + ncost, next);}}}return -1;}private:vector<vector<pii>> graph;};"}
{"task_id": "cpp/24", "content": "Please choose the answer from the following options.\nA.ans[a.back()] = s[a.size()] - s[0] - target * a.size();ans[a[0]] = target * a.size();\nB.ans[a.back()] = s[a.size()] - s[0];ans[a[0]] = target * a.size();\nC.ans[a.back()] = s[a.size()] - s[0] - target * a.size();\nD.ans[a[0]] = target * a.size();\n\n### 615. (0,0) 点和 (x,y) 点的最小距离\n\nGiven a 2D grid containing only the character '.' and 'X', find the minimum distance between a character 'X' and the point (0,0) and return it as an integer. If there is no such cell, then return -1.\nFor two cells located at (x1, y1) and (x2, y2), the distance is defined as\n|x1 - x2| + |y1 - y2|.\nThe incomplete code is as follows:\nclass Solution {public:int nearestExit(vector<vector<char>> &m, vector<int> &e) {____ // 蓝色面积priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> q; // 定义小根堆if (m[e[0]][e[1]]!= 'X')return -1; // 边界判断q.push({0, e[0] * m[0].size() + e[1]}); // 记录初始值vector<bool> vis(m.size() * m[0].size()); // 记录访问状态vis[e[0] * m[0].size() + e[1]] = true;while (!q.empty()) {auto p = q.top();q.pop();int a = p.second / m[0].size(), b = p.second % m[0].size();if (m[a][b] == '.') {if (____) // 绿色面积return ____;} // 黄色面积int dirs[5] = {-1, 0, 1, 0, -1};", "groundtruth": "class Solution {public:vector<long long> distance(vector<int> &nums) {int n = nums.size();unordered_map<int, vector<int>> groups;for (int i = 0; i < n; ++i)groups[nums[i]].push_back(i); // 相同元素分到同一组，记录下标vector<long long> ans(n);long long s[n + 1];s[0] = 0;for (auto &[_, a]: groups) {int m = a.size();for (int i = 0; i < m; ++i)s[i + 1] = s[i] + a[i]; // 前缀和for (int i = 0; i < m; ++i) {long long target = a[i];long long left = target * i - s[i]; // 蓝色面积long long right = s[m] - s[i] - target * (m - i); // 绿色面积ans[target] = left + right;}}return ans;}};"}
{"task_id": "cpp/25", "content": "\ninput example:\n[6,11,4,21,32,36,30,30,24,20,43,38,5,44,40,2,18,27,38,18,26,27,26,39,30,18,35,39,20,18,33,34,49,40,38,5,29,18,14,8,39,36,5,47,50,29,24,33,14,38,6,18,23,16,30,34,30,39,41,17,2,20,28,13,50,14,8,45,46,5,24,11,32,6,30,43,38,17,32,32,45,12,29,28,11,27,21,13,2,3,16,32,24,29,5,21,18,28,20,33,48,19,17,42,6,41,19,16,49,48,2,28,22,23,11,46,29,20,22,34,10,30,44,41,12,11,34,37,4,47,14,21,48,20,47,3,14,11,31,32,34,39,38,38,47,40,29,37,32,11,21,27,19,39,27,32,12,34,30,16,13,42,17,35,35,11,45,50,47,50,18,34,43,8,6,4,", "groundtruth": "class Solution {public:int minimizeMax(vector<int> &nums, int p) {sort(nums.begin(), nums.end());int left = -1, right = nums.back() - nums[0]; // 开区间while (left + 1 < right) { // 开区间int mid = left + (right - left) / 2, cnt = 0;for (int i = 0; i < nums.size() - 1; ++i)if (nums[i + 1] - nums[i] <= mid) { // 都选++cnt;++i;}(cnt >= p ? right : left) = mid;}return right;}};"}
{"task_id": "cpp/26", "content": "\n## Longest substring without repeating characters\n\nLongest substring without repeating characters Given a string s, find the length of the longest substring without repeating characters.The following incomplete code is given for a string s, and you need to complete the code of the longest substring method, which returns the length of the longest substring without repeating characters.\n\nclass Solution {public:    int longestSubstring(string s) {        int left = 0, right = 0, ans = 0;        vector<int> vis(128);        while (right < s.size()) {            char cur = s[right];            right++;            while (vis[cur]++) left++;            ans = max(ans, right - left);        }        return ans;    }};\n\n## Finding the longest substring of a string\n\nHere is a problem of finding the longest substring of a string without repeating characters in a string. For example: If the string is \"abcddef\", the longest substring without repeating characters is \"abcd\" and the length is 4. I did not understand why when we meet a character in a new substring, we should cut off a string from the beginning of the string. That is, it will be \"ef\" in the first place, it will be \"d\" then, and it will be \"\" finally. What is the principle for cutting off a string like this? I have given my answer to this problem, but I do not know if it is correct. If it is wrong, what is the correct method?\n\n## 3. Longest Substring Without Repeating Characters\n\nGiven a string, find the length of the longest substring without repeating characters. The answer should be a string and the length of the string. For example, given \"abcabcbb\", the answer should be \"abc\", and the length of the string is 3.Given the string \"bbbbb\", the answer is \"b\", the length of the string is 1.Given the string \"pwwkew\", the answer is \"wke\", the length of the string is 3. Note that the answer must be a substring, \"pwke\" is a subsequence and is not considered a substring.\n\n## Longest substring without repeating characters\n\nGiven a string, find the length of the longest substring without repeating characters. The answer should be a string and the length", "groundtruth": "class Solution {public:int minimumVisitedCells(vector<vector<int>>& grid) {int m = grid.size(), n = grid[0].size();vector<vector<int>> dist(m, vector<int>(n, -1));dist[0][0] = 1;vector<priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>>> row(m), col(n);auto update = [](int& x, int y) {if (x == -1 || y < x) {x = y;}};for (int i = 0; i < m; ++i) {for (int j = 0; j < n; ++j) {while (!row[i].empty() && row[i].top().second + grid[i][row[i].top().second] < j) {row[i].pop();}if (!row[i].empty()) {update(dist[i][j], dist[i][row[i].top().second] + 1);}while (!col[j].empty() && col[j].top().second + grid[col[j].top().second][j] < i) {col[j].pop();}if (!col[j].empty()) {update(dist[i][j], dist[col[j].top().second][j] + 1);}if (dist[i][j] != -1) {row[i].emplace(dist[i][j], j);col[j].emplace(dist[i][j], i);}}}return dist[m - 1][n - 1];}};"}
{"task_id": "cpp/27", "content": "The completed code is as follows:\nclass Solution {public:vector<vector<int>> findMatrix(vector<int> &nums) {unordered_map<int, int> cnt;for (int x: nums) ++cnt[x];vector<vector<int>> ans;while (!cnt.empty()) {vector<int> row;for (auto it = cnt.begin(); it!= cnt.end();) {row.push_back(it->first);if (--it->second == 0) cnt.erase(it++);else ++it;}ans.push_back(row);}return ans;}};\n\n## Python\n\n0%", "groundtruth": "class Solution {public:vector<vector<int>> findMatrix(vector<int> &nums) {unordered_map<int, int> cnt;for (int x: nums) ++cnt[x];vector<vector<int>> ans;while (!cnt.empty()) {vector<int> row;for (auto it = cnt.begin(); it != cnt.end();) {row.push_back(it->first);if (--it->second == 0) it = cnt.erase(it);else ++it;}ans.push_back(row);}return ans;}};"}
{"task_id": "cpp/28", "content": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\nint miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\nint ans = 0;\nint n = reward1.size();\nvector<int> diffs(n);\nfor (int i = 0; i < n; i++) {\ndiffs[i] = reward1[i] - reward2[i];\n}\nsort(diffs.begin(), diffs.end());\nfor (int i = 1; i <= k; i++) {\nans += diffs[n-i];\n}\nreturn ans;\n}\n};\n\nint main(){\nSolution s;\nvector<int> v1{18,12,12,17,12,12,12};\nvector<int> v2{13,12,11,17,13,12,12};\nint k = 3;\n\nint res = s.miceAndCheese(v1,v2,k);\n\ncout << res <<endl;\nreturn 0;\n}\n\n#include <stdio.h>\n\nstruct ListNode {\nint val;\nstruct ListNode *next;\n};\n\ntypedef struct ListNode lnode, *lnodeptr;\n\nlnodeptr newnode(int val){\nlnodeptr p = (lnodeptr)malloc(sizeof(lnode));\n\np->val = val;\np->next = NULL;\n\nreturn p;\n}\n\nlnodeptr create_list(int *arr, int size){\nlnodeptr head = NULL, tail = NULL;\n\nfor(int i = 0; i < size; ++i){\nlnodeptr p = newnode(arr[i]);\n\nif(i == 0){\nhead = p;\n}else{\ntail->next = p;\n}\n\ntail = p;\n}\nreturn head;\n}\n\nvoid print_list(lnodeptr head){\nwhile(head){\nprintf(\"%d \", head->val);\n\nhead = head->next;\n}\nprintf(\"\\n\");\n\nreturn ;\n}\n\n", "groundtruth": "class Solution {public:int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {int ans = 0;int n = reward1.size();vector<int> diffs(n);for (int i = 0; i < n; i++) {ans += reward2[i];diffs[i] = reward1[i] - reward2[i];}sort(diffs.begin(), diffs.end());for (int i = 1; i <= k; i++) {ans += diffs[n - i];}return ans;}};"}
{"task_id": "cpp/29", "content": "Code:\nclass Solution {public:vector<int> minReverseOperations(int n, int p, vector<int> &banned, int k) {unordered_set<int> ban{banned.begin(), banned.end()};set<int> sets[2];for (int i = 0; i < n; ++i)if (ban.count(i) == 0)sets[i % 2].insert(i);sets[0].insert(n);sets[1].insert(n); // 哨兵vector<int> ans(n, -1);vector<int> q = {p};for (int step = 0;!q.empty(); ++step) {vector<int> nq;for (int i: q) {ans[i] = step;// 从 mn 到 mx 的所有位置都可以翻转到int mn = max(i - k + 1, k - i - 1);int mx = i + k - 1;auto &s = sets[mn % 2];for (auto it = s.lower_bound(mn); *it <= mx; it = s.erase(it))nq.push_back(*it);}q = move(nq);}return ans;}};\n\nThe description of the original question is as follows. The incomplete code is as follows.\nclass Solution {public:vector<int> minReverseOperations(int n, int p, vector<int> &banned, int k) {unordered_set<int> ban{banned.begin(), banned.end()};set<int> sets[2];for (int i = 0; i < n; ++i)if (____)sets[i % 2].insert(i);sets[0].insert(n);sets[1].insert(n); // 哨兵vector<int> ans(n, -1);vector<int> q = {p};for (int step = 0;!q.empty(); ++step) {vector<int> nq;for (int i: q) {ans[i] = step;// 从 mn 到 mx 的所有位置都可以翻转到int mn = max(i - k + 1, k - i - 1);____auto &s = sets[mn % 2];for (auto it", "groundtruth": "class Solution {public:vector<int> minReverseOperations(int n, int p, vector<int> &banned, int k) {unordered_set<int> ban{banned.begin(), banned.end()};set<int> sets[2];for (int i = 0; i < n; ++i)if (i != p && !ban.count(i))sets[i % 2].insert(i);sets[0].insert(n);sets[1].insert(n); // 哨兵vector<int> ans(n, -1);vector<int> q = {p};for (int step = 0; !q.empty(); ++step) {vector<int> nq;for (int i: q) {ans[i] = step;// 从 mn 到 mx 的所有位置都可以翻转到int mn = max(i - k + 1, k - i - 1);int mx = min(i + k - 1, n * 2 - k - i - 1);auto &s = sets[mn % 2];for (auto it = s.lower_bound(mn); *it <= mx; it = s.erase(it))nq.push_back(*it);}q = move(nq);}return ans;}};"}