{"task_id": "java/0", "content": "Sample Input\n5\n[[1,0],[4,2],[2,0]]\n\nSample Output\n3\n", "groundtruth": "class Solution {    public int findChampion(int n, int[][] edges) {        int[] degree = new int[n];        for (int[] e : edges) {            degree[e[1]]++;        }        int champion = -1;        for (int i = 0; i < n; i++) {            if (degree[i] == 0) {                if (champion == -1) {                    champion = i;                } else {                    return -1;                }            }        }        return champion;    }}"}
{"task_id": "java/1", "content": "\n### 출처\n[O'zbekiston Respublikasi Milliy Universitet", "groundtruth": "class Solution {    public long maximumScoreAfterOperations(int[][] edges, int[] values) {        List<Integer>[] g = new ArrayList[values.length];        Arrays.setAll(g, e -> new ArrayList<>());        g[0].add(-1);         for (int[] e : edges) {            int x = e[0], y = e[1];            g[x].add(y);            g[y].add(x);        }        long ans = 0;        for (int v : values) {            ans += v;        }        return ans - dfs(0, -1, g, values);    }    private long dfs(int x, int fa, List<Integer>[] g, int[] values) {        if (g[x].size() == 1) {             return values[x];        }        long loss = 0;         for (int y : g[x]) {            if (y != fa) {                loss += dfs(y, x, g, values);             }        }        return Math.min(values[x], loss);     }}"}
{"task_id": "java/2", "content": "\n\nNote:\n\n3 <= nums.length <= 1000\n0 <= nums[i] <= 1000\nnums[i] is an integer.\n\n## 解法\n\n```rust\nimpl Solution {\n    pub fn triangle_type(nums: Vec<i32>) -> String {\n        if nums.len() < 3 {\n            return \"none\".to_string();\n        }\n        if nums[0] + nums[1] <= nums[2] {\n            return \"none\".to_string();\n        }\n        match nums[0] {\n            x if x == nums[1] && x == nums[2] => \"equilateral\",\n            x if x != nums[1] && x == nums[2] => \"isosceles\",\n            _ => \"scalene\",\n        }\n        .to_string()\n    }\n}\n```\n\n这题没什么可说的，按照顺序比��", "groundtruth": "class Solution {    public String triangleType(int[] nums) {        Arrays.sort(nums);        int x = nums[0];        int y = nums[1];        int z = nums[2];        if (x + y <= z) { // 排序后，只需比较 x+y 和 z            return 'none';        }        if (x == z) { // 排序了，说明 y 也和 x z 相等            return 'equilateral';        }        if (x == y || y == z) {            return 'isosceles';        }        return 'scalene';    }}"}
{"task_id": "java/3", "content": "\nclass Solution {\n    public int numberOfPairs(int[][] points) {\n        int pairs = 0;\n        Arrays.sort(points, (a, b) -> {\n            if (a[0] != b[0]) {\n                return a[0] - b[0];\n            } else {\n                return b[1] - a[1];\n            }\n        });\n        int ____ ;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if ____ {\n                    pairs++;\n                }\n            }\n        }\n        return pairs;\n    }\n    public boolean isGood(int[][] points, int index1, int index2) {\n        int n = points.length;\n        for (int i = 0; i < n; i++) {\n            if (i == index1 || i == index2) {\n                continue;\n            }\n            if (points[i][0] >= points[index1][0] && points[i][0] <= points[index2][0] && points[i][1] >= points[index2][1] && points[i][1] <= points[index1][1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "class Solution {    public int numberOfPairs(int[][] points) {        int pairs = 0;        Arrays.sort(points, (a, b) -> {            if (a[0] != b[0]) {                return a[0] - b[0];            } else {                return b[1] - a[1];            }        });        int n = points.length;        for (int i = 0; i < n; i++) {            for (int j = i + 1; j < n; j++) {                if (points[i][1] >= points[j][1] && isGood(points, i, j)) {                    pairs++;                }            }        }        return pairs;    }    public boolean isGood(int[][] points, int index1, int index2) {        int n = points.length;        for (int i = 0; i < n; i++) {            if (i == index1 || i == index2) {                continue;            }            if (points[i][0] >= points[index1][0] && points[i][0] <= points[index2][0] && points[i][1] >= points[index2][1] && points[i][1] <= points[index1][1]) {                return false;            }        }        return true;    }}"}
{"task_id": "java/4", "content": "\nIf there exists more than one answer with the maximum value, return any of them.\n\nNotice that for an input array and positive integer k, there may be multiple subarrays that are all good; a correct answer is any such good subarray with a maximum sum.\n\nExample 1:\n\nInput: nums = [1,2,3,4], k = 5\nOutput: 2\nExplanation:\nTaking a subarray containing [2,3], the absolute difference between its first and last element is 5.\nExample 2:\n\nInput: nums = [2], k = 1\nOutput: 0\nExplanation:\nThere are no good subarrays in nums since the absolute difference between its first and last element is 2 and this differs from k by at most 1.\nExample 3:\n\nInput: nums = [5], k = 5\nOutput: 0\nExplanation:\nThere are no good subarrays in nums since the absolute difference between its first and last element is 5 and this differs from k by at most 1.\nExample 4:\n\nInput: nums = [1,4,4], k = 0\nOutput: 4\nExample 5:\n\nInput: nums = [0,0,0,0,0], k = 1\nOutput: 1\n \n\nConstraints:\n\n1 <= nums.length <= 105\n0 <= nums[i] <= 109\n0 <= k <= 109\n\n```java\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\nimport java.util.PriorityQueue;\nimport java.util.Comparator;\nimport java.util.Arrays;\n\npublic class Solution {    \n    public long maximumSubarraySum(int[] nums, int k) {\n        long ans = Long.MIN_VALUE;\n        long sum = 0;\n        Map<Integer, Long> minS = new HashMap<>();\n        for (int x : nums) {\n            long s1 = minS.getOrDefault(x + k, Long.MAX_VALUE / 2);", "groundtruth": "class Solution {    public long maximumSubarraySum(int[] nums, int k) {        long ans = Long.MIN_VALUE;        long sum = 0;        Map<Integer, Long> minS = new HashMap<>();        for (int x : nums) {            long s1 = minS.getOrDefault(x - k, Long.MAX_VALUE / 2);            long s2 = minS.getOrDefault(x + k, Long.MAX_VALUE / 2);            ans = Math.max(ans, sum + x - Math.min(s1, s2));            minS.merge(x, sum, Math::min);            sum += x;        }        return ans > Long.MIN_VALUE / 4 ? ans : 0;    }}"}
{"task_id": "java/5", "content": "Solution:\nimport java.util.*;\n\npublic class Main {\n    public static int numberOfSubstrings(String S) {\n        char[] s = S.toCharArray();\n        int n = s.length;\n        int m = 0;\n        int[] a = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '0') {\n                a[m++] = i;\n            }\n        }\n        a[m] = n; // 哨兵\n        int ans = 0;\n        int i = 0; // >= left 的第一个 0 的下标是 a[i]\n        for (int left = 0; left < n; left++) {\n            if (s[left] == '1') {\n                ans += a[i] - left; // 不含 0 的子串个数\n            }\n            for (int k = i; k < m; k++) {\n                int cnt0 = k - i + 1;\n                if (cnt1 >= cnt0 * cnt0) {\n                    break;\n                }\n                int cnt1 = a[k] - left - (k - i);\n                ans += cnt1 - (cnt1 % cnt0) + 1;\n            }\n            if (s[left] == '0') {\n                i++; // 这个 0 后面不会再枚举到了\n            }\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        while (in.hasNext()) { // 注意 while 循环的使用\n            String s = in.next();\n            System.out.println(numberOfSubstrings(s));\n        }\n    }\n}\n\n// 1 6\n// 011110\n// 10\n// 00\n// 1\n// 0\n// 11001000011111111\n\n#", "groundtruth": "class Solution {    public int numberOfSubstrings(String S) {        char[] s = S.toCharArray();        int n = s.length;        int m = 0;        int[] a = new int[n + 1];        for (int i = 0; i < n; i++) {            if (s[i] == '0') {                a[m++] = i;            }        }        int tot1 = n - m;        a[m] = n; // 哨兵        int ans = 0;        int i = 0; // >= left 的第一个 0 的下标是 a[i]        for (int left = 0; left < n; left++) {            if (s[left] == '1') {                ans += a[i] - left; // 不含 0 的子串个数            }            for (int k = i; k < m; k++) {                int cnt0 = k - i + 1;                if (cnt0 * cnt0 > tot1) {                    break;                }                int cnt1 = a[k] - left - (k - i);                ans += Math.max(a[k + 1] - a[k] - Math.max(cnt0 * cnt0 - cnt1, 0), 0);            }            if (s[left] == '0') {                i++; // 这个 0 后面不会再枚举到了            }        }        return ans;    }}"}
{"task_id": "java/6", "content": "For the given test case, the output is:\ntrue\n*/\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Problem_1108 {\n    class Solution {\n        public bool CanReachCorner(int xCorner, int yCorner, int[][] circles) {\n            bool[] vis = new bool[circles.Length];\n            for (int i = 0; i < circles.Length; i++) {\n                long x = circles[i][0], y = circles[i][1], r = circles[i][2];\n                if (inCircle(x, y, r, 0, 0) || // 圆 i 包含矩形左下角\n                    inCircle(x, y, r, xCorner, yCorner) || // 圆 i 包含矩形右上角\n                    // 圆 i 是否与矩形上边界/左边界相交相切\n                    !vis[i] && (x <= xCorner && Math.Abs(y - yCorner) <= r ||\n                                y <= yCorner && x <= r ||\n                                y > yCorner && inCircle(x, y, r, 0, yCorner)) && dfs(i, xCorner, yCorner, circles, vis)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        // 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        private bool inCircle(long ox, long oy, long r, long x, long y) {\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r;\n        }\n\n        private bool dfs(int i, int xCorner, int yCorner, int[][] circles, bool[] vis) {\n            long x1 = circles[i][0], y1 = circles[i][1], r1 = circles[i][", "groundtruth": "class Solution {\n    public boolean canReachCorner(int X, int Y, int[][] circles) {\n        boolean[] vis = new boolean[circles.length];\n        for (int i = 0; i < circles.length; i++) {\n            long x = circles[i][0], y = circles[i][1], r = circles[i][2];\n            if (inCircle(x, y, r, 0, 0) || // 圆 i 包含矩形左下角\n                inCircle(x, y, r, X, Y) || // 圆 i 包含矩形右上角\n                // 圆 i 是否与矩形上边界/左边界相交相切\n                !vis[i] && (x <= X && Math.abs(y - Y) <= r ||\n                            y <= Y && x <= r ||\n                            y > Y && inCircle(x, y, r, 0, Y)) && dfs(i, X, Y, circles, vis)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n    private boolean inCircle(long ox, long oy, long r, long x, long y) {\n        return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r;\n    }\n\n    private boolean dfs(int i, int X, int Y, int[][] circles, boolean[] vis) {\n        long x1 = circles[i][0], y1 = circles[i][1], r1 = circles[i][2];\n        // 圆 i 是否与矩形右边界/下边界相交相切\n        if (y1 <= Y && Math.abs(x1 - X) <= r1 ||\n            x1 <= X && y1 <= r1 ||\n            x1 > X && inCircle(x1, y1, r1, X, 0)) {\n            return true;\n        }\n        vis[i] = true;\n        for (int j = 0; j < circles.length; j++) {\n            long x2 = circles[j][0], y2 = circles[j][1], r2 = circles[j][2];\n            // 在两圆相交相切的前提下，点 A 是否严格在矩形内\n            if (!vis[j] &&\n                (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) &&\n                x1 * r2 + x2 * r1 < (r1 + r2) * X &&\n                y1 * r2 + y2 * r1 < (r1 + r2) * Y &&\n                dfs(j, X, Y, circles, vis)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"task_id": "java/7", "content": "\nNote:\nThe result may be large, so it is necessary to return the result in long type.\n\nThe number of flowers can be a large number, so please", "groundtruth": "class Solution {\n    public long flowerGame(int n, int m) {\n        long a = ((long)n/2) * ((long)m-((long)m/2));\n        long b = ((long)m/2) * ((long)n-((long)n/2));\n        return a + b;\n    }\n}\n"}
{"task_id": "java/8", "content": "\nThe function returned value in the following example is 12.\n\n \n\nExample 1:\n\nInput: nums = [2,2,2,2,5], k = 3\nOutput: 12\nExplanation: The possible bitwise OR values for the remaining elements are 2, 6, 7, and 12.\n\nExample 2:\n\nInput: nums = [1,2,3,4,5], k = 2\nOutput: 14\nExplanation: The possible bitwise OR values for the remaining elements are 4, 6, 7, and 14.\n\nExample 3:\n\nInput: nums = [1,2,3,4,5,6], k = 1\nOutput: 8\nExplanation: The possible bitwise OR values for the remaining elements are 2, 3, 4, 5, 6, and 8.\n \n\nConstraints:\n\n1 <= nums.length <= 105\n1 <= k <= nums.length\n1 <= nums[i] <= 105\n\nAccepted\n24,098\nSubmissions\n55,620\n*/\npublic class Solution {\n    public int minOrAfterOperations(int[] nums, int k) {\n        int ans = 0;\n        int mask = 0;\n        for (int b = 29; b >= 0; b--) {\n            mask |= 1 << b;\n            int cnt = 0; // 操作次数\n            int and = -1; // -1 的二进制全为 1\n            for (int x : nums) {\n                and &= x & mask;\n                if (and != 0) {\n                    cnt++; // 合并 x，操作次数加一\n                } else {\n                    and = -1; // 准备合并下一段\n                }\n            }\n            if (cnt > k) {\n                ans |= (1 << b); // 答案的这个比特位必须是 1\n                mask ^= 1 <<", "groundtruth": "class Solution {\n    public int minOrAfterOperations(int[] nums, int k) {\n        int ans = 0;\n        int mask = 0;\n        for (int b = 29; b >= 0; b--) {\n            mask |= 1 << b;\n            int cnt = 0; // 操作次数\n            int and = -1; // -1 的二进制全为 1\n            for (int x : nums) {\n                and &= x & mask;\n                if (and != 0) {\n                    cnt++; // 合并 x，操作次数加一\n                } else {\n                    and = -1; // 准备合并下一段\n                }\n            }\n            if (cnt > k) {\n                ans |= 1 << b; // 答案的这个比特位必须是 1\n                mask ^= 1 << b; // 后面不考虑这个比特位\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/9", "content": "\nHere are some examples of input and output:\nInput: n = 3, x = 1, y = 2\nOutput: [3,3,2]\nThe explanation of the input and output is as follows:\nThere are 3 houses numbered 1, 2 and 3 connected by three streets.\nIn the following figure,\nthe green house is house numbered x = 1,\nthe blue house is house numbered y = 2,\nthe yellow street is the extra street.\nYou need to return a 1-indexed array result.\nThe result[0] = 3 means 3 ways to reach house number 2 from house number 1.\nThere are 3 ways:\n1. Only one yellow street(length = 1)\n2. Two yellow streets(length = 2)\n3. Three yellow streets(length = 3)\nThe result[1] = 3 means 3 ways to reach house number 3 from house number 1.\nThe result[2] = 2 means 2 ways to reach house number 3 from house number 2.\nThe figure below shows all ways to reach the house numbered 3 from the house numbered 1 or 2:\nThe figure below shows all ways to reach the house numbered 2 from the house numbered 1.\n\nInput: n = 2, x = 2, y = 1\nOutput: [1,1]\nExplanation: There is only one way to reach house numbered 2 from house numbered 1.\n\nInput: n = 3, x = 1, y = 3\nOutput: [2,1,1]\nExplanation:\nThe figure below shows all the ways to reach the house numbered 3 from the house numbered 1.\nPlease note that one way is the path from house numbered 1 to house numbered 3 directly.\n\nInput: n = 4, x = 1, y = 4\nOutput: [1,2,3,2]\nExplanation:\nThe figure below shows all the ways to reach the house numbered 4 from the house numbered 1.\nPlease note that one way is the path from house numbered 1 to house numbered 4 directly.\n*/\n\n#include <", "groundtruth": "class Solution {\n    public int[] countOfPairs(int n, int x, int y) {\n        int w[][] = new int[n + 1][n + 1];\n        int INF = Integer.MAX_VALUE / 2;\n        //初始化 邻接矩阵。\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                w[i][j] = (i == j ? 0 : INF);\n        //额外的捷径的权值是1。但不能是自身到自身，因为自身到自身的权值本来就是0.\n        if (x != y) {\n            w[x][y] = 1;\n            w[y][x] = 1;\n        }\n        //建图，前后相邻 权值都是1。\n        for (int i = 1; i < n; i++) {\n            w[i][i + 1] = 1;\n            w[i + 1][i] = 1;\n        }\n        //佛洛依德算法\n        for (int p = 1; p <= n; p++)\n            for (int st = 1; st <= n; st++)\n                for (int end = 1; end <= n; end++)\n                    w[st][end] = Math.min(w[st][end], w[st][p] + w[p][end]);\n        //先用下标从0开始的数组来求结果。\n        int[] res = new int[n + 1];\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                if (w[i][j] != INF)\n                    res[w[i][j]]++;\n        //最终再遍历一次把求得的结果放到 下标从1开始的result数组。\n        int[] result  = new int[n];\n        for (int i = 0; i < n; i++)\n            result[i] = res[i + 1];\n        return result;\n    }\n}\n"}
{"task_id": "java/10", "content": "\n样例输入：\n3 1 2\n样例输出：\n2\n\n来源：\n<a href=\"https://leetcode-cn.com/problems/find-the-shortest-superstring\">力扣（LeetCode）</a>\n<hr>\n\n#### 3、有几条珊瑚？\n\n你跟你的朋友玩了一个珊瑚收集游戏。每次你可以从水里捡起一个珊瑚或者是把一个珊瑚放回到水里。你和你的朋友轮流行动，你作为先手。\n\n你们都知道这个游戏的规则，如果你想赢，请返回你的最小行动数，输的概率大于等于50%，最终输了或赢了游戏的概率是多少？（保证合法的解肯定是存在的）\n\n你的函数将返回一个概率为多少，输出结果请给出精度为3位小数。\n\n\n示例1：\n\n输入: \"5\"\n输出: 0.305\n示例2：\n\n输入: \"3\"\n输出: 0.286\n示例3：\n\n输入: \"4\"\n输出: 0.25\n\n来源：<a href=\"https://leetcode-cn.com/contest/weekly-contest-146/problems/fewest-number-of-unique-integers-after-k-removals/\">力扣（LeetCode）</a>\n<hr>\n\n#### 4、打印赢面\n\n对于一个正整数 `num`, 你可以根据如下步骤构建一个 �", "groundtruth": "class Solution {\n    public int[] countOfPairs(int n, int x, int y) {\n        int w[][] = new int[n + 1][n + 1];\n        int INF = Integer.MAX_VALUE / 2;\n        \n        //初始化 邻接矩阵。\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                w[i][j] = (i == j ? 0 : INF);\n\n        //额外的捷径的权值是1。但不能是自身到自身，因为自身到自身的权值本来就是0.\n        if (x != y) {\n            w[x][y] = 1;\n            w[y][x] = 1;\n        }\n\n        //建图，前后相邻 权值都是1。\n        for (int i = 1; i < n; i++) {\n            w[i][i + 1] = 1;\n            w[i + 1][i] = 1;\n        }\n\n        //佛洛依德算法\n        for (int p = 1; p <= n; p++)\n            for (int st = 1; st <= n; st++)\n                for (int end = 1; end <= n; end++)\n                    w[st][end] = Math.min(w[st][end], w[st][p] + w[p][end]);\n\n        //先用下标从0开始的数组来求结果。\n        int[] res = new int[n + 1];\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                if (w[i][j] != INF)\n                    res[w[i][j]]++;\n\n        //最终再遍历一次把求得的结果放到 下标从1开始的result数组。\n        int[] result  = new int[n];\n        for (int i = 0; i < n; i++)\n            result[i] = res[i + 1];\n\n        return result;\n    }\n}\n"}
{"task_id": "java/11", "content": "\nExample 1:\n\nInput: nums = [3,1,4,2]\nOutput: false\nExplanation: There are 3 ways to arrange this array:\n[1, 2, 3, 4]\n[3, 1, 4, 2]\n[4, 3, 2, 1]\nHowever, each number's bits set count (the number of 1's) is not strictly decreasing.\nExample 2:\n\nInput: nums = [7,9,8,6,4,2,1]\nOutput: true\nExplanation: It is possible to rearrange the elements such that they are increasing in each bit set count.\nExample 3:\n\nInput: nums = [3,1,6,5,4,2,7,9,8,12,11,10,14,13]\nOutput: true\nExplanation: It is possible to rearrange the elements such that they are increasing in each bit set count.\nExample 4:\n\nInput: nums = [1,3,2]\nOutput: false\nExplanation: There are 2 ways to arrange this array:\n[1, 3, 2]\n[3, 1, 2]\nHowever, both of them have 1 bit set count in the most significant bit of each element, which is not strictly decreasing.\nExample 5:\n\nInput: nums = [1,2,3,2]\nOutput: false\nExplanation: It is impossible to arrange this array since in each of the 4 permutations there are 3 elements with 1 bit set count.\n \nConstraints:\n\n1 <= nums.length <= 15\n1 <= nums[i] <= 105\n\n'''\n\nclass Solution:\n    def canSortArray(self, nums):\n        if len(nums) == 1:\n            return True\n\n        lastCnt = 0\n        lastGroupMax = 0\n        curGroupMax = 0\n        for num in nums:\n            curCnt = len(str(bin(num))[2:].split('1'))\n\n            if curCnt == lastCnt", "groundtruth": "class Solution {\n    public boolean canSortArray(int[] nums) {\n        int lastCnt = 0;\n        int lastGroupMax = 0;\n        int curGroupMax = 0;\n        for (int num : nums) {\n            int curCnt = Integer.bitCount(num);\n            if (curCnt == lastCnt) {\n                curGroupMax = Math.max(curGroupMax, num);\n            } else {\n                lastCnt = curCnt;\n                lastGroupMax = curGroupMax;\n                curGroupMax = num;\n            }\n            if (num < lastGroupMax) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "java/12", "content": "\n \n\nExample 1:\n\nInput: nums = [100,1,1000]\nOutput: 2\nExplanation:\n- One operation (i, j) = (0, 1), nums = [100,1,1000]. nums[0] % nums[1] == 0, so nums[0] does not change.\n- Two operations (i, j) = (1, 2), nums = [100,1,500]. nums[1] % nums[2] == 0, so nums[1] does not change.\nExample 2:\n\nInput: nums = [5,2,1,2,5,10,20]\nOutput: 3\nExplanation:\n- One operation (i, j) = (0, 1), nums = [5,2,1,2,5,10,20]. nums[0] % nums[1] == 0, so nums[0] does not change.\n- Two operations (i, j) = (1, 2), nums = [5,1,1,2,5,10,20]. nums[1] % nums[2] == 0, so nums[1] does not change.\n- Three operations (i, j) = (2, 3), nums = [5,1,1,1,5,10,20]. nums[2] % nums[3] == 0, so nums[2] does not change.\n \n\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 106\n \n\nFollow-up: Can you solve this problem in O(n) time?\n\n \n\n \n */\n\nclass Solution {\n    public int minimumArrayLength(int[] nums) {\n        \n        int min = Integer.MAX_VALUE;\n        \n        for(int num : nums) {\n            min = Math.min(min, num);\n        }\n        \n        int cnt = 0;\n        for(int num : nums", "groundtruth": "class Solution {\n    public int minimumArrayLength(int[] nums) {\n        int m = Integer.MAX_VALUE;\n        for (int x : nums) {\n            m = Math.min(m, x);\n        }\n\n        for (int x : nums) {\n            if (x % m > 0) {\n                return 1;\n            }\n        }\n\n        int cnt = 0;\n        for (int x : nums) {\n            if (x == m) {\n                cnt++;\n            }\n        }\n        return (cnt + 1) / 2;\n    }\n}\n"}
{"task_id": "java/13", "content": "\nHint #1\nTo deal with each subarray and obtain the sum of the cost of each subarray, think of how to keep the cost of the last k subarrays.\nHint #2\nTo deal with the rest of the elements after the last k subarrays are obtained, you need to update the cost of each subarray in time proportional to its size. For example, if the size of the last k subarrays is dist, then the time complexity of updating them must be O(dist).\nThe time and space complexity of your solution must be O(n).\nThe number of test cases is 35.\n\n\n\n题目大意：给你一个数组，要求你做 k 个连续的分组，每组的长度都为 i （ i 在 [1, n-k + 1] 之间），如果两个分组之间的长度大于 dist，那么它们就不是连续的。要求输出最小的分组成本。\n\n这道题一般要求不只是求解答案，还要求解过程中的一些关键操作。\n\n这道题，第一个很简单，就是按照题目的意思一步一步来，详细的思路在注释里面，不做过多说明。\n\n时间复杂度：O(n)。\n\n空间复杂度：O(n)。\n\n\n```\n\n\nclass Solution {\n    public long minimumCost(int[] nums, int k, int dist) {\n        k--;\n        sumL = nums[0];\n        for (int i = 1; i < dist + 2; i++) {\n            sumL += nums[i];\n            L.merge(nums[i], 1, Integer::sum);\n        }\n        sizeL = dist + 1;\n        while (sizeL > k) {\n            l2r();\n        }\n\n        long ans = sumL;\n        for (int i = dist +", "groundtruth": "class Solution {\n    public long minimumCost(int[] nums, int k, int dist) {\n        k--;\n        sumL = nums[0];\n        for (int i = 1; i < dist + 2; i++) {\n            sumL += nums[i];\n            L.merge(nums[i], 1, Integer::sum);\n        }\n        sizeL = dist + 1;\n        while (sizeL > k) {\n            l2r();\n        }\n\n        long ans = sumL;\n        for (int i = dist + 2; i < nums.length; i++) {\n            // 移除 out\n            int out = nums[i - dist - 1];\n            if (L.containsKey(out)) {\n                sumL -= out;\n                sizeL--;\n                removeOne(L, out);\n            } else {\n                removeOne(R, out);\n            }\n\n            // 添加 in\n            int in = nums[i];\n            if (in < L.lastKey()) {\n                sumL += in;\n                sizeL++;\n                L.merge(in, 1, Integer::sum);\n            } else {\n                R.merge(in, 1, Integer::sum);\n            }\n\n            // 维护大小\n            if (sizeL == k - 1) {\n                r2l();\n            } else if (sizeL == k + 1) {\n                l2r();\n            }\n\n            ans = Math.min(ans, sumL);\n        }\n        return ans;\n    }\n\n    private long sumL;\n    private int sizeL;\n    private final TreeMap<Integer, Integer> L = new TreeMap<>();\n    private final TreeMap<Integer, Integer> R = new TreeMap<>();\n\n    private void l2r() {\n        int x = L.lastKey();\n        removeOne(L, x);\n        sumL -= x;\n        sizeL--;\n        R.merge(x, 1, Integer::sum);\n    }\n\n    private void r2l() {\n        int x = R.firstKey();\n        removeOne(R, x);\n        sumL += x;\n        sizeL++;\n        L.merge(x, 1, Integer::sum);\n    }\n\n    private void removeOne(Map<Integer, Integer> m, int x) {\n        int cnt = m.get(x);\n        if (cnt > 1) {\n            m.put(x, cnt - 1);\n        } else {\n            m.remove(x);\n        }\n    }\n}\n"}
{"task_id": "java/14", "content": "\nThe correct code is as follows:\nclass Solution {\n    public List<Integer> beautifulIndices(String s, String a, String b, int k) {\n        char[] text = s.toCharArray();\n        List<Integer> posA = kmp(text, a.toCharArray());\n        List<Integer> posB = kmp(text, b.toCharArray());\n\n        List<Integer> ans = new ArrayList<>();\n        for (int i : posA) {\n            int bi = lowerBound(posB, i + 1);\n            if (bi < posB.size() && posB.get(bi) - i <= k ||\n                bi > 0 && i - posB.get(bi - 1) <= k) {\n                ans.add(i);\n            }\n        }\n        return ans;\n    }\n\n    private List<Integer> kmp(char[] text, char[] pattern) {\n        int m = pattern.length;\n        int[] pi = new int[m];\n        int c = 0;\n        for (int i = 1; i < m; i++) {\n            char v = pattern[i];\n            while (c > 0 && pattern[c] != v) {\n                c = pi[c - 1];\n            }\n            if (pattern[c] == v) {\n                c++;\n            }\n            pi[i] = c;\n        }\n\n        List<Integer> res = new ArrayList<>();\n        c = 0;\n        for (int i = 0; i < text.length; i++) {\n            char v = text[i];\n            while (c > 0 && pattern[c] != v) {\n                c = pi[c - 1];\n            }\n            if (pattern[c] == v) {\n                c++;\n            }\n            if (c == m) {\n                res.add(i - m + 1);\n                c = pi[c - 1];\n            }\n        }\n        return res;\n    }\n\n    // 开区间写法\n    private int lowerBound(List<Integer> nums, int target) {\n        int left = -1,", "groundtruth": "class Solution {\n    public List<Integer> beautifulIndices(String s, String a, String b, int k) {\n        char[] text = s.toCharArray();\n        List<Integer> posA = kmp(text, a.toCharArray());\n        List<Integer> posB = kmp(text, b.toCharArray());\n\n        List<Integer> ans = new ArrayList<>();\n        for (int i : posA) {\n            int bi = lowerBound(posB, i);\n            if (bi < posB.size() && posB.get(bi) - i <= k ||\n                bi > 0 && i - posB.get(bi - 1) <= k) {\n                ans.add(i);\n            }\n        }\n        return ans;\n    }\n\n    private List<Integer> kmp(char[] text, char[] pattern) {\n        int m = pattern.length;\n        int[] pi = new int[m];\n        int c = 0;\n        for (int i = 1; i < m; i++) {\n            char v = pattern[i];\n            while (c > 0 && pattern[c] != v) {\n                c = pi[c - 1];\n            }\n            if (pattern[c] == v) {\n                c++;\n            }\n            pi[i] = c;\n        }\n\n        List<Integer> res = new ArrayList<>();\n        c = 0;\n        for (int i = 0; i < text.length; i++) {\n            char v = text[i];\n            while (c > 0 && pattern[c] != v) {\n                c = pi[c - 1];\n            }\n            if (pattern[c] == v) {\n                c++;\n            }\n            if (c == m) {\n                res.add(i - m + 1);\n                c = pi[c - 1];\n            }\n        }\n        return res;\n    }\n\n    // 开区间写法\n    private int lowerBound(List<Integer> nums, int target) {\n        int left = -1, right = nums.size(); // 开区间 (left, right)\n        while (left + 1 < right) { // 区间不为空\n            // 循环不变量：\n            // nums[left] < target\n            // nums[right] >= target\n            int mid = (left + right) >>> 1;\n            if (nums.get(mid) < target) {\n                left = mid; // 范围缩小到 (mid, right)\n            } else {\n                right = mid; // 范围缩小到 (left, mid)\n            }\n        }\n        return right;\n    }\n}\n"}
{"task_id": "java/15", "content": "\nExample 1:\nInput: k = 5, x = 2\nOutput: 3\nExplanation: The numbers with non-zero counts of set bits at positions 2, 4, 6, 8 and 10 are 0, 1, 3, 5, 7 and 9. The accumulated price is (1 + 0) + (1 + 0) + (1 + 1) + (1 + 0) + (1 + 1) = 8. \nThe number 3 is the greatest one under price 8.\nExample 2:\nInput: k = 10, x = 5\nOutput: 5\nExplanation: The numbers with non-zero counts of set bits at positions 5, 10, 15, 20, 25 are 1, 2, 4, 8 and 16. The accumulated price is (1 + 1) + (1 + 0) + (1 + 0) + (1 + 1) + (1 + 0) = 10. \nThe number 5 is the greatest one under price 10.\nExample 3:\nInput: k = 7, x = 3\nOutput: 1\nExplanation: The numbers with non-zero counts of set bits at positions 3, 6 and 9 are 1, 2 and 4. The accumulated price is (1 + 1) + (1 + 0) + (1 + 0) = 4. \nThe number 1 is the greatest one under price 4.\nExample 4:\nInput: k = 10, x = 7\nOutput: 4\nExplanation: The numbers with non-zero counts of set bits at positions 7, 14, 21, 28, 35, 42 and 49 are 8, 16, 32, 64, 128, 256 and 512. The accumulated price is (1 + 0) + (1 + 0) + (1 + 0) + (1 + 0) + (1 + 0) + (1 + 1) + (", "groundtruth": "class Solution {\n    public long findMaximumNumber(long k, int x) {\n        this.x = x;\n        long left = 0;\n        long right = (k + 1) << x;\n        while (left + 1 < right) {\n            long mid = (left + right) >>> 1;\n            if (countDigitOne(mid) <= k) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n\n    private int x;\n    private long num;\n    private long memo[][];\n\n    private long countDigitOne(long num) {\n        this.num = num;\n        int m = 64 - Long.numberOfLeadingZeros(num);\n        memo = new long[m][m + 1];\n        for (long[] row : memo) {\n            Arrays.fill(row, -1);\n        }\n        return dfs(m - 1, 0, true);\n    }\n\n    private long dfs(int i, int cnt1, boolean isLimit) {\n        if (i < 0) return cnt1;\n        if (!isLimit && memo[i][cnt1] != -1) return memo[i][cnt1];\n        int up = isLimit ? (int) (num >> i & 1) : 1;\n        long res = 0;\n        for (int d = 0; d <= up; d++) {\n            res += dfs(i - 1, cnt1 + (d == 1 && (i + 1) % x == 0 ? 1 : 0), isLimit && d == up);\n        }\n        if (!isLimit) memo[i][cnt1] = res;\n        return res;\n    }\n}\n"}
{"task_id": "java/16", "content": "\nclass Solution {\n    public List<String> validStrings(int n) {\n        List<String> ans = new ArrayList<>();\n        int mask = ____;\n        for (int i = 0; i < (1 << n); i++) {\n            int x = mask ^ i;\n            if (((x >> 1) & x) == 0) {\n                ans.add(Integer.toBinaryString((1 << n) | i).substring(1));\n            }\n        }\n        return ans;\n    }\n}\n\nConstraints:\n1 <= n <= 10", "groundtruth": "class Solution {\n    public List<String> validStrings(int n) {\n        List<String> ans = new ArrayList<>();\n        int mask = (1 << n) - 1;\n        for (int i = 0; i < (1 << n); i++) {\n            int x = mask ^ i;\n            if (((x >> 1) & x) == 0) {\n                ans.add(Integer.toBinaryString((1 << n) | i).substring(1));\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/17", "content": "\n** 3. 4Sum **\nGiven an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\n\nNotice that the solution set must not contain duplicate triplets.\n\nExample 1:\n\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExample 2:\n\nInput: nums = []\nOutput: []\nExample 3:\n\nInput: nums = [0]\nOutput: []\n\n```\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        int n = nums.length;\n        Arrays.sort(nums);\n        for(int i = 0;i<n;i++){\n            int target = -nums[i];\n            int left = i+1;\n            int right = n-1;\n            while(left<right){\n                int sum = nums[left] + nums[right];\n                if(sum>target)\n                    right--;\n                else if(sum<target)\n                    left++;\n                else{\n                    result.add(new ArrayList<>(Arrays.asList(nums[i],nums[left],nums[right])));\n                    left++;\n                    right--;\n                }\n            }\n        }\n        return result;\n    }\n}\n```\n\n\n** 4. Median of two sorted arrays **\nThere are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\n\nYou may assume nums1 and nums2 cannot be both empty.\n\n\n```\nclass Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int n = nums1.", "groundtruth": "class Solution {\n    public int numberOfSubmatrices(char[][] grid) {\n        int ans = 0;\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][][] sum = new int[m + 1][n + 1][2];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                sum[i + 1][j + 1][0] = sum[i + 1][j][0] + sum[i][j + 1][0] - sum[i][j][0];\n                sum[i + 1][j + 1][1] = sum[i + 1][j][1] + sum[i][j + 1][1] - sum[i][j][1];\n                if (grid[i][j] != '.') {\n                    sum[i + 1][j + 1][grid[i][j] & 1]++;\n                }\n                if (sum[i + 1][j + 1][0] > 0 && sum[i + 1][j + 1][0] == sum[i + 1][j + 1][1]) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/18", "content": "\nThe sample case is as follows:\nExample 1:\n\nInput: target = \"abcba\", words = [\"ab\",\"ba\",\"abc\",\"cab\"], costs = [1,2,3,4]\nOutput: 3\nExplanation:\nWe can use the fourth operation, i.e. append ba to target, to get target = \"abcba\".\n\nExample 2:\n\nInput: target = \"abccba\", words = [\"ab\",\"ba\",\"bca\",\"bda\",\"bdca\"], costs = [1,2,3,4,5]\nOutput: 5\nExplanation:\nWe can append the second operation, i.e. append ab, and then append ba, and finally append the second b to target to get target = \"abccba\".\nNote that the operation can be done even if it will increase the cost by 1. Please see the example 2 in the explanation for the example 1.\n\nExample 3:\n\nInput: target = \"cbabacdca\", words = [\"cba\",\"bac\",\"bda\",\"bad\",\"bdca\"], costs = [2,4,5,3,7]\nOutput: 8\nExplanation:\nWe can append the third operation, i.e. append bda to target, then append the third operation, i.e. append bad to target, then append the second operation, i.e. append bac to target. Notice that it is allowed to use the operations in any order.\n\nConstraints:\n\n1 <= target.length <= 10^5\ntarget consists of lowercase English letters.\n1 <= words.length <= 5000\n1 <= words[i].length, costs[i] <= target.length\nwords[i] and target contain lowercase English letters only.\nwords[i] starts with a lowercase English letter.\nAll the characters of words[i] are unique.\nAll the operations do not", "groundtruth": "class Solution {\n    public int minimumCost(String target, String[] words, int[] costs) {\n        char[] t = target.toCharArray();\n        int n = t.length;\n\n        final int MOD = 1_070_777_777;\n        final int BASE = (int) 8e8 + new Random().nextInt((int) 1e8);\n        int[] powBase = new int[n + 1];\n        int[] preHash = new int[n + 1];\n        powBase[0] = 1;\n        for (int i = 0; i < n; i++) {\n            powBase[i + 1] = (int) ((long) powBase[i] * BASE % MOD);\n            preHash[i + 1] = (int) (((long) preHash[i] * BASE + t[i]) % MOD);\n        }\n\n        Map<Integer, Map<Integer, Integer>> minCost = new TreeMap<>();\n        for (int i = 0; i < words.length; i++) {\n            long h = 0;\n            for (char b : words[i].toCharArray()) {\n                h = (h * BASE + b) % MOD;\n            }\n            minCost.computeIfAbsent(words[i].length(), k -> new HashMap<>())\n                   .merge((int) h, costs[i], Integer::min);\n        }\n\n        int[] f = new int[n + 1];\n        Arrays.fill(f, Integer.MAX_VALUE / 2);\n        f[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            for (Map.Entry<Integer, Map<Integer, Integer>> e : minCost.entrySet()) {\n                int len = e.getKey();\n                if (len > i) {\n                    break;\n                }\n                int subHash = (int) (((preHash[i] - (long) preHash[i - len] * powBase[len]) % MOD + MOD) % MOD);\n                f[i] = Math.min(f[i], f[i - len] + e.getValue().getOrDefault(subHash, Integer.MAX_VALUE / 2));\n            }\n        }\n        return f[n] == Integer.MAX_VALUE / 2 ? -1 : f[n];\n    }\n}\n"}
{"task_id": "java/19", "content": "\n## 待定答案\n这题的思路是一样的，不过这次就是两个循环了。\n\n```java\nclass Solution {\n    public ListNode modifiedList(int[] nums, ListNode head) {\n        ListNode dummy = new ListNode(0, head);\n        ListNode cur = dummy;\n        \n        Set<Integer> set = new HashSet<>();\n        for (int i = 0; i < nums.length; i++) {\n            set.add(nums[i]);\n        }\n        \n        while (cur.next != null) {\n            if (set.contains(cur.next.val)) {\n                cur.next = cur.next.next;\n            } else {\n                cur = cur.next;\n            }\n        }\n        return dummy.next;\n    }\n}\n```\n\n## 分析\n最初我还是使用了之前的方法，不过在进行的过程中发现一个问题，就是说，题目说是要删除，很多人都是使用了将next指向后一个next，感觉在内存空间上其实已经释放了，但是如果某个指针一直在指向它，那么内存占用会一直存在。\n\n所以最终使用的是一种更为节省空间的方法：\n将每一个元素赋值给dummy的next指向的，然后再将他next指向前面的next。\n\n这种方法是很节省内存的一种方式，同时可以简化代码：\n```java\nclass Solution {\n    public ListNode modifiedList(int[] nums, ListNode head) {\n        Set<Integer> set = new HashSet<>();\n        for (int x : nums) {\n            set.add(x);\n        }\n        ListNode dummy = new ListNode(0, head);\n        ListNode cur = dummy;\n        while (cur", "groundtruth": "class Solution {\n    public ListNode modifiedList(int[] nums, ListNode head) {\n        Set<Integer> set = new HashSet<>(nums.length); // 预分配空间\n        for (int x : nums) {\n            set.add(x);\n        }\n        ListNode dummy = new ListNode(0, head);\n        ListNode cur = dummy;\n        while (cur.next != null) {\n            if (set.contains(cur.next.val)) {\n                cur.next = cur.next.next; // 删除\n            } else {\n                cur = cur.next; // 向后移动\n            }\n        }\n        return dummy.next;\n    }\n}\n"}
{"task_id": "java/20", "content": "\nThe input and output format is the same as it is described above. For example, the input is 3 3 2 1 2 2 where the first line means that the cake has dimensions 3 x 3, the second line describes the cost to cut the cake along horizontal lines (2, 1), and the last line describes the cost to cut the cake along vertical lines (2, 2). The output should be 4, which is the minimum cost to cut the cake into 1 x 1 pieces.\n\nExample 1:\n\nInput:\n3 3 2 1 2 2\n\nOutput:\n4\n\nExplanation:\nThe optimal cut is -\n![](https://assets.leetcode.com/uploads/2020/06/17/leetcode_cut_cake_3_1.png)\n\nExample 2:\n\nInput:\n7 7 3 14 7 13\n\nOutput:\n124\n\nExplanation:\nThe optimal cut is -\n![](https://assets.leetcode.com/uploads/2020/06/17/leetcode_cut_cake_3_2.png)\n\n\n\"\"\"\nfrom typing import List\n\nclass Solution:\n    def minimumCost(self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]) -> int:\n        self.m = m\n        self.n = n\n        horizontalCut = [0] + horizontalCut\n        verticalCut = [0] + verticalCut\n        total_cut = m * n + m - 1 + n - 1\n        self.min = [0] * total_cut\n        self.cut = [[0] * (n + 1) for _ in range(m + 1)]\n        for row in range(1, m + 1):\n            for col in range(1, n + 1):\n                self.cut[row][col] = min(self.cut[row - 1][col], self.cut[row][col - 1]) + 1\n        self.cut[0][0] = -1\n", "groundtruth": "class Solution {\n    public int minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {\n        int[][][][] dp = new int[m][n][m][n];\n        for (int i1 = 0; i1 < m; i1++) {\n            for (int j1 = 0; j1 < n; j1++) {\n                for (int i2 = 0; i2 < m; i2++) {\n                    Arrays.fill(dp[i1][j1][i2], Integer.MAX_VALUE);\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[i][j][i][j] = 0;\n            }\n        }\n        for (int rowCount = 1; rowCount <= m; rowCount++) {\n            for (int colCount = 1; colCount <= n; colCount++) {\n                for (int i1 = 0, i2 = rowCount - 1; i2 < m; i1++, i2++) {\n                    for (int j1 = 0, j2 = colCount - 1; j2 < n; j1++, j2++) {\n                        for (int midRow = i1; midRow < i2; midRow++) {\n                            dp[i1][j1][i2][j2] = Math.min(dp[i1][j1][i2][j2], horizontalCut[midRow] + dp[i1][j1][midRow][j2] + dp[midRow + 1][j1][i2][j2]);\n                        }\n                        for (int midCol = j1; midCol < j2; midCol++) {\n                            dp[i1][j1][i2][j2] = Math.min(dp[i1][j1][i2][j2], verticalCut[midCol] + dp[i1][j1][i2][midCol] + dp[i1][midCol + 1][i2][j2]);\n                        }\n                    }\n                }\n            }\n        }\n        return dp[0][0][m - 1][n - 1];\n    }\n}\n"}
{"task_id": "java/21", "content": "\nFor example,\n\nGiven s = \"ca\",\nreturn true.\n\nGiven s = \"aba\",\nreturn false.\n\nNote:\ns will only contain lowercase letters.\n\n'''\n\nclass Solution {\n    public boolean doesAliceWin(String s) {\n        int[] a = new int[s.length()];\n        int sum = 0;\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                sum++;\n            }\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                a[i] = sum % 2 == 0 ? 1 : 0;\n            } else {\n                a[i] = sum % 2 == 0 ? 0 : 1;\n            }\n        }\n        int n = s.length();\n        for (int i = 0; i < n - 1; i++) {\n            if (a[i] == a[i + 1]) {\n                return false;\n            }\n        }\n        return a[0] == 1;\n    }\n}\n\n\n# 题意:\n输入一个字符串s,有两人(Alice和Bob)在s上依次移动,\n要求Alice赢,\n\n在Alice移动后,下一个人必须移除当前一个人所选择的子字符串,\n子字符串必须至少包含一个元音字符,\n移除子字符串的方法不受限, 且这些移除掉的子字符串不会影响移除的下一步,\n每一步子字符串移除之后,s中会存在n个字符,其中包括一个元音字符,\nAlice和", "groundtruth": "class Solution {\n    public boolean doesAliceWin(String s) {\n        for (char c : s.toCharArray()) {\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"task_id": "java/22", "content": "\n \n\nExample 1:\n\nInput: s = \"010010\"\nOutput: 2\nExplanation: We move the '0' at index 2 to index 5, and the '1' at index 1 to index 4.\n\nExample 2:\n\nInput: s = \"10\"\nOutput: 0\nExplanation: There are no '1's in s to move.\n\nExample 3:\n\nInput: s = \"001011101\"\nOutput: 2\nExplanation: We can move the '1' at index 3 to index 6, then the '1' at index 1 to index 3.\n\n \n\nConstraints:\n\n    1 <= s.length <= 105\n    s[i] is either '0' or '1'.\n    There will be at most 5000 operations.\n\nAccepted\n187,926\nSubmissions\n616,598\n\n*/\n\n\nclass Solution {\n    public int maxOperations(String s) {\n        char[] charArray = s.toCharArray();\n        int count1 = 0;\n        int count2 = 0;\n        int cnt = 0;\n        for(int i = 0; i < charArray.length; i++){\n            if(charArray[i] == '1' && i+1 < charArray.length && i+1 < s.length()){\n                if(charArray[i+1] == '0'){\n                    count1++;\n                    cnt++;\n                    charArray[i+1] = '1';\n                }\n                else{\n                    if(charArray[i+1] == '1' && i+2 < s.length() && charArray[i+2] == '0'){\n                        count2++;\n                        cnt++;\n                        charArray[i+2] = '1';\n                    }\n                }\n            }\n        }\n        return cnt;\n    }\n}\n\n//========================================================\n\nclass Solution {\n    public int maxOperations(String s) {\n        int ans", "groundtruth": "class Solution {\n    public int maxOperations(String S) {\n        char[] s = S.toCharArray();\n        int ans = 0;\n        int cnt1 = 0;\n        for (int i = 0; i < s.length; i++) {\n            if (s[i] == '1') {\n                cnt1++;\n            } else if (i > 0 && s[i - 1] == '1') {\n                ans += cnt1;\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/23", "content": "Please run the code carefully.\nThe length of both the two arrays is in the range [1, 10,000]. The answer should be correct up to the 6th decimal place.\n\nThe data is as follows:\n[1,3,11,2]\n[1,4,7,15]\nThe answer is as follows:\n1\n\n\n\n\n\n\nclass Solution {\n    public long minimumOperations(int[] nums, int[] target) {\n        long s = target[0] - nums[0];\n        long ans = Math.abs(s);\n        for (int i = 1; i < nums.length; i++) {\n            int k = (target[i] - target[i - 1]) - (nums[i] - nums[i - 1]);\n            if (k > 0) {\n                ans += s >= 0 ? k : Math.max(k - s, 0);\n            } else {\n                ans -= s < 0 ? k : Math.min(k + s, 0);\n            }\n            s += k;\n        }\n        return ans;\n    }\n}\n\n/*\n\n[1,3,11,2]\n[1,4,7,15]\n\n\n\ns=target[0]-nums[0]\nif k>0;\ns>=0 -> ans+=k\ns<0 -> ans+=min(k-s,0)\n\n\nif k<0;\ns>0 -> ans+=k\ns<=0 -> ans+=min(k+s,0)\n\n\n\n1->1\n3->4->7\n", "groundtruth": "class Solution {\n    public long minimumOperations(int[] nums, int[] target) {\n        long s = target[0] - nums[0];\n        long ans = Math.abs(s);\n        for (int i = 1; i < nums.length; i++) {\n            int k = (target[i] - target[i - 1]) - (nums[i] - nums[i - 1]);\n            if (k > 0) {\n                ans += s >= 0 ? k : Math.max(k + s, 0);\n            } else {\n                ans -= s <= 0 ? k : Math.min(k + s, 0);\n            }\n            s += k;\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/24", "content": "\nThe return value of your function", "groundtruth": "class Solution {\n    private static final int MX = 31622;\n    private static final int[] PI = new int[MX + 1];\n\n    static {\n        for (int i = 2; i <= MX; i++) {\n            if (PI[i] == 0) { // i 是质数\n                PI[i] = PI[i - 1] + 1;\n                for (int j = i * i; j <= MX; j += i) {\n                    PI[j] = -1; // 标记 i 的倍数为合数\n                }\n            } else {\n                PI[i] = PI[i - 1];\n            }\n        }\n    }\n\n    public int nonSpecialCount(int l, int r) {\n        return r - l + 1 - (PI[(int) Math.sqrt(r)] - PI[(int) Math.sqrt(l - 1)]);\n    }\n}\n"}
{"task_id": "python/0", "content": "\nInput Format\nThe first line of input contains two space-separated integers n and m denoting the number of rows and columns of grid. \nThe next n lines contain n space-separated integers each denoting the elements of the respective row. \nThe last line contains a single integer m denoting the integer value for which we have to calculate the sum of the adjacent and diagonal elements.\n\nNote: When a diagonal element is not present in grid, it should not be included in the sum.\n\nOutput Format\nOutput the following two lines:\n\nIn the first line, print the sum of all the adjacent elements of m.\nIn the second line, print the sum of all the diagonal elements of m.\n\nConstraints\n1 <= n <= 5\nn2 <= m <= n2\nExample Input 0\n\n4 5\n1 2 3 4\n0 6 2 5\n1 3 5 0\n2 3 2 0\n7\nExample Output 0\n\n27\n31\nExplanation 0\n\nThe sum of all the adjacent elements is:\n\n 3  5  0  5  0  1\n 0  2  6  3  3  2\n 1  3  5  5  3  0\n 5  5  3  0  2  0\nThe sum of the diagonal elements is:\n\n 0  3  5  5  3  2\n 1  0  5  6  5  5\n 0  5  5  5  6  3\n 0  3  0  5  7  5\nAs we can see, there are two diagonal elements adjacent to value 7.\nThe sum of all the diagonal elements is 26.\nExample Input 1\n\n4 3\n5 2 3\n2 2 2\n2 2 2\n2\nExample Output 1\n\n5\n7\nExplanation 1\n\nThe sum of all the adjacent elements is:\n\n 3  2  3\n 2  3  2\n 2  2  3\n 2  2  2\nThe sum of the diagonal elements is:\n\n 0  3  5\n 1  0  6\n 0  5  0\nAs we can see, there", "groundtruth": " DIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n    "}
{"task_id": "python/1", "content": "\nYou may notice that the diagonals are not symmetric. Please consider the edges of the", "groundtruth": " DIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n "}
{"task_id": "python/2", "content": "\nExample 1:\n\nInput: grid = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [20,20,20]\nExplanation:\nHere, the 0th value equals:\nTop left value (1) + Top middle value (5) + Top right value (9) + Left middle value (4) + Right middle value (7) = 1 + 5 + 9 + 4 + 7 = 20\nMiddle left value (2) + Bottom left value (6) + Bottom middle value (8) + Middle right value (3) + Top middle value (5) = 2 + 6 + 8 + 3 + 5 = 20\nMiddle right value (3) + Bottom middle value (8) + Bottom right value (9) + Left middle value (4) + Middle left value (2) = 3 + 8 + 9 + 4 + 2 = 20\nHere is a visual representation of the values:\n1 2 3       1 2 3 \n4 5 6   ==>  4 5 6 \n7 8 9       7 8 9\nExample 2:\n\nInput: grid = [[1,0,3],[4,0,6],[0,2,9]]\nOutput: [16,11,20]\nExplanation:\nHere, the 0th value equals:\nTop left value (1) + Top middle value (5) + Top right value (9) + Middle left value (4) + Middle right value (3) = 1 + 0 + 0 + 4 + 0 = 8\nLeft middle value (0) + Bottom middle value (8) + Middle right value (3) + Top middle value (5) + Bottom right value (9) = 0 + 0 + 0 + 5 + 0 = 10\nRight middle value (0) + Bottom middle value (8) + Bottom right value (9) + Middle left value (4) + Top middle value (5) = 0 + 0 + 0 + 4 + 0 = 12\nHere is a visual representation of the values:\n1 0 ", "groundtruth": " DIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n  "}
{"task_id": "python/3", "content": "Please use Python 3 to solve this problem.\nExamples\nInput:\nn = 5, queries = [[0,4], [1,2], [1,3], [2,0], [0,2]]\nOutput:\n[1, 3, 0, 1, 2]\n \nConstraints:\n2 <= n <= 10^5\n1 <= queries.length <= 10^5\nqueries[i].length == 2\n0 <= queries[i][0], queries[i][1] < n\n\n\n# BFS solution, TLE\nimport collections\nfrom typing import List\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = collections.defaultdict(list)\n        vis = [0] * n\n        queue = collections.deque([0])\n        for i in range(n-1):\n            g[i].append(i+1)\n        ret = [0] * len(queries)\n        for i in range(len(queries)):\n            l, r = queries[i][0], queries[i][1]\n            if vis[r] == i:\n                queue.append(r)\n            else:\n                g[l].append(r)\n                if vis[l] == i:\n                    while queue:\n                        if queue[0] == l:\n                            queue.popleft()\n                            break\n                        queue.append(queue.popleft())\n                else:\n                    ret[i] = self.bfs(n, g, vis, queue)\n            vis[r] = i\n        return ret\n    \n    def bfs(self, n, g, vis, queue):\n        for i in range(n-1):\n            tmp = queue\n            queue = collections.deque()\n            for x in tmp:\n                for y in g[x]:\n                    if y == n-1:\n                        return len(tmp) + 1\n                    if vis[y] == 0:\n                        queue.append(y)\n                    vis[y] = 1\n            queue.append(queue.popleft", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n  "}
{"task_id": "python/4", "content": "\n## Method 1: BFS\n\n```python\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n```\n\n### Time Complexity\n\nO(n + m)\n\nwhere n is the number of nodes, m is the number of queries.\n\n### Space Complexity\n\nO(n)\n\nwhere n is the number of nodes.\n\n## Method 2: BFS + Queue\n\n```python\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = []\n                for x in q:\n                    for y in g[x]:\n                        if vis[y] != i:\n                            vis[y] = i\n                            tmp.append(y)\n                q = tmp\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n "}
{"task_id": "python/5", "content": "\nExplanation\nThe city is represented by a tree. We use a depth-first search to find all cities.\nWe store the last query that the city is included in in the graph.\nWhen a shortest path is needed from the query to the last query of the city, we reverse the path from the last query of the city.\n \nConstraints:\n2 <= n <= 102\n1 <= queries.length <= 102\n0 <= ui, vi < n\n0 <= ui != vi\n\"\"\"\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n    \n    \nsolution = Solution()\nprint(solution.shortestDistanceAfterQueries(5, [\n        [2, 1],\n        [1, 0],\n        [1, 0],\n        [4, 1]\n        ]))\n\nprint(solution.shortestDistanceAfterQueries(6, [\n        [0, 5],\n        [0, 4],\n        [3, 5],\n        [1, 4],\n        [2, 4],\n        [1, 3]\n        ]))\n\nprint(solution.shortestDistanceAfterQueries(6, [\n        [0, 4],\n        [0, 3],", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n "}
{"task_id": "python/6", "content": "\n样例输入:\n8\n[[1,4],[1,5],[2,3],[6,3],[5,3],[6,3],[1,6],[4,6]]\n\n样例输出:\n[2,3,3,2,3,2,3,2]\n\n备注:\n2 <= n <= 10^5\n0 <= queries.length <= n * (n - 1) / 2\n0 <= queries[i][0], queries[i][1] < n\n*/\n\n\nclass UnionSet\n{\npublic:\n    int n;\n    vector<int> father;\n    int numDisjoint;\n\n    UnionSet(int n) : n(n), father(n), numDisjoint(n)\n    {\n        for (int i = 0; i < n; ++i)\n        {\n            father[i] = i;\n        }\n    }\n\n    int Find(int x)\n    {\n        return father[x] == x ? x : father[x] = Find(father[x]);\n    }\n\n    bool Union(int x, int y)\n    {\n        int fx = Find(x);\n        int fy = Find(y);\n        if (fx == fy)\n        {\n            return false;\n        }\n        father[fx] = fy;\n        --numDisjoint;\n        return true;\n    }\n};\n\nclass Solution\n{\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>> &queries)\n    {\n        UnionSet us(n);\n        vector<int> res;\n        for (auto q : queries)\n        {\n            int x = q[0] - 1, y = q[1] - 1;\n            us.Union(x, y);\n            int count = us.numDisjoint;\n            for (int i = 0; i < n; ++i)\n            {\n                if (us.Find(i) != us.Find(y))\n                {\n                    count -= 1;\n                }\n            }\n            res.push_back(count);\n        }\n", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/7", "content": "\nYou can assume that n <= 20000 and queries.length <= 100000. You may assume that there are no duplicate queries and i < vi in all the queries.\n\n \nExample 1:\nInput: n = 3, queries = [[0,1],[1,2],[0,2]]\nOutput: [3,2,2]\nExplanation: In the beginning, each city is connected to the next city. \nAfter the first query [0,1] is executed, we create a road between the \nfirst city and the second city. The second city will be the same as \nthe first city in the next queries. So the shortest path will always \nbe the shortest road between the first and the last city. And the shortest \npath for the first query is 0 -> 1 -> 2, whose length is 3.\nAfter the second query [1,2] is executed, we create a road between the \nsecond city and the third city. Now the shortest path is 0 -> 1 -> 3.\nAfter the third query [0,2] is executed, we create a road between the \nfirst city and the third city. Since the first city is already connected with the last city, \nthe shortest path is still 0 -> 1 -> 3. Thus the shortest distance is 3 for all the queries.\n\nExample 2:\nInput: n = 5, queries = [[4,3],[0,3],[1,2],[2,1],[3,4]]\nOutput: [8,6,2,4,2]\nExplanation: The shortest path is:\n(0) -> 4 -> (3)\n(1) -> 4 -> (3)\n(1) -> 3 -> 4\n(2) -> 3\n(2) -> 4\n(2) -> 3\nThus the shortest path is 0 -> 1 -> 2 -> 3 -> 4 and its length is 8.\n(0) -> 3 -> (1) -> 4\n(0) -> 3\nThus the shortest path is 0 -> 1 -> 2 -> 3 and its length is 6.\n(0) -> 3\nTh", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/8", "content": "\n## [编程题 💻](https://github.com/jimmyltsy/coding-solutions/tree/master/HDU)\n\n+ <a href=\"#a\">1027 </a><a href=\"#b\">1075 </a><a href=\"#c\">2002 </a><a href=\"#d\">3016 </a><a href=\"#e\">4663 </a><a href=\"#f\">6013 </a><a href=\"#g\">6014 </a><a href=\"#h\">6058 </a><a href=\"#i\">6074 </a><a href=\"#j\">6136 </a><a href=\"#k\">6148 </a><a href=\"#l\">6180 </a><a href=\"#m\">6181 </a><a href=\"#n\">6259 </a><a href=\"#o\">6265 </a><a href=\"#p\">6278 </a><a href=\"#q\">6291 </a><a href=\"#r\">6309 </a><a href=\"#s\">6318 </a><a href=\"#t\">6392 </a><a href=\"#u\">6473 </a><a href=\"#v\">6533 </a><a href=\"#w\">6562 </a><a href=\"#x\">6591 </a><a href=\"#y\">6615 </a><a href=\"#z\">6652 </a><a href=\"#A\">6653 </a><a href=\"#B\">6728 </a><a href=\"#C\">6772 </a><a href=\"#D\">6773 </a><a href=\"#E\">6775 </a><a href=\"#F\">6781 </a><a href=\"#G\">6816 </a><a href=\"#H\">6818 </a><a href=\"#I\">6837 </a><a href=\"#J\">6862 </a><a href=\"#K\">6892 </a><a href=\"#L\">6904 </a><a href=\"#M\">6910 </a><a href", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/9", "content": "\nThe test data is as follows:\n```\nInput：\n\n```\n[\"Solution\",\"numberOfAlternatingGroups\",\"numberOfAlternatingGroups\",\"numberOfAlternatingGroups\",\"numberOfAlternatingGroups\",\"numberOfAlternatingGroups\",\"numberOfAlternatingGroups\",\"numberOfAlternatingGroups\",\"numberOfAlternatingGroups\",\"numberOfAlternatingGroups\"]\n[[[0,1]],[[2],[2]],[[1,2],[2]],[[1,2],[3]],[[1,3],[3]],[[1,2],[2]],[[2],[2]],[[1,3],[3]],[[1,4],[4]],[[1,2],[2]]]\n\nOutput:\n\n```\n[\n  [1, 0]\n]\n\nExplanation:\n\n```\n- After processing the first query, there is only one alternating group of length 2.\n- After processing the second query, there is only one alternating group of length 2.\n- After processing the third query, there is now two alternating groups: [0, 1] and [2, 3] where the first one has length 2.\n- After processing the fourth query, there are now three alternating groups: [0, 1] (2 chars), [2, 3] (2 chars), [4, 5] (2 chars).\n- After processing the fifth query, there are now four alternating groups: [0, 1] (2 chars), [2, 3] (2 chars), [4, 5] (2 chars), [6, 7] (2 chars).\n- After processing the sixth query, there is only one alternating group of length 2.\n- After processing the seventh query, there is only one alternating group of length 2.\n- After processing the eighth query, there is only one alternating group of length 2.\n- After processing the ninth query, there are only two alternating groups: [0, 1] and [2, 3, 4, 5] where the second one has length 4.\n- After processing the tenth query, there is only one alternating group of length 2.\n\n```\nExample 2:\n```\nInput:\n\n```\n[\"Solution\",\"numberOfAltern", "groundtruth": " from sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/10", "content": "\nInput：\nThe input consists of two parts. In the first line, an integer n (1 ≤ n ≤ 105) indicates the number of red and blue tiles. Then there are n integers as colors in the next line. After that, an integer m (1 ≤ m ≤ 105) indicates the number of queries. There are m lines. Each line contains 2 integers (1 ≤ i ≤ 104) as described above.\n\nOutput：\nFor each query of type 1, print the count of alternating groups with size sizei. Each result should be separated by a space. Then print a single line containing all the results for all queries of type 1 in order.\n\nSample Input 1:\n4\n0 0 0 0\n1\n[1 2]\n\nSample Output 1:\n3\n\nSample Input 2:\n4\n0 0 1 1\n2\n[2 1]\n[1 3 0]\n\nSample Output 2:\n1 1 0\n\nSample Input 3:\n4\n0 0 0 1\n2\n[2 1]\n[1 3 1]\n\nSample Output 3:\n1 1 0\n\"\"\"\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t", "groundtruth": " from sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/11", "content": "\nPlease submit the completed code. You can use the code template of the LeetCode editorial page. Please do not read the editorial, nor can you read any solution written by other people. You are allowed to search for information about the question, but please do not discuss the question on any site. For copyright issues, we may not show your code. If you pass the test, you will be able to submit the correct code.\n\nFor better user experience, we have disabled the input/output interface. Please try running the code by clicking \"Run Code\" and see the input and output in the console. If you submit your code by clicking the \"Run\" button, the input/output interface will not be shown.\n\nIn order to submit your code, select \"Console\" at the bottom right and type the code in the console. You may use the code template given above to complete your code. \nPlease submit the completed code. You can use the code template of the LeetCode editorial page. Please do not read the editorial, nor can you read any solution written by other people. You are allowed to search for information about the question, but please do not discuss the question on any site. For copyright issues, we may not show your code. If you pass the test, you will be able to submit the correct code.\n\nIn order to submit your code, select \"Console\" at the bottom right and type the code in the console. You may use the code template given above to complete your code. \n\"\"\"\n\nfrom sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n", "groundtruth": " from sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/12", "content": "\nExamples :\n\nInput: nums = [12,24,8,32]\nOutput: false\nExplanation: There are no double-digit numbers in nums so Bob's sum is 0. The only way for Alice to win is if she chooses all the single-digit numbers and the sum of them is 12 which is greater than Bob's sum of 0. \n\nInput: nums = [12,24,8,32,24,5]\nOutput: false\n\nInput: nums = [12,24,8,32,24,5,5]\nOutput: false\n\nInput: nums = [2,2,2,2,2,2,2,2]\nOutput: true\n\n\"\"\"\n\nclass Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        single=0\n        double=0\n        for it in nums:\n            if it>=10: \n                double+=it-", "groundtruth": " class Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        single=0\n        double=0\n        for it in nums:\n            if it>=10: \n                double=double+it \n            else:\n                single=single+it  \n        \n        return single !=double\n "}
{"task_id": "python/13", "content": "\n样例输入\n2 6\n样例输出\n4\n\n题目\n\n题目描述\n\n\n给出 2 个整数 l 和 r ，在区间 [l, r] 内，计算非特殊整数的个数。\n\n\n\n题解\n\n特殊的数是指其除了本身以外，没有其他的正因子的数，例如 4 和 6 都是特殊的数。这里说的正因子只包括其他的自然数，不包括 1 和本身。\n\n所以非特殊数一共有四类，分别是素数（因子只有 1 ）、2 的幂、偶数的正整数和所有能够被 2 整除、3 整除、5 整除 的数，这三类数都是由于其本身因子很特殊所以被划分到了这一类中，所以不会在本题中被考虑。\n\n如何判断这四类数呢？我们先来看素数，素数很显然，可以直接判断一个数是不是素数来定义。而判断它是不是 2 的幂就稍显复杂一点，根据数的二进制表示的规律（2 的幂的二进制表示的最高位一定是 1，且其他位都是 0 ），可以遍历每一位，看看有几个二进制表示中的位数是 1 的，如果只有一个，那么就一定是 2 的幂。\n\n最后一类数 2 的倍数（即为所有能够被 2 整除、3 ", "groundtruth": " MX = 31622\npi = [0] * (MX + 1)\nfor i in range(2, MX + 1):\n    if pi[i] == 0:  # i 是质数\n        pi[i] = pi[i - 1] + 1\n        for j in range(i * i, MX + 1, i):\n            pi[j] = -1  # 标记 i 的倍数为合数\n    else:\n        pi[i] = pi[i - 1]\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        return r - l + 1 - (pi[isqrt(r)] - pi[isqrt(l - 1)])\n"}
{"task_id": "python/14", "content": "The return value is the answer to the original question.\nSample 1:\n\nInput: [2,3,3,2,2]\n\nOutput: 3\n\nExplanation:\n\nFor each number in the range [2, 3, 3, 2, 2], list all possible divisors of that number.\n\n1  2   2       2       2\n|  |  |  |     |  |     |\n|  |  |  |     |  |  _  |\n|  |  |  |     |  _  |  |\n|  |  |  |     _  |  |  |\n|  |  |  _   |  |  |  |\n|  |  _   |  |  |  |  |\n_  |  _   |  |  |  |  |\n---------------  -  -  |\n|  |  |  |     |  |  |  |\n|  |  |  |     |  |  |  |\n|  |  |  |     |  |  |  |\n|  |  |  |     |  |  |  |\n|  |  |  |     |  |  |  |\n|  |  |  |     |  |  |  |\n|  |  |  |     |  |  |  |\n|  |  |  |     |  |  |  |\n\nYou can see that when the range is 2 ~ 3, only the number 2 has only one special number, while the numbers 3 and 3 have 2 special numbers. Therefore the count is 3 - 1 = 2. When the range is 2 ~ 2, the number 2 has one special number, but the number 2 has no special numbers. Therefore the count is 2 - 1 = 1.\n\n'''\n\nMX = 31622\npi = [0] * (MX + 1)\nfor i in range(2, MX + 1):\n    if pi[i] == 0:  # i 是质数\n        pi[i] = pi[i - 1] + 1\n        for j", "groundtruth": " MX = 31622\npi = [0] * (MX + 1)\nfor i in range(2, MX + 1):\n    if pi[i] == 0:  # i 是质数\n        pi[i] = pi[i - 1] + 1\n        for j in range(i * i, MX + 1, i):\n            pi[j] = -1  # 标记 i 的倍数为合数\n    else:\n        pi[i] = pi[i - 1]\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        return r - l + 1 - (pi[isqrt(r)] - pi[isqrt(l - 1)])\n "}
{"task_id": "python/15", "content": "\nExample 1:\n\nInput: s = \"011001\"\nOutput: 5\nExplanation: The 5 substrings are :\n\"011001\" : dominated by 1s\n\"01100\" : dominated by 0s\n\"11001\" : dominated by 1s\n\"1100\" : dominated by 0s\n\"1001\" : dominated by 1s\nNote that the first two zeroes are not dominated by 0s because there are two zeros in a row.\nExample 2:\n\nInput: s = \"1011101\"\nOutput: 9\nExplanation: The 9 substrings are :\n\"1011101\" : dominated by 1s\n\"011101\" : dominated by 0s\n\"11101\" : dominated by 1s\n\"01101\" : dominated by 0s\n\"101101\" : dominated by 1s\n\"11101\" : dominated by 1s\n\"0101101\" : dominated by 0s\n\"1101101\" : dominated by 1s\n\"1001101\" : dominated by 1s\n \n\nConstraints:\n\n2 <= s.length <= 5 x 105\ns[i] is either '0' or '1'.\n*/\n\nclass Solution {\npublic:\n    int numberOfSubstrings(string s) {\n        int ans = 0, l = s.size(), i = 0;\n        for (int j = 0; j < l; j++) {\n            if (s[j] == '0') {\n                i = j;\n            }\n            if (s[j] == '1') {\n                int cnt0 = j - i + 1;\n                if (cnt0 * cnt0 > l - j) break;\n                int cnt1 = l - j - (j - i);\n                ans += max(l - j - (j - i) - (cnt0 *", "groundtruth": " class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n "}
{"task_id": "python/16", "content": "\nThe input format is as follows:\nThe input contains only one line, which contains a string s, whose length is no more than 105. There is no blank space in it.\n\nThe output format is as follows:\nA line containing an integer N, representing the number of substrings with dominant ones.\n\nIt is guaranteed that the answer is a 32-bit integer.\n\n样例：\n\n输入：\n010100\n\n输出：\n12\n\n提示：\n\n总共有 40326 个子串。其中：\n\n 110011\n00110100\n0011010000\n000011010000\n... 共有 12 个子串满足条件。\n\n分析：https://leetcode-cn.com/problems/number-of-substrings-with-only-1s/solution/jian-dan-xing-zui-xiao-yi-yuan-chuan-0y1-9g7j/\n\nhttps://leetcode.com/problems/count-number-of-special-subsequences/discuss/1366159/JavaC%2B%2BPython-Fenwick-Tree-with-explanation\n\n\n\n#Fenwick\n\n\n```c++\nclass Solution {\npublic:\n    int m,n;\n    int **ft;\n\n    int lowbit(int x){\n        return x & (-x);\n    }\n\n    int sumRange(int i){\n        int ans = 0;\n        while(i>0){\n            ans+=ft[m][i];\n            i-=lowbit(i);\n        }\n        return ans;\n    }\n\n    void add(int i,int x){\n        while(i<=n){\n            ft[m][i]+=x;\n            i+=lowbit(i);\n        }\n    }\n\n    int specialSubseq(string s) {\n        n = s.size();\n        m = (int) (2*pow(", "groundtruth": " class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n    "}
{"task_id": "python/17", "content": "The output should be the integer.\n\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                ans += cnt1 * cnt1 <= tot1 * cnt0\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n    \n\nExample 1:\n\nInput: s = \"111000\"\nOutput: 4\n\nExplanation: All substrings are: \"111000\", \"11100\", \"1110\", \"11\", and \"1\".\nThey are", "groundtruth": " class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n    "}
{"task_id": "python/18", "content": "\nGiven integers xCorner, yCorner, and a 2D array circles, where circles[i] = [xi, yi, ri] denotes a circle with center at (xi, yi) and radius ri, you need to write a code to find out whether there is a path between the bottom left corner of the coordinate plane and the top right corner of the coordinate plane such that the entire path lies inside the rectangle defined by (0,0) and (xCorner, yCorner). Note that the starting and ending points are both inside the rectangle.\n\nNotice:\nThe x-coordinate is the first element of the tuple, the y-coordinate is the second element of the tuple, and the radius of a circle is the third element of the tuple.\n\nIn case there are multiple paths satisfying the requirements, any of the path is fine as the answer.\n\nIt is guaranteed that there is at least one way satisfying the requirements.\n\nExamples\nExample 1:\nInput: 5, 5, [[3, 4, 1]]\nOutput: false\nExample 2:\nInput: 20, 20, [[6, 6, 5], [10, 10, 5]]\nOutput: true\nExample 3:\nInput: 40, 40, [[10, 10, 5], [20, 20, 5]]\nOutput: true\nExample 4:\nInput: 100, 100, [[20, 20, 5], [50, 50, 5]]\nOutput: true\nNote:\n1 <= xCorner, yCorner <= 100\n1 <= circles.length <= 50\n0 <= circles[i][0], circles[i][1] <= 100\n1 <= circles[i][2] <= 50\n'''\n\n\n# Approach 1: DFS\n# '''\n# 时间复杂度：O(n)。n 为 xCorner * yCorner。\n# 空间复杂度：O(n)。\n# '''\nclass Solution:\n    def canReachCorner(self, xCorner: int, yCorner: int, circles:", "groundtruth": " class Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and \\\n                   (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or \\\n               in_circle(x, y, r, X, Y) or \\\n               not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n    "}
{"task_id": "python/19", "content": "\nNote: You may assume that any circle will be not crossed by any line segment outside of the circle. That is, any two circles will never intersect in one point.\n\nA path is defined by the following rules:\n\nYou may start at any point within the circle, as long as it is not in the bottom left corner.\nEvery step must be either a step up (x+1 and y), a step right (x, y+1), a step down (x-1 and y), or a step left (x, y-1).\nWhenever the next move takes a line outside of the rectangle, the line is said to \"touch the boundary\" of the rectangle.\nIt's guaranteed that there will be exactly one path between the two given coordinates in the rectangle that doesn't touch any circles.\n\nExample 1:\n\nInput: xCorner = 1, yCorner = 1, circles = [[1,1,1]]\nOutput: true\nExplanation: The path\n- Step left (1, 0)\n- Step left (0, 0)\n- Step left (0, 1)\n- Step right (1, 1)\nis outside the circle, so it only touches the circle at the starting point.\nExample 2:\n\nInput: xCorner = 1, yCorner = 1, circles = [[1,1,1],[2,2,1]]\nOutput: false\nExplanation: There is no path that doesn't touch the circles.\n\n\n\"\"\"\nclass Solution:\n    def canReachCorner(self, x: int, y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        def dfs(i, r, x, y, path, touch):\n            if x == 0 and y == 0:\n                return path\n            # 距离点 x，y", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or                x1 <= X and y1 <= r1 or                x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and                    (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and                    x1 * r2 + x2 * r1 < (r1 + r2) * X and                    y1 * r2 + y2 * r1 < (r1 + r2) * Y and                    dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or                in_circle(x, y, r, X, Y) or                not vis[i] and (x <= X and abs(y - Y) <= r or                                y <= Y and x <= r or                                y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/20", "content": "\n## Example 1:\n\n![](https://assets.leetcode.com/uploads/2020/11/14/untitled-diagram.png)\n\n> Input: xCorner = 2, yCorner = 2, circles = [[1,1,2],[2,2,1]] Output: true\n\n## Example 2:\n\n![](https://assets.leetcode.com/uploads/2020/11/14/untitled-diagram-1.png)\n\n> Input: xCorner = 0, yCorner = 4, circles = [[1,1,2],[2,2,1]] Output: false\n\n## Example 3:\n\n![](https://assets.leetcode.com/uploads/2020/11/14/untitled-diagram-2.png)\n\n> Input: xCorner = 1, yCorner = 1, circles = [[1,1,1]] Output: true\n\n## Example 4:\n\n> Input: xCorner = 0, yCorner = 1, circles = [[1,1,2]] Output: false\n\n## Constraints:\n\n* 2 <= xCorner, yCorner <= 100\n* 1 <= circles.length <= 50\n* circles[i].length == 3\n* 0 <= xi, yi, ri <= 100\n\n## Solution\n\n```Python\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or                x1 <= X and y1 <= r1 or                x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and                    (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and                    x1 * r2 + x2 * r1 < (r1 + r2) * X and                    y1 * r2 + y2 * r1 < (r1 + r2) * Y and                    dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or                in_circle(x, y, r, X, Y) or                not vis[i] and (x <= X and abs(y - Y) <= r or                                y <= Y and x <= r or                                y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/21", "content": "\nSolution:\n\nclass Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        def check(i):\n            for j in range(n):\n                if i == j:\n                    continue\n                elif grid[i][j] and grid[j][i]:\n                    continue\n                elif not grid[i][j] and not grid[j][i]:\n                    return False\n                else:\n                    return i < j if grid[i][j] else i > j\n            return True\n        n = len(grid)\n        for i in range(n):\n            if check(i):\n                return i\n\nNote that the above code will fail in some cases like: [0, 0, 1, 1], in such cases, the correct implementation should be:\n\nclass Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        def check(i):\n            for j in range(n):\n                if i == j:\n                    continue\n                elif grid[i][j] and grid[j][i]:\n                    continue\n                elif not grid[i][j] and not grid[j][i]:\n                    return False\n                else:\n                    return i if grid[i][j] else j\n            return True\n        n = len(grid)\n        for i in range(n):\n            if check(i):\n                return i\n\n\"\"\"\n\nclass Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        def check(i):\n            for j in range(n):\n                if i == j:\n                    continue\n                elif grid[i][j] and grid[j][i]:\n                    continue\n                elif not grid[i][j] and not grid[j][i]:\n                    return False\n                else:\n                    return i if grid[i][j] else j\n            return True\n        n = len(grid)\n        for i in range(n):\n            if check(i):\n                return i\n\nclass Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        def check", "groundtruth": "\nclass Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        def check(i):\n            for j in range(n):\n                if i == j:\n                    continue\n                elif grid[i][j] == 1 and grid[j][i] == 0:\n                    continue\n                else:\n                    return False\n            return True\n        n = len(grid)\n        for i in range(n):\n            if check(i):\n                return i\n"}
{"task_id": "python/22", "content": "\nIf you are not familiar with DAG, please read the following link.\n\nhttps://en.wikipedia.org/wiki/Directed_acyclic_graph\n\n \n\nExample 1:\n\nInput: n = 7, edges = [[0,1],[1,2],[1,4],[4,5],[2,3],[3,6]]\nOutput: 5\nExplanation: The optimal way to choose the teams is:\n- 0 as the champion.\n- 4, 3, and 6 as the first, second, and third places.\nThe maximum possible value is 0 + 4 + 3 + 6 = 13.\n\n\nSolution:-\n\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        graph = [[] for i in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n\n\nExample 1:\nInput: n = 7, edges = [[0,1],[1,2],[1,4],[4,5],[2,3],[3,6]]\nOutput: 5\nExplanation: The optimal way to choose the teams is:\n- 0 as the champion.\n- 4, 3, and 6 as the first, second, and third places.\nThe maximum possible value is 0 + 4 + 3 + 6 = 13.\n\nExample 2:\nInput: n = 12, edges = [[0,1],[1,2],[2,3],[3,4],[5,6],[6", "groundtruth": "\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/23", "content": "\nConstraints:\n\n1 <= n <= 105\n1 <= edges.length <= 3 * 104\nedges[i].length == 2\n0 <= ui, vi <= n - 1\nui != vi\nAll the teams are connected in the", "groundtruth": "\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/24", "content": "\nNote: You can use an array of size n to store values (i.e., nums) instead of the original list.\n\nExample 1:\nInput: edges = [[0,1],[0,2],[2,3]], values = [1,3,2,4]\nOutput: 8\nExplanation: The figure on the right shows the given tree. There are 4 leaves at the bottom. The leaf with value 4 is at the bottom-left, whereas the leaf with value 3 is at the bottom-right.\nThe path from the root to the bottom-left leaf goes through nodes 0 -> 2. The path from the root to the bottom-right leaf goes through nodes 0 -> 1 -> 2. Therefore, the sum of values on the path from the root to the bottom-left leaf is 3 + 2 = 5, and the sum on the path from the root to the bottom-right leaf is 1 + 3 = 4. Thus, the minimum value of scores is max(5, 4) = 5, and the maximum score is 5 + 4 = 9.\n\nExample 2:\nInput: edges = [[0,1],[1,2],[2,3],[1,4],[4,5]], values = [1,2,4,6,7,8]\nOutput: 13\nExplanation: The figure on the right shows the given tree.\nThe leaf with value 8 is at the bottom-left, whereas the leaf with value 7 is at the bottom-right.\nThe path from the root to the bottom-left leaf goes through nodes 0 -> 4 -> 5. The path from the root to the bottom-right leaf goes through nodes 0 -> 1 -> 4 -> 5. Therefore, the sum of values on the path from the root to the bottom-left leaf is 7 + 8 = 15, and the sum on the path from the root to the bottom-right leaf is 1 + 7 + 8 = 25. Thus, the minimum value of scores is max(15, 25) = 25, and the maximum score is 25 + 15 = 40.\n\nExample 3:\nInput: edges = [[0,1],[0,2],[", "groundtruth": "\nclass Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v != p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp1 + nums[u], dp0)\n            \n        return dfs(0)[1]\n"}
{"task_id": "python/25", "content": "Sample input 1\n\n[1,2,3,5]\nSample output 1\n\n7\nSample input 2\n\n[6,5,2]\nSample output 2\n\n7\nNote\n\n- A balanced subsequence is a subsequence which the difference of \nany two consecutive elements of the subsequence is at most 1. \n- 1≤k≤len(nums)≤50000.\n- 1≤nums[i]≤50000.\nExplanation\n\nIf nums is [1,2,3,5], then a possible balanced subsequence is [1,2,5],\nthe difference between any two consecutive elements is at most 1.\nSo the maximum value sum of a balanced subsequence of nums is 7, which is \nsum of [1,2,5].\n\n******************************************************************************\nhttps://www.interviewbit.com/problems/maximum-difference-balanced-subsequence/\nint Solution::maxBalancedSubsequenceSum(vector<int> &A) {\n\n\tvector <pair<int,int> > v;\n\tint i,j,n=A.size(),s=0,maxm=0;\n\tif(n==1) return A[0];\n\tfor(i=0;i<n;i++){\n\t\tfor(j=i+1;j<n;j++){\n\t\t\ts=A[i]-A[j]+i-j;\n\t\t\tv.push_back(make_pair(s,i));\n\t\t}\n\t}\n\tsort(v.begin(),v.end());\n\tfor(i=v.size()-1;i>=0;i--){\n\t\tif(maxm<=v[i].first){\n\t\t\tmaxm=v[i].first;\n\t\t\tcontinue;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\ti=n-1;\n\tfor(;i>=0;i--){\n\t\tif(v[i].first==maxm){\n\t\t\treturn A[v[i].second];\n\t\t}\n\t}", "groundtruth": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/26", "content": "\nThe data is as follows:\nnums = [2,1,-1]\nnums = [2,1,-3,2,3,-2,0,-1]\nnums = [2,-1,-1]\nnums = [2,-1,-2,-3,-4]\nnums = [-3,-5,-1,-2,2,-4,-1,-2,-1,-1,3,5,1,1,2,-1,4,2,5]\nnums = [-1,-1,-1,-1]\nnums = [-2,1]\n\n\n# my solution, binary search\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        n = len(nums)\n        if not n:\n            return 0\n        \n        l = -float('inf')\n        r = sum(nums) + 1\n        \n        while l + 1 < r:\n            m = l + (r-l) // 2\n            s, cur = self.findMaxSum(nums, m)\n            if s > m:\n                r = s\n            else:\n                l = s\n        \n        return l\n\n    def findMaxSum(self, nums, m):\n        res = []\n        cur = 0\n        for i in range(len(nums)):\n            while cur > m and res:\n                cur -= res.pop()\n            if cur + nums[i] <= m:\n                cur += nums[i]\n                res.append(nums[i])\n        return cur, res\n\n# BIT\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        n = len(nums)\n        if not n:\n            return 0\n        \n        ans = -float('inf')\n        dp = [0] * (n+1)\n        dp1 = [-inf] * (n+1)\n        dp1[0] = 0\n        \n        for i in range(1, n+1):\n            dp1[i] = max(nums[i-1] + dp1[", "groundtruth": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/27", "content": "\nPlease write your codes in the file \"main.cpp\"\n\nTest your code before submitting it!\n\nIf your code cannot finish within 2.0 seconds, it will receive a score of 0 instead of the expected score.\n\nIf your code exceed the memory usage limit, it will receive a score of 0 instead of the expected score.\n\nExpected Time Complexity: O(nlogn)\nExpected Space Complexity: O(n)\n\nInput Format\nThe input consists of n (0 <= n <= 100,000) positive integers on the first line. The numbers are separated by space characters.\n\nOutput Format\nOutput a single integer which is the maximum possible sum of elements in a balanced subsequence of nums.\n\nSample Input 1\n1 2 3 4\n\nSample Output 1\n10\n\nSample Input 2\n5 2 1 3 5 6 4\n\nSample Output 2\n22\n\"\"\"\nfrom bisect import bisect_left, insort\nfrom itertools import accumulate\nfrom math import inf\n\n\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))\n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1\n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.", "groundtruth": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/28", "content": "Example 1:\n\nInput: nums = [2,4,5,8], k = 2\nOutput: 8\nExplanation: The binary representation of 8 is \"1000\". The binary representations of 2, 4, and 5 are \"10\", \"100\", and \"101\".\nAfter concatenation they are \"10001010010\".\nAfter K-or, \"10001010010\" becomes \"10001010010\". That is the binary representation of 8.\nExample 2:\n\nInput: nums = [10,11,12,14,15,21,24,30], k = 3\nOutput: 61\nExample 3:\n\nInput: nums = [6,4,8,1,2,4,10], k = 1\nOutput: 6\nExample 4:\n\nInput: nums = [3,1,2,4,2,3,1,1,4,4,1], k = 2\nOutput: 13\n\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109\n1 <= k <= sum(1 << bitLen[i] for num in nums)\nNote: bitLen[i] is the number of bits in the binary representation of nums[i] (1 <= bitLen[i] <= 30).\n\nSolution :\n\nclass Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for i in range(max(nums).bit_length()):\n            cnt1 = sum(1<<i & num for num in nums)\n            if cnt1 >= k:\n                ans |= 1 << i\n        return ans\n \nTime: O(N), N is the length of nums\nSpace:O(1)\n\n\n--------------------------------------------------------------------------------------------------------\n\nWe have a list of words, each word can be written as a concatenation of N lowercase letter-strings. For example, if", "groundtruth": "\nclass Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for i in range(max(nums).bit_length()):\n            cnt1 = sum(x >> i & 1 for x in nums)\n            if cnt1 >= k:\n                ans |= 1 << i\n        return ans\n"}
{"task_id": "python/29", "content": "\nIf it can be calculated, return a result as a signed integer. If it is impossible to calculate, return -1.\n\nExample 1\n\nInput\nnums1 = [1, 2, 0, 0]\nnums2 = [1, 3, 5, 7]\nOutput\n7\nExplanation\n\nPossible replacement (underline the zeros with the values of nums2):\n\n    [1, 2, 3, 7]\n    [1, 3, 5, 1]\n\nThe sum of elements in these two arrays will be equal as 1 + 2 + 3 + 7 == 1 + 3 + 5 + 1 = 16\n\nExample 2\n\nInput\nnums1 = [0, 0, 0]\nnums2 = [0, 0, 0]\nOutput\n-1\nExplanation\n\nEither zero1, zero2 or both can be replaced with any non-zero integer.\n\nExample 3\n\nInput\nnums1 = [1, 3, 5, 0, 0, 0]\nnums2 = [1, 3, 5, 1, 3, 1]\nOutput\n-1\nExplanation\n\nBoth zero1 and zero2 can be replaced with zero.\n\nExample 4\n\nInput\nnums1 = [1, 3, 5, 7]\nnums2 = [1, 3, 5, 1, 3, 1]\nOutput\n10\nExplanation\n\nPossible replacement (underline the zeros with the values of nums2):\n\n    [1, 3, 5, 1]\n    [1, 3, 5, 7]\n\nThe sum of elements in these two arrays will be equal as 1 + 3 + 5 + 1 == 1 + 3 + 5 + 7 = 16\n\nLimits\nTime limit (s): 2.0\nMemory limit (MB): 128\nThe length of nums1 is in the range [1, 1000].\n\nThe length of nums2 is in the range [1, ", "groundtruth": "\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n"}
{"task_id": "python/30", "content": "\n*   Correct Output:\n\n    6\n    \n\n*   Explanation of the correct output:\n\nIn this case, we first change both nums1 and nums2 as follows: \n\nnums1: [0,1,0,0] \nnums2: [0,0,0,1] \n\nWe replace 0 with 4 to get this result: \n\nnums1: [4,1,0,0] \nnums2: [0,0,0,4] \n\nThe", "groundtruth": "\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n"}
{"task_id": "python/31", "content": "", "groundtruth": "\nclass Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n        dp1 = dp2 = dp3 = 0\n        for num in nums:\n            dp1, dp2, dp3 = min(dp1, dp2, dp3) + max(0, k - num), dp1, dp2\n        return min(dp1, dp2, dp3)\n"}
{"task_id": "python/32", "content": "Note that an empty line will end the program and that there may be multiple cases of inputs.\n\nExample 1:\nInput: n = 5, edges = [[0,1],[2,1],[2,3],[0,3],[2,4]], coins = [1,2,2,3,4], k = 3\nOutput: 17\nExplanation:\nThe tree structure is shown in the figure. \nThe yellow edges are the edges which you can collect 1 coin. \nThe red edges are the edges which you can collect 2 coins.\nThere are 3 ways to collect 17 coins using the yellow and red edges:\n1. (100 coins) collect all coins except node 2\n2. (90 coins) collect all coins except node 2 and node 3 \n3. (80 coins) collect all coins except node 2 and node 4\nThe coins at node 2 are 2 coins and can be reduced to 1 coin. The coins at node 3 and node 4 can be reduced to 1 coin each. There are 3 ways to collect 17 coins with no edge loss or edge gain.\n \nExample 2:\nInput: n = 7, edges = [[0,1],[2,1],[3,1],[4,1],[5,6],[6,4],[7,4]], coins = [2,3,2,4,1,2,1], k = 5\nOutput: 12\nExplanation:\nThe tree structure is shown in the figure. \nThere are 5 ways to collect 12 coins with no edge loss or edge gain:\n1. (20 coins) collect all coins except node 3\n2. (10 coins) collect all coins except node 1 and node 3 \n3. (10 coins) collect all coins except node 1 and node 4 \n4. (10 coins) collect all coins except node 1 and node 5 \n5. (10 coins) collect all coins except node 1 and node 6\nThe coins at node 3 can be reduced to 3 - 5 = 2 coins. The coins", "groundtruth": "\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i) \n                    if j < 13: \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n"}
{"task_id": "python/33", "content": "\nConstraints:\n\nn == edges.length == coins.length\n1 <= n <= 1000\nedges[i].length == 2\n0 <= ai, bi <= n - 1\nai != bi\nAll the edges (ai, bi) are unique.\n1 <= coins[i] <= 1000\n\nExample 1:\n\n\nInput: edges = [[0,1],[1,2],[1,3],[1,4],[2,5],[3,6],[4,7]], coins = [2,4,1,2,7,8,7], k = 5\nOutput: 16\nExplanation: The optimal way to collect coins is to pick them up from nodes 2, 4, and 7.\nNode 2: For node 2, there are no other nodes in the subtree where you can put the coins.\nYou will get coins[2] - 5 = 1 point.\nNode 4: For node 4, the optimal way to collect the coins is to put them in one of its two subtrees.\nLet the two subtrees be node 5 and node 7.\nFor node 5, there are no other nodes in the subtree where you can put the coins.\nYou will get coins[5] - 5 = 0 point.\nFor node 7, the optimal way to collect the coins is to put them in the subtree of node 6.\nFor node 6, there are no other nodes in the subtree where you can put the coins.\nYou will get coins[6] - 5 = 1 point.\nYou will get a total of 1 + 0 + 1 = 2 points.\nNode 7: For node 7, the optimal way to collect the coins is to put them in one of its two subtrees.\nLet the two subtrees be node 6 and node 7.\nFor node 6, there are no other nodes in the subtree where you can put the coins.\nYou will get coins[6] - 5 = 1 point.\nFor node 7, the optimal way to collect the coins is to put them in one of its two subtrees.\nLet the two subtrees be node 4", "groundtruth": "\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i) \n                    if j < 13: \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n"}
{"task_id": "python/34", "content": "The maximum points is 3 + 2 - 10 + 7 + 5 - 4 + 3 + 4 = 15.\nHere the coins that we have to collect are denoted by x. The coins that we do not collect but can still get because we have collected the ancestor coins are denoted by . In the given tree, we have four choices as follows:\n\nChoose 9 (x) and collect the subtree. The ancestor coins of 9 have already been collected. Thus, the total points we get in this case is coins[9] = 3.\nChoose 14 (x) and collect the subtree. The ancestor coins of 14 have already been collected. Thus, the total points we get in this case is coins[14] = 7.\nChoose 11 (o) and collect the subtree. The ancestor coins of 11 have already been collected. Thus, the total points we get in this case is coins[11] = 5.\nChoose 16 (x) and collect only coins[16] = 4. The ancestor coins of 16 have been collected. Thus, the total points we get in this case is 0. Note that in case (3), we are only able to collect coins[16] = 4. We are unable to collect the rest of the ancestor coins because these coins were given in the previous choices.\nFor each choice, we have a list of four possibilities. Thus, the maximum points we can get in this case is max(3, 0, 0, 0, 7, 0, 0, 0, 5, 0, 0, 0, 4, 0, 0, 0) = 15.\n\nFor this problem, we have chosen to represent a vertex x with coins[x] coins. For each vertex x, we have two possibilities when we choose to collect the ancestor coins of x: either we collect the ancestor coins or we don't collect them. This means, we have four choices, which is 2^2, or 4 choices in total.\n\nWe note, we can use DFS with memoization. Since the tree is undirect", "groundtruth": " class Solution:     def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:         g = [[] for _ in coins]         for x, y in edges:             g[x].append(y)             g[y].append(x)         @cache         def dfs(i: int, j: int, fa: int) -> int:             res1 = (coins[i] >> j) - k             res2 = coins[i] >> (j + 1)             for ch in g[i]:                 if ch != fa:                     res1 += dfs(ch, j, i)                      if j < 13:                          res2 += dfs(ch, j + 1, i)              return max(res1, res2)         return dfs(0, 0, -1) "}
{"task_id": "python/35", "content": "Please keep it in mind that you are expected to complete the code. Some blank spaces left blank. You do not need to use the comments to solve the problem. However, you are allowed to use the comments in your code.\nSubmitting this question will remove it from your submission history.\nSample 1:\n\nInput: nums = [1,2,3,1,2,1]\nOutput: 17\nExplanation: Each subarray is listed with its distinct count:\n[1] = 1\n[1,2] = 2\n[1,2,3] = 3\n[2] = 2\n[2,3] = 2\n[2,3,1] = 3\n[3] = 1\n[3,1] = 2\n[3,1,2] = 2\n[1] = 1\n[1,2] = 2\n[1,2,3] = 3\n[2] = 2\n[2,3] = 2\n[2,3,1] = 3\n[3] = 1\n[3,1] = 2\n[3,1,2] = 2\nTotal distinct count is: 1 + 2 + 3 + 2 + 2 + 3 + 1 + 2 + 3 + 2 + 2 + 3 + 1 + 2 + 3 = 17\n\nSample 2:\n\nInput: nums = [1,2,2,3]\nOutput: 12\nExplanation: Each subarray is listed with its distinct count:\n[1] = 1\n[2] = 2\n[2,2] = 1\n[2,3] = 2\n[3] = 1\nTotal distinct count is: 1 + 2 + 1 + 2 + 1 = 12 \n\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 1000\n\n\n\"\"\"\n\n\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = [0] * (n * 4", "groundtruth": " class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o * 2] + sum[o * 2 + 1]             return res         ans = s = 0         last = {}         for i, x in enumerate(nums, 1):             j = last.get(x, 0)             s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j             ans += s             last[x] = i         return ans % 1_000_000_007 "}
{"task_id": "python/36", "content": "", "groundtruth": " class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o * 2] + sum[o * 2 + 1]             return res         ans = s = 0         last = {}         for i, x in enumerate(nums, 1):             j = last.get(x, 0)             s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j             ans += s             last[x] = i         return ans % 1_000_000_007 "}
{"task_id": "python/37", "content": "\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= nums.length\n\nProblem link: https://leetcode.com/contest/weekly-contest-202/problems/sum-of-distinct-subarray-squares/\n\"\"\"\n\nfrom typing import DefaultDict\nimport heapq\nclass Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        n = len(arr)\n        ans = []\n        todo = []\n\n        def do(o, l, r, add):\n            if o >= n:\n                return\n            ans[o] += add * (r - l + 1)\n            todo[o] += add\n\n        def query_and_add1(o, l, r, L, R):\n            if l > R or r < L:\n                return 0\n            elif L <= l and r <= R:\n                ans[o] += (r - l + 1)\n                todo[o] += 1\n                return ans[o]\n\n            m = (l + r) // 2\n            add = todo[o]\n            if add:\n                do(o * 2, l, m, add)\n                do(o * 2 + 1, m + 1, r, add)\n                todo[o] = 0\n            res = 0\n            if L <= m:\n                res += query_and_add1(o * 2, l, m, L, R)\n            if m < R:\n                res += query_and_add1(o * 2 + 1, m + 1, r, L, R)\n\n            ans[o] = ans[o * 2] + ans[o * 2 + 1]\n            return res\n\n        ans = [0] * (n * 4)\n        todo = [0] * (n * 4)\n\n        # o=1 [l,r] 1 <= l <= r <= n\n        # 把 [L,R] 加一，同时返回加一之前的区间和\n        self.ans", "groundtruth": " class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o * 2] + sum[o * 2 + 1]             return res         ans = s = 0         last = {}         for i, x in enumerate(nums, 1):             j = last.get(x, 0)             s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j             ans += s             last[x] = i         return ans % 1_000_000_007 "}
{"task_id": "python/38", "content": "The minimum changes required to make the string beautiful, assuming no 0's\n'''\n\nclass Solution:\n    def minChanges(self, s: str) -> int:\n        s = s.replace('1', 'A')\n        s = s.replace('0', 'B')\n        s = s.replace('A', '1')\n        s = s.replace('B', '0')\n        return len(s)\n", "groundtruth": " class Solution:     def minChanges(self, s: str) -> int:         cnt = 0         for i in range(0, len(s), 2):             if len(set(s[i:i + 2])) > 1:                 cnt += 1                 print(s)         return cnt "}
{"task_id": "python/39", "content": "\n\nPlease fill in the following incomplete code according to the description. The description is as follows:\nYou are given an integer numRows. Write a function to return the the first numRows of Pascal's triangle.\nThe incomplete code is as follows:\nclass Solution:   def generate(self, numRows: int) -> List[List[int]]:       if numRows <= 0:           return []       res = []       for i in range(numRows):           if i == 0:               res.append([1])               continue           curr_row = [1]               for j in range(1, i):               curr_row.append(res[-1][j] + res[-1][j - 1])               curr_row.append(1)               res.append(curr_row)       return res  \nGive only the completed code. Do not output any additional information.\n\n\nPlease fill in the following incomplete code according to the description. The description is as follows:\nYou are given a list of strings words and a string pattern. A string is said to match the pattern if it matches the entire pattern, as in, all the pattern's letters match some substring in this string.\nReturn an integer array answer, where answer[i] is the number of strings in words that match words[i].\nThe incomplete code is as follows:\nclass Solution:   def numOfStrings(self, words: List[str], pattern: str) -> List[int]:       res = []       # pattern 처리       cnt = collections.Counter(pattern)       psum = 0       for i in range(26):           psum += cnt.get(chr(ord('a') + i), 0)       # words 처리       for s in words:           s = list(s)           cnt = collections.Counter(s)           ssum = 0           for i in range(26):               ssum += cnt.get(chr(ord('a') + i), 0)           if ssum == psum:               res.append(1)           else:               res.append(0)       return res  \nGive only the completed code. Do not output any additional information.\n\n\nPlease fill in the following incomplete code according to the description. The description is as follows:\nYou", "groundtruth": " class Solution:     def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:         f = [0] + [-inf] * target         s = 0         for x in nums:             s = min(s + x, target)             for j in range(s, x - 1, -1):                 # f[j] = max(f[j], f[j - x] + 1)                 if f[j] < f[j - x] + 1:                     f[j] = f[j - x] + 1         return f[-1] if f[-1] > 0 else -1 "}
{"task_id": "python/40", "content": "\n**Example 1:**\n\n```\nInput: m = 5, n = 8, hFences = [3, 6], vFences = [5, 8]\nOutput: 16\nExplanation: One square is of side 2 with the coordinates (1, 1) and (2, 2).\nThis is best possible because it covers the entire area without obstructions.\n\nExample 2:\n\nInput: m = 3, n = 3, hFences = [1, 2], vFences = [1, 2]\nOutput: -1\nExplanation: There is no way to form a square because there will always be an obstructions.\n```\n\n**Example 3:**\n\n```\nInput: m = 4, n = 5, hFences = [1,4], vFences = [3,4]\nOutput: 4\n```\n\n### Constraints:\n\n+ ```m == hFences.length```\n+ ```n == vFences.length```\n+ ```1 <= m, n <= 10^5```\n+ ```1 <= m * n <= 10^5```\n+ ```1 <= hFences[i] < m```\n+ ```1 <= vFences[i] < n```\n+ All values in hFences and vFences are unique.\n\n\n\n## Solutions\n### 1. Math（题目分析）\n\n题目让我们在矩形中盖板子，得到最大的正方形面积。\n\n第一步，确定左上角和右下角的点(m, n)（左下角点为(1, 1)），并且至少保证这个小正方形包含在矩形内：\n![](https://img.halfrost.com/Leetcode/leetcode_464_1.png)\n\n第二步，考虑左侧和右侧边上的板子：\n![](https://img.halfrost.com/", "groundtruth": " class Solution:     def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:         h = self.f(hFences, m)         v = self.f(vFences, n)         ans = max(h & v, default=0)         return ans ** 2 % 1_000_000_007 if ans else -1      def f(self, a: List[int], mx: int) -> Set[int]:         a.extend([1, mx])         a.sort()         return set(y - x for x, y in combinations(a, 2)) "}
{"task_id": "python/41", "content": "\n \n\nConstraints:\n\nm == hFences.length\nn == vFences.length\n1 <= m <= 105\n1 <= n <= 105\n1 <= hFences[i] <= m\n1 <= vFences[i] <= n\nAll horizontal and vertical fences are unique.\nEach value in the fence will be unique too.\n\n \n\nExample 1:\n\n \n\nInput: hFences = [1,2,5,20], vFences = [3,8,12,20], m = 6, n = 10\nOutput: 4\nExplanation:\nAll the horizontal fences are marked in red, and all the vertical fences are marked in blue.\nWe can build the square at (2, 2) with a side length of 2:\n- Square at (2, 2) can be built:\n- 1 <= 2 + 2 = 4 <= 6.\n- 1 <= 2 + 2 = 4 <= 10.\nExample 2:\n\n \n\nInput: hFences = [5,15,15,20,20], vFences = [10,20], m = 7, n = 12\nOutput: 16\nExplanation:\nAll the horizontal fences are marked in red, and all the vertical fences are marked in blue.\nWe can build the square at (0, 8) with a side length of 4:\n- Square at (0, 8) can be built:\n- 5 <= 0 + 4 = 4 <= 7.\n- 10 <= 0 + 4 = 4 <= 12.\nExample 3:\n\n \n\nInput: hFences = [2,2,2], vFences = [2,2,2], m = 6, n = 11\nOutput: 9\n \n\nConstraints:\n\n1 <= hFences.length, vFences.length <= 105\n1 <= m, n <= 107\n1 <= hFences[i], vFences[j] <= min(m, n)\nAll integers in hF", "groundtruth": " class Solution:     def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:         h = self.f(hFences, m)         v = self.f(vFences, n)         ans = max(h & v, default=0)         return ans ** 2 % 1_000_000_007 if ans else -1      def f(self, a: List[int], mx: int) -> Set[int]:         a.extend([1, mx])         a.sort()         return set(y - x for x, y in combinations(a, 2)) "}
{"task_id": "python/42", "content": "If the following code runs correctly, you will get a score of 10. Otherwise, you will get a score of 0.\n# Definition for a Node.\nclass Node:\n    def __init__(self, val=None, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\nYou are given a reference of a node in a connected undirected graph. Return the degree of the node.\nThe degree of a node is defined as the number of nodes that are connected to the node. A node is connected to itself.\nWe define the degree of a null node to be 0.\nYou must write an algorithm that runs in O(1) time.\nExample 1:\nInput: node = \"a\"\nOutput: 3\nExplanation: The node has 3 adjacent nodes:\n- \"e\" with an edge of weight 3.\n- \"c\" with an edge of weight 1.\n- \"b\" with an edge of weight 4.\nExample 2:\nInput: node = \"b\"\nOutput: 4\nExplanation: The node has 4 adjacent nodes:\n- \"e\" with an edge of weight 3.\n- \"c\" with an edge of weight 1.\n- \"b\" with an edge of weight 4.\n- \"d\" with an edge of weight 2.\nExample 3:\nInput: node = \"d\"\nOutput: 2\nExplanation: The node has 2 adjacent nodes:\n- \"a\" with an edge of weight 2.\n- \"e\" with an edge of weight 2.\nExplanation:\nThe degree of node \"a\" is 3 because it has 3 adjacent nodes:\n- \"e\" with an edge of weight 3.\n- \"c\" with an edge of weight 1.\n- \"b\" with an edge of weight 4.\nThe degree of node \"b\" is 4 because it has 4 adjacent nodes:\n- \"e\" with an edge of weight 3.\n- \"c\" with an edge of weight 1.\n- \"b\" with an edge of weight 4.\n- \"d\" with an edge of weight 2.\nThe degree of node \"", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)          for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))         return ans if ans < inf else -1 "}
{"task_id": "python/43", "content": " \n### Sample input\n    1\n    aaba\n    ab\n    [\"a\",\"a\",\"b\"]\n    [\"b\",\"a\",\"a\"]\n    [4,2,2]\n\n### Sample output\n    2\n\n### Hint\nUse Dijkstra's algorithm on the adjacency matrix.\n\n###### Note\nIf you don't know about Dijkstra's algorithm, you can go to the [video explanation](https://youtu.be/9UhDH4PpDVU).\n\n### Code\n- Dijkstra's Algorithm (Python 3)\n```\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        original = dict(zip(original, cost))\n        dis = [[inf] * 26 for _ in range(26)]\n        for i in range(26):\n            dis[i][i] = 0\n        for x, y, c in zip(original, changed, cost):\n            x = ord(x) - ord('a')\n            y = ord(y) - ord('a')\n            dis[x][y] = c\n        for k in range(26):\n            for i in range(26):\n                for j in range(26):\n                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n        ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))\n        return ans if ans < inf else -1\n\n# @lc code=end\n```\n- Using Union Find (Python 3)\n```\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        if original == [''] * len(cost) and changed == [''] * len(cost):\n            return 0\n        d = dict(zip(original, changed))\n        # print(d)\n        parent", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)          for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))         return ans if ans < inf else -1 "}
{"task_id": "python/44", "content": "\nNote: inf is 2", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)         for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))         return ans if ans < inf else -1 "}
{"task_id": "python/45", "content": "\nNote: In the above description, we represent the cost as an integer cost, however, the", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = min(dis[x][y], c)             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                      continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 "}
{"task_id": "python/46", "content": "\nHere is an example of the input (as a string) and the output.\nFor the input:\n\n'3\nabcd\ndbca\n[\"abcd\",\"cdab\",\"cbad\",\"dacb\"]\n[\"badc\",\"dbca\",\"badc\",\"dacb\"]\n[3,4,4,2]\n'.\nYour program should output the following:\n\n6\n\nNote: \nThe code will be judged both from performance and readability. The input will always be valid.\n*/\nclass Solution {\npublic:\n    map<string, int> mp;\n    int dfs(string& source, int i, int cost, string target) {\n        if (i == source.size()) {\n            return cost;\n        }\n        //cout << source.substr(i) << endl;\n        if (source.substr(i) == target) {\n            return cost;\n        }\n        if (mp.find(source.substr(i)) != mp.end()) {\n            if (mp[source.substr(i)] == cost) {\n                return cost;\n            }\n            else {\n                return -1;\n            }\n        }\n        mp[source.substr(i)] = cost;\n        int mini = INT_MAX;\n        for (int j = 0; j < target.size(); j++) {\n            if (source[i] == target[j]) {\n                continue;\n            }\n            int c = dfs(source, i + 1, cost, target);\n            if (c == -1) {\n                continue;\n            }\n            mini = min(mini, c + 1);\n        }\n        return mini;\n    }\n    int minimumCost(string source, string target, vector<string>& origina, vector<string>& changed, vector<int>& cost) {\n        string cur;\n        int mini = INT_MAX;\n        for (int i = 0; i < origina.size(); i++) {\n            for (int j = 0; j < changed.size(); j++) {\n                if (origina[i] == target && changed[j] == source) {\n                    return 0;\n                }\n                if (origina[i]", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = min(dis[x][y], c)             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                       continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 "}
{"task_id": "python/47", "content": "\nNote:\n\nn == source.length == target.length\n1 <= n <= 105\n1 <= cost.length <= 105\nn == original.length == changed.length\n1 <= cost.length <= 105\nAll strings in the input consist of lowercase English letters.\nThe pairs (source[i], target[i]) are all distinct.\nIt is guaranteed that source is convertible to target with any number of operations.\n\n\nExample 1:\n\nInput: source = \"abc\", target = \"bca\", original = [\"ab\",\"bc\",\"ac\"], changed = [\"bc\",\"ca\",\"", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = min(dis[x][y], c)             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                       continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 "}
{"task_id": "python/48", "content": "\n### Solution\n\n```python\nDIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n\n\nif __name__ == '__main__':\n    grid = [[0, 1], [1, 1]]\n    obj = neighborSum(grid)\n    print(obj.diagonalSum(1))\n    print(obj.diagonalSum(0))\n```\n\n### [219. Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/)\n\nGiven an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.\n\n### Solution\n\n```python\nfrom collections import defaultdict\n\nclass Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        seen = defaultdict(list)\n        for i, num in enumerate(nums):\n            if i - seen[num][-1] <= k:\n                return True\n            seen[num].append(i)\n        return False\n```\n\n\n### [220. Contains Duplicate III](https://leetcode.com/problem", "groundtruth": "\nDIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n  "}
{"task_id": "python/49", "content": "\nPlease solve the problem as mentioned above. Otherwise, you will not be eligible for receiving the reimbursement from Uber. \nFor your information, this problem has been posted as a recruitment question by Uber. We have the rights to post this problem and solution (with minor modifications) to other platforms.\n\nInput Format\nThere are two class constructor and two member functions\n\nClass Constructor: NeighborSum(grid)\nParameter 1: grid - a 2D list/array\nOutput: None\nNote: There will be no side effects for any variables\nMember Function: adjacentSum(value)\nParameter 1: value - an integer\nOutput: An integer representing the sum of the adjacent neighbors of the value.\nMember Function: diagonalSum(value)\nParameter 1: value - an integer\nOutput: An integer representing the sum of the diagonal neighbors of the value.\nConstraints:\n1 <= n <= 250\n\n0 <= grid[i][j] <= 2500\n0 <= value <= 2500\n\nSample Input:\ngrid = [\n         [0,1,0],\n         [0,0,1],\n         [1,1,1]\n       ]\nvalue = 2\n\nSample Output:\n2\n2\n\nExplanation of Sample Input:\nAs we can see that value is 2. It has 2 diagonal neighbors and 2 adjacent neighbors.\n\n\nCODE:-\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n    \n    def adjacentSum(self, value: int) -> int:\n        return sum(self.s[value])\n    def diagonalSum(self, value: int) ->", "groundtruth": "\nDIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n  "}
{"task_id": "python/50", "content": "\nWe are not looking for correctness, only for the completed code.\n\nAnalyze the following incomplete code, and add some code to it in order for it to become correct. The description is as follows:\n\nThere are n roads numbered from 0 to n - 1, and an array cities of length n describing the types of cities where city i is either a start or end city or even a normal city (not a start city nor a end city). For instance, cities = [0, 1, 2, 1] means:\n\nCity 0 is a start city\nCities 1, 2 are normal cities\nCity 3 is an end city\nThe length of a road is the same for all roads. If city i is a start city, the distance from city i to all normal cities is the same. If city i is an end city, the distance from all normal cities to city i is the same. If city i is a normal city, the distance from city i to all other cities is the same.\n\nHere, the distance between two cities is the minimum number of roads to pass through between the two cities. It can be multiple roads. For example, a distance between city 0 and city 2 is 2 since 0 → 1 → 2.\n\nGiven the city types array, your task is to calculate, for each city, the number of roads to the nearest start or end city.\n\nNote: If a road is present between city i and city j, there will also be a road present between city j and city i.\n\nThe incomplete code is as follows:\n\nclass Solution:\n    def shortestDistance(self, cities: List[int]) -> int:\n        ___\n        \nFill in the blank using the following description. The description is as follows:\n\nYou are given an integer n and a 0-indexed 2D integer array grid of side-length n. The cells of grid are either open or blocked.\n\nA robot is initially at cell (0, 0) in the top-left corner and wants to reach cell (n - 1, n - 1) in the bottom-right corner. The robot can move in four directions: up, down, left, and right. The robot cannot step into blocked cells.\n\nCalculate the minimum number of times the robot must be moved in", "groundtruth": "\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n "}
{"task_id": "python/51", "content": "\nThe format of the return value is an array where the ith element is the length of the shortest path from city 0 to city n - 1 after processing the first i + 1 queries.\n\n \n\nExample 1:\n\nInput: n = 7, queries = [[0,1],[1,2],[2,3],[2,3],[0,1],[0,1],[2,3]]\nOutput: [6,5,7,9,6,5,7]\nExplanation: The shortest path length for the first 7 queries are as follows:\n[0,1] : The shortest path is [0,1] of length 6.\n[1,2] : The shortest path is [0,1,2] of length 5.\n[2,3] : The shortest path is [0,1,2,3] of length 7.\n[2,3] : The shortest path is [0,1,2,3] of length 7.\n[0,1] : The shortest path is [0,1,2,3,4] of length 6.\n[0,1] : The shortest path is [0,1,2,3,4] of length 6.\n[2,3] : The shortest path is [0,1,2,3,4,5] of length 7.\nNote that [2,3,4,5] is a shorter path.\nExample 2:\n\nInput: n = 13, queries = [[10,12],[11,12],[5,12],[8,12]]\nOutput: [10,11,12,13]\nExplanation: The shortest path length for the first 4 queries are as follows:\n[10,12] : The shortest path is [10,12] of length 10.\n[11,12] : The shortest path is [11,12] of length 11.\n[5,12] : The shortest path is [5,6,7,8,9,10,11,12] of length 13.\n[8,12] : The shortest path", "groundtruth": "\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/52", "content": "The output must be one line, containing n space-separated integers. You can print each integer in a separate line at the end of your program.\n\n# Definition for Fenwick Tree.\n\n\nclass FenwickTree:\n    def __init__(self, n: int) -> None:\n        self.n = n\n        self.ftree = [0] * (n + 1)\n\n    def ____(self, index: int, value: int) -> None:\n        pass\n\n    def query(self, index: int) -> int:\n        pass\n\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i", "groundtruth": "\nfrom sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/53", "content": "\nExplanation:\n\nThe alternating groups of 1 are [1], [2], [4], [7] and [1, 4, 7].\nThe alternating groups of 2 are [3], [5] and [6, 8].\nThe alternating groups of 3 are [9].\nThe alternating groups of 4 are [1, 4, 7].\nThe alternating groups of 5 are [5].\nThe alternating groups of 6 are [6, 8].\nThe alternating groups of 7 are [1, 4, 7].\nThe alternating groups of 8 are [6, 8].\nThe alternating groups of 9 are [9].\n```python\nclass FenwickTree(object):\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0]*(n+1)\n\n    def add(self, x, val):\n        while x < self.n:\n            self.bit[x] += val\n            x += (x & -x)\n\n    def query(self, x):\n        res = 0\n        while x:\n            res += self.bit[x]\n            x -= (x & -x)\n        return res\n\nclass Solution(object):\n    def numberOfAlternatingGroups(self, a, queries):\n        def get_type(x):\n            if x%2 == 0:\n                return 1\n            return 2\n\n        res, ans = [0]*len(a), []\n        n = len(a)\n        tree = FenwickTree(n)\n        for i in range(n):\n            x = get_type(i)\n            res[i] = tree.query(x-1)\n            tree.add(x, 1)\n        for i in range(len(queries)):\n            _type, index, color = queries[i]\n            if _type == 1:\n                x = get_type(index)\n                ans.append(tree.query(x-1) - tree.query(x) - res[index])\n            else:\n                tree.add(get_type(index), 0)\n                res[", "groundtruth": "\nfrom sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/54", "content": "\nThe expected time complexity is O(n logn) and the expected space complexity is O(n) where n is the length of nums.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: false\nExplanation: No matter which numbers Alice chooses, her sum of choices cannot exceed Bob's sum of choices.\nFor example, if Alice chooses {1, 2} and Bob chooses {3}, then the sum of Alice's choice is 3, and the sum of Bob's choice is 3. Thus the total sum is 6, which is not strictly greater than 3.\nExample 2:\n\nInput: nums = [1,2,3,-1,-2,-3,7]\nOutput: true\nExplanation: No matter which numbers Alice chooses, her sum of choices will always be strictly greater than Bob's sum of choices.\nFor example, if Alice chooses {1, 2, 3} and Bob chooses {-1, -2, -3, 7}, then the sum of Alice's choices is 6, and the sum of Bob's choices is 2. Thus the total sum is 8, which is strictly greater than 2.\n \n\nConstraints:\n\n1 <= nums.length <= 105\n-104 <= nums[i] <= 104\n \n\n", "groundtruth": "\nclass Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        single=0\ndouble=0\nfor it in nums:\nif it>=10: \ndouble=double+it \nelse:\nsingle=single+it  \n        \nreturn single !=double\n "}
{"task_id": "python/55", "content": "\nThe example 1 is obvious: \n\ninput: s = \"100110\"\noutput: 4\nExplanation: There are 4 substrings with dominant ones: [100, 0110, 010, 00110].\nThe substring \"110\" has 0 zeroes, which does not satisfy the condition.\nThe example 2 is obvious:\n\ninput: s = \"111000\"\noutput: 3\nExplanation: There are 3 substrings with dominant ones: [111, 000, 111000].\nThe substring \"11000\" has 2 zeroes, which does not satisfy the condition.\nExample 3:\n\nInput: s = \"100110011001100010\"\nOutput: 33\nExplanation: There are 33 substrings with dominant ones.", "groundtruth": "\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n    "}
{"task_id": "python/56", "content": "\n\nclass Solution:\n    def canReachCorner(self, x: int, y: int, circles: List[List[int]]) -> bool:\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            if in_circle(circles[i][0], circles[i][1], circles[i][2], x, y):\n                return False\n            if circles[i][0] <= x and abs(circles[i][1] - y) <= circles[i][2] and circles[i][0] <= y and circles[i][1] <= circles[i][2]:\n                vis[i] = True\n                if circles[i][0] == 0 or circles[i][1] == 0 or circles[i][0] == x or circles[i][1] == y:\n                    return True\n                if dfs(i - 1):\n                    return True\n                if dfs(i + 1):\n                    return True\n                return dfs(i - x)\n            elif circles[i][0] >= x and abs(circles[i][1] - y) <= circles[i][2]:\n                return dfs(i - 1)\n            else:\n                return dfs(i + 1)\n\n        for i, (x, y, r) in enumerate(circles):\n            if not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n\n\n# Submission details:\n# Runtime: 104 ms\n# Memory Usage: 15.7 MB\n\n# Runtime complexity: O(k)\n# Space complexity:O(1)\n\n# Time complexity: O(k)\n", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and \\\n                   (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or \\\n               in_circle(x, y, r, X, Y) or \\\n               not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/57", "content": "Note: If any part of the circle lies outside the rectangle, your code may fail to detect a possible valid solution.\n\n\n\n案例分析：\n首先从图中找出 起点与终点 的坐标\nx = x_left, \ny = y_top\n\n然后遍历所有圆，如果当前圆的圆心在起点和终点的四个某个点上，则把这个圆的编号标为1\n然后用递归找到所有圆中被 1 标记的圆的相邻圆，用 1 把这些相邻圆标上，然后这些圆又有相邻圆，则递归标上。以此类推，如果能够标到所有的圆的话，则存在一条可行路径\n\n整个流程：\n    标记所有在起点与终点的所有圆，为 1\n    \n    while 能标到其它圆为1 \n        标记\n    \n    if 所有圆都被标记\n        存在一条可行路径\n        \n\n\n\n\n```\nclass Solution:\n    def canReachCorner(self, x: int, y: int, circles: List[List[int]]) -> bool:\n        vis = [False] * len(circles)\n\n        def dfs(i: int) -> bool:\n            if vis[i]:\n                return True\n\n            if circles[i][0] == x or circles[i][0] == y or circles[i][1] == x or circles[i][1] == y:\n                if dfs(i-1) or dfs(i+1):\n                    vis[i] = True\n                    return True\n            return False\n\n        if dfs(0):\n            for i in range", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and \\\n                   (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or \\\n               in_circle(x, y, r, X, Y) or \\\n               not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/58", "content": "\nIn the incomplete code, the missing functions dfs and findChampion are described below:\ndfs\nReturn the number of teams from which team start is directly or indirectly strong.\n\nfindChampion\nReturn the team that is the champion if there is a unique champion, otherwise, return -1.\n\nIf team a is strong", "groundtruth": "class Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/59", "content": "Example 1:\nInput: n = 6, edges = [[0,3],[1,3],[2,3],[4,5],[4,3]]\nOutput: 3\nExplanation:\nHere, for each team we have the teams that it can defeat and the teams that it can be defeated by.\nTeams 0,1,2 have nobody that can defeat it while it can defeat 4,5.\nTeams 3,4,5 have nobody that can defeat it while it can defeat 0,1,2.\nTeam 3 will be the champion because it has no enemy and every other team is its enemy.\n\nExample 2:\nInput: n = 1, edges = []\nOutput: 0\nExplanation: There is only one team and no other team can defeat it, so the team 0 will be the champion.\n\nExample 3:\nInput: n = 2, edges = [[0,1]]\nOutput: 1\nExplanation: Team 1 can't be defeated and will be the champion.\n\nExample 4:\nInput: n = 3, edges = [[0,1]]\nOutput: -1\nExplanation: Team 0 can't be defeated so team 1 has to defeat team 0.\nTeam 1 can't be defeated and team 0 will be the champion.\nThus, we return -1.\n\nConstraints:\n1 <= n <= 2 * 10^4\n0 <= m <= 2 * 10^4\nedges[i].length == 2\n0 <= ui, vi <= n - 1\nui != vi\n\nHint #1  \nWe can solve this problem using DFS (depth-first search). It is also helpful to maintain a graph for the given directed graph. Then start DFS from one of the vertices and return the first encountered leaf node.\n\nHint #2  \nThere are n teams in a tournament. There is no way to choose a champion that is not in the tournament. So, there has to be a champion in the tournament.\n'''\n\n\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        graph = [[] for _ in range(n)]\n        for v1,", "groundtruth": "class Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/60", "content": "\nFor the first test case, there is one tree with 8 nodes and 7 edges. The root of this tree is node 0, and there are 4 leaves: nodes 1, 2, 3, and 7. The second test case has a tree with 7 nodes and 6 edges. All of the nodes are 0-indexed.\n\n \n\nExample 1:\n\n\n\nInput: edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], values = [2,4,-3,3,-2,2]\nOutput: 6\nExplanation: The above figure represents the given tree and the operation sequence chosen.\nThe nodes visited in this sequence are shown with their new values below.\n- Operation 1: Take the node with value 4. New value of node 1: 4 + (-3) = 1.\n- Operation 2: Take the node with value 3. New value of node 2: 4 + (-2) = 2.\n- Operation 3: Take the node with value 2. New value of node 3: 3 + (-2) = 1.\n- Operation 4: Take the node with value 3. New value of node 4: 4 + (-3) = 1.\n- Operation 5: Take the node with value 4. New value of node 5: 4 + (-3) = 1.\n- Operation 6: Take the node with value 2. New value of node 6: 2 + (-2) = 0.\nThis sequence of operations maximizes the path from root to leaf node 6, so the answer is 6.\nExample 2:\n\n\n\nInput: edges = [[0,1],[0,2],[1,3],[1,4],[2,5]], values = [1,3,-5,3,-3]\nOutput: 10\nExplanation: The above figure represents the given tree and the operation sequence chosen.\nThe nodes visited in this sequence are shown with their new values below.\n- Operation 1: Take the node with value 1. New value of node 2: 3 + (-5) = -2.\n- Operation 2: Take the node with value ", "groundtruth": "class Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v != p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp1 + nums[u], dp0)\n            \n        return dfs(0)[1]\n"}
{"task_id": "python/61", "content": "\nNote: You do not have access to any", "groundtruth": "class Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v != p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp1 + nums[u], dp0)\n            \n        return dfs(0)[1]\n"}
{"task_id": "python/62", "content": "The value of k is equal to or greater than 1.\n1 ≤ n ≤ 2 × 10^5\n0 ≤ nums[i] ≤ 10^9\n\nSample Input 1\nnums = [3,1,5,2,1,7,4]\nSample Output 1\n9\nSample Explanation 1\nThe longest balanced subsequence is [5,7], where the longest balanced subsequence of subsequence [3,5,7] is [5,7], and the longest balanced subsequence of subsequence [5,7] is [7].\n\nSample Input 2\nnums = [3,1,5,2,1,7,4,2]\nSample Output 2\n13\nSample Explanation 2\nThe longest balanced subsequence is [5,7,4], where the longest balanced subsequence of subsequence [3,5,7,4] is [5,7,4], and the longest balanced subsequence of subsequence [5,7,4] is [5,7,4].\n\"\"\"\n\n\n\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1  \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))  \n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        self.tree[i] = val\n        i += 1\n        while i < len(self.tree):\n            self.tree[i] = max(val, self.tree[i])\n            i += i & (-i)\n\n    def pre_max(self, i: int) -> int:\n       ", "groundtruth": "class Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/63", "content": "\nPlease submit the code before 12:00 on June 20, 2021 (GMT+9)\nTest data for judges:\n\nIn a certain K-or operation, a bit position is 1 only when k or more numbers in nums have 1 in this position. Now the K-or operation is extended with more operations. Given three integers a, b and k, the first K-or operation is a & b, followed by K-or operations with a, b and b & (a | b) repeatedly. Return the result of these operations.\nIt's guaranteed that a, b and k are positive integers.\n\n\nInput Format\nInput will consist of a single line containing three space separated integers a, b and k.\n\n\nOutput Format\nReturn the result of the operations.\n\n\nConstraints\n1 <= a, b, k <= 10^9\n\nSample Input 1\n10 10 1\n\nSample Output 1\n20\n\nExplanation 1\nFirst K-or: 10 & 10\nSecond K-or: 20 | 10\nThird K-or: 10 | 20\nFourth K-or: 20 & (10 | 20)\nFifth K-or: 10 | (20 & (10 | 20))\nIn the fourth operation, only nums 10 and 20 have a 1 in the first position, so the first position in the result is 1.\nIn the fifth operation, only nums 10 and 20 have a 1 in the first position, so the first position in the result is 1.\nIn the sixth operation, only nums 10 and 10 have a 1 in the first position, so the first position in the result is 1.\nIn the seventh operation, only nums 10 and 10 have a 1 in the first position, so the first position in the result is 1.\nIn the eighth operation, only nums 10 and 10 have a 1 in the first position, so the first position in the result is 1.\nIn the ninth operation, only nums 10 and 10 have a", "groundtruth": "class Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for i in range(max(nums).bit_length()):\n            cnt1 = sum(x >> i & 1 for x in nums)\n            if cnt1 >= k:\n                ans |= 1 << i\n        return ans\n"}
{"task_id": "python/64", "content": "\n \n\nNote:\n\nnums1 and nums2 are 0-indexed integer arrays of length 1 to 10^5.\nZeroes in the two arrays can be at different positions.\nIt is guaranteed that at least one of nums1 and nums2 has all zeros.\nSum of elements in each array does not exceed 10^4.\n\n\n\n## solution\n\n```python\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n        \n        diff = abs(sum1-sum2)\n        \n        if diff % zero2 != 0 or diff / zero2 == 0:\n            return -1\n        \n        val = diff // zero2\n        if sum1 > sum2:\n            nums1 = list(map(lambda x: x+val if x == 0 else x, nums1))\n        else:\n            nums2 = list(map(lambda x: x+val if x == 0 else x, nums2))\n\n        new_sum1 = sum(nums1)\n        new_sum2 = sum(nums2)\n        \n        return (new_sum1 + new_sum2) // 2\n\n```\n\n### comment\n\ndiff: 两个数的差异\nzero2: 差的赋值", "groundtruth": "class Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n\n"}
{"task_id": "python/65", "content": "\nThe code will be evaluated on the following test case:\n\n-- Example 1\n  Input: nums = [2,1,6,5], k = 4\n  Output: 3\n  Explanation:\n    Increment operations allowed: 2 -> 3, 6 -> 7 and 5 -> 6\n    This results in the array [3, 3, 7, 6].\n    The array is beautiful because the maximum element is 7 ≥ 4.\n\n-- Example 2\n  Input: nums = [1,2,3,4], k = 5\n  Output: 0\n  Explanation: The array is already beautiful.\n\n-- Example 3\n  Input: nums = [1,2,3], k = 4\n  Output: 1\n  Explanation: Increment the last element by 1 and the array is [1,2,4]. This makes the array beautiful.\n\n-- Example 4\n  Input: nums = [1,2,3,4,5], k = 5\n  Output: 0\n  Explanation: The array is already beautiful.\n\"\"\"\n#1\nclass Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n        length=len(nums)\n        for i in range(length):\n            nums[i]+=k\n        nums.sort()\n        count = 0\n        for i in range(length):\n            if(nums[i]>k):\n                break\n            count += 1\n        return count\n\n\n\nclass Solution(object):\n    def minIncrementOperations(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        count = 0\n        for num in nums:\n            if num > k:\n                count += 1\n                break\n        else:\n            count = len(nums)\n        return count\n\nclass Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n", "groundtruth": "class Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n        dp1 = dp2 = dp3 = 0\n        for num in nums:\n            dp1, dp2, dp3 = min(dp1, dp2, dp3) + max(0, k - num), dp1, dp2\n        return min(dp1, dp2, dp3)\n"}
{"task_id": "python/66", "content": "The code runs on Python 3.6.\nThe given codes are guaranteed to be lexicographically correct.\nPlease do not use global variables.\nPlease do not change the function signature.\n\n\nExample 1:\n\nInput: edges = [[0,1],[0,2]], coins = [3,2], k = 2\nOutput: 7\nExplanation: The tree is shown above. There are 3 nodes in total. \nFirst, collect coin 3 on root 0 and the coins value of subtree 0 will be floor(2/2) = 1.\nThen, collect coin 2 on root 0 and the coins value of subtree 0 will be floor(1/2) = 0.\nSo the final coins value of root 0 is 3 + 0 = 3.\n\nExample 2:\n\nInput: edges = [[0,1],[1,2],[2,3],[1,4]], coins = [5,3,1,4], k = 2\nOutput: 9\nExplanation: The tree is shown above.\nCollect coin 5 from node 0, and the coins value of subtree 0 will be floor(3/2) = 1.\nCollect coin 3 from node 0, and the coins value of subtree 0 will be floor(1/2) = 0.\nSo the final coins value of node 0 is 5 + 0 = 5.\nCollect coin 1 from node 1, and the coins value of subtree 1 will be floor(4/2) = 2.\nCollect coin 4 from node 1, and the coins value of subtree 1 will be floor(2/2) = 1.\nSo the final coins value of node 1 is 1 + 2 = 3.\nThe final result is 5 + 3 = 8.\n\nExample 3:\n\nInput: edges = [[0,1],[1,2],[1,3],[1,4],[2,5],[2,6],[3,7],[4,8],[5,9],[6,10],[7,11]], coins = [10,2,1,8,6,3,10,5", "groundtruth": "class Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i) \n                    if j < 13: \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n"}
{"task_id": "python/67", "content": "\nLimits\nTime limit: 20 seconds per test set.\nMemory limit: 1GB.\n1 ≤ T ≤ 100.\n1 ≤ nums.length ≤ 1000.\n", "groundtruth": "\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = [0] * (n * 4)\n        todo = [0] * (n * 4)\n\n        def do(o: int, l: int, r: int, add: int) -> None:\n            sum[o] += add * (r - l + 1)\n            todo[o] += add\n\n        # o=1  [l,r] 1<=l<=r<=n\n        # 把 [L,R] 加一，同时返回加一之前的区间和\n        def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:\n            if L <= l and r <= R:\n                res = sum[o]\n                do(o, l, r, 1)\n                return res\n\n            m = (l + r) // 2\n            add = todo[o]\n            if add:\n                do(o * 2, l, m, add)\n                do(o * 2 + 1, m + 1, r, add)\n                todo[o] = 0\n\n            res = 0\n            if L <= m: res += query_and_add1(o * 2, l, m, L, R)\n            if m < R:  res += query_and_add1(o * 2 + 1, m + 1, r, L, R)\n            sum[o] = sum[o * 2] + sum[o * 2 + 1]\n            return res\n\n        ans = s = 0\n        last = {}\n        for i, x in enumerate(nums, 1):\n            j = last.get(x, 0)\n            s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j\n            ans += s\n            last[x] = i\n        return ans % 1_000_000_007\n"}
{"task_id": "python/68", "content": "\nExplanation:\nThe distinct count of nums[0..4] is 3 as there are 3 unique values in [1, 2, 3].\nThe distinct count of nums[0..0] is 1 as there is only 1 unique value in [3].\nThe distinct count of nums[0..4] is 2 as there are 2 unique values in [1, 3].\nThe distinct count of nums[3..4] is 1 as there is only 1 unique value in [2].\nThe distinct count of nums[0..4] is 1 as there is only 1 unique value in [3].\nThe distinct count of nums[1..4] is 3 as there are 3 unique values in [2, 3, 4].\nThe distinct count of nums[2..4] is 2 as there are 2 unique values in [3, 4].\nThe distinct count of nums[0..4] is 3 as there are 3 unique values in [1, 2, 4].\nThe distinct count of nums[0..1] is 2 as there are 2 unique values in [1, 2].\nThe distinct count of nums[2..3] is 1 as there is only 1 unique value in [3].\nThe distinct count of nums[0..2] is 3 as there are 3 unique values in [1, 2, 3].\nThe distinct count of nums[0..3] is 3 as there are 3 unique values in [1, 2, 4].\nThe distinct count of nums[1..3] is 2 as there are 2 unique values in [3, 4].\nThe distinct count of nums[2..3] is 1 as there is only 1 unique value in [4].\nThe distinct count of nums[0..4] is 2 as there are 2 unique values in [1, 4].\nThe distinct count of nums[3..4] is 1 as there is only 1 unique value in [3].\nThe distinct count of nums[0..4] is 3 as there are 3 unique values in [1, 3, 4].\nThe distinct count of nums[", "groundtruth": "\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = [0] * (n * 4)\n        todo = [0] * (n * 4)\n\n        def do(o: int, l: int, r: int, add: int) -> None:\n            sum[o] += add * (r - l + 1)\n            todo[o] += add\n\n        # o=1  [l,r] 1<=l<=r<=n\n        # 把 [L,R] 加一，同时返回加一之前的区间和\n        def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:\n            if L <= l and r <= R:\n                res = sum[o]\n                do(o, l, r, 1)\n                return res\n\n            m = (l + r) // 2\n            add = todo[o]\n            if add:\n                do(o * 2, l, m, add)\n                do(o * 2 + 1, m + 1, r, add)\n                todo[o] = 0\n\n            res = 0\n            if L <= m: res += query_and_add1(o * 2, l, m, L, R)\n            if m < R:  res += query_and_add1(o * 2 + 1, m + 1, r, L, R)\n            sum[o] = sum[o * 2] + sum[o * 2 + 1]\n            return res\n\n        ans = s = 0\n        last = {}\n        for i, x in enumerate(nums, 1):\n            j = last.get(x, 0)\n            s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j\n            ans += s\n            last[x] = i\n        return ans % 1_000_000_007\n"}
{"task_id": "python/69", "content": "\nExample 1:\n\nInput: s = \"00110\"\nOutput: 1\nExplanation: Update the 1 in the third position to 0 so that s becomes \"00010\". It can be shown that it is not possible to make s beautiful with less than 1 change.\n\nExample 2:\n\nInput: s = \"10\"\nOutput: 0\nExplanation: There is no need to change s because it is already beautiful.\n\nExample 3:\n\nInput: s = \"1110\"\nOutput: 1\nExplanation: Update the 0 in the third position to 1 so that s becomes \"1111\". It can be shown that it is not possible to make s beautiful with less than 1 change.\n\nConstraints:\n\n1 <= s.length <= 105\ns.length is even.\ns[i] is either '0' or '1'.\n\n\"\"\"\n\n# 剪枝版本\nclass Solution:\n    def minChanges(self, s: str) -> int:\n        n = len(s)\n        ans = 0\n        for i in range(n):\n            if s[i] == '1':\n                ans += 1\n        if ans % 2:\n            return -1\n        ans //= 2\n        while True:\n            # 对任意两个1相邻进行操作\n            # 若不满足，则说明操作完之后都满足\n            flag = False\n            for i in range(1, n - 1):\n                if s[i] == '1' and s[i - 1] == '1':\n                    if ans > 0:\n                        s = s[:i - 1] + '0' + s[i:]\n                        ans -= 1\n                        flag = True\n                        continue\n                    else:\n                        break\n            if flag or not s:\n                return ans\n            else:\n                return -1\n\n\n\"\"\"\n递归版本\n分别对每一种可能进行枚举，时间", "groundtruth": "\nclass Solution:\n    def minChanges(self, s: str) -> int:\n        cnt = 0\n        for i in range(0, len(s), 2):\n            if len(set(s[i:i + 2])) > 1:\n                cnt += 1\n                \n        print(s)\n        return cnt\n"}
{"task_id": "python/70", "content": "\nYou can use the following code as a start:\n\nclass Solution:\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        if ___:\n            return -1\n        ___\n        return ___\n\nExamples\nInput: nums = [5, 5, 1, 4, 3], target = 3\nOutput: 3\nExplanation: The subsequence [5, 5, 1] sums up to 3.\n\nInput: nums = [5, 5, 0, 3, 4, 5], target = 8\nOutput: 2\nExplanation: The subsequence [5, 3] sums up to 8.\n\"\"\"\n\nclass Solution:\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        if target <= 0:\n            return -1\n        for i, num in enumerate(nums):\n            nums[i] = (0, num)\n        nums.sort(key = lambda x : x[1])\n        nums = [(x[1]-x[0]) for x in nums]\n        print(nums)\n        i = 0\n        while i < len(nums):\n            if nums[i] <= target:\n                break\n            i += 1\n        if i == len(nums):\n            return -1\n        res = 0\n        _tmp = 0\n        while target > 0 and i < len(nums):\n            _tmp += nums[i]\n            if _tmp > target:\n                _tmp = 0\n                i -= 1\n                res += 1\n            else:\n                i += 1\n                res += 1\n        return res\n\ndef main():\n    sol = Solution()\n    param = [5, 5, 1, 4, 3]\n    param2 = [5, 5, 0, 3, 4, 5]\n    # param = [5,5,5,5,5,5,5,5]\n    param3 = 1\n    param2 =", "groundtruth": "\nclass Solution:\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        f = [0] + [-inf] * target\n        s = 0\n        for x in nums:\n            s = min(s + x, target)\n            for j in range(s, x - 1, -1):\n                # f[j] = max(f[j], f[j - x] + 1)\n                if f[j] < f[j - x] + 1:\n                    f[j] = f[j - x] + 1\n        return f[-1] if f[-1] > 0 else -1\n"}
{"task_id": "python/71", "content": "\nExample 1:\nInput: m = 5, n = 8, hFences = [1,4,8], vFences = [3,6]\nOutput: 10\nExplanation: The figure above shows the field. Red fences represent the horizontal fences and blue fences represent the vertical fences.\n\nExample 2:\nInput: m = 2, n = 2, hFences = [1], vFences = [1]\nOutput: -1\nExplanation: It is impossible to form a square area that satisfies the conditions.\n\nExample 3:\nInput: m = 1, n = 1, hFences = [0], vFences = [0]\nOutput: 1\n\nExample 4:\nInput: m = 2, n = 2, hFences = [0,1], vFences = [0,1]\nOutput: 2\n\nConstraints:\n2 <= m, n <= 1000\n1 <= m * n <= 105\nhFences.length == vFences.length == fences.length\n1 <= fences[i] <= m - 1\nThe input is guaranteed to form a", "groundtruth": "\nclass Solution:\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n        h = self.f(hFences, m)\n        v = self.f(vFences, n)\n        ans = max(h & v, default=0)\n        return ans ** 2 % 1_000_000_007 if ans else -1\n\n    def f(self, a: List[int], mx: int) -> Set[int]:\n        a.extend([1, mx])\n        a.sort()\n        return set(y - x for x, y in combinations(a, 2))\n"}
{"task_id": "python/72", "content": "\nNote: If the answer is very large, return it modulo 10**9 + 7.\n\nConstraints:\n1 <= m <= 100\n1 <= n <= 100\n0 <= hFences.length, vFences.length <= min(m, n)\n1 <= hFences[i] <= m\n1 <= vFences[i] <= n\n\nExample 1:\nInput: m = 5, n = 8, hFences = [3, 5, 1, 10], vFences = [4, 8, 1, 3]\nOutput: 49\n\nExample 2:\nInput: m = 6, n = 8, hFences = [3, 5, 1, 7], vFences = [4, 8, 3, 6]\nOutput: 76\n\nExample 3:\nInput: m = 1000, n = 1000, hFences = [int(m/4), int(m/2), int(m*3/4)], vFences = [int(n/4), int(n/2), int(n*3/4)]\nOutput: 1000000\n\nExample 4:\nInput: m = 3, n = 3, hFences = [1], vFences = [1]\nOutput: 9\n\"\"\"\n\nclass Solution:\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n        hFences = self.f(hFences, m)\n        vFences = self.f(vFences, n)\n        d = {(m, n): 0}\n        for i in range(n, 0, -1):\n            for j in range(m, 0, -1):\n                if not(j-1 in hFences and i-1 in vFences):\n                    d[(j, i)] = max(d.get((j, i-1), 0)+1, max(d.get((j-1, i), 0)+", "groundtruth": "\nclass Solution:\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n        h = self.f(hFences, m)\n        v = self.f(vFences, n)\n        ans = max(h & v, default=0)\n        return ans ** 2 % 1_000_000_007 if ans else -1\n\n    def f(self, a: List[int], mx: int) -> Set[int]:\n        a.extend([1, mx])\n        a.sort()\n        return set(y - x for x, y in combinations(a, 2))\n"}
{"task_id": "python/73", "content": "\nYou can modify the source and target strings and can use variables, classes, and functions, but cannot import libraries.\n\nConstraints:\n\n1 <= source.length, target.length <= 1000\n1 <= target.length <= source.length\nsource and target consist of lowercase English letters.\noriginal.length == changed.length == cost.length\n1 <= original[i].length, changed[i].length, cost[i] <= 26\noriginal[i] != changed[i]\n\nExample 1:\nInput: source = \"abc\", target = \"abc\", original = [\"a\",\"b\",\"c\"], changed = [\"c\",\"b\",\"a\"], cost = [1,2,3]\nOutput: 0\nExplanation:\n- Start with the string \"abc\".\n- Apply the first operation on index 0:\n  - Change \"abc\" to \"cba\" at a cost of 1.\n- The string \"cba\" does not need further operations, so the minimum cost is 0.\nExample 2:\nInput: source = \"abcd\", target = \"acde\", original = [\"a\",\"b\",\"c\",\"d\"], changed = [\"c\",\"b\",\"e\",\"a\"], cost = [1,2,3,4]\nOutput: 2\nExplanation:\n- Start with the string \"abcd\".\n- Apply the second operation on index 2:\n  - Change \"abcd\" to \"aced\" at a cost of 3.\n- Apply the first operation on index 0:\n  - Change \"aced\" to \"aced\" at a cost of 1.\n- Apply the third operation on index 3:\n  - Change \"aced\" to \"acde\" at a cost of 4.\nThe total cost is 1 + 2 + 3 + 4 = 2.\nExample 3:\nInput: source = \"a\", target = \"b\", original = [\"a\"], changed = [\"b\"], cost = [4]\nOutput: -1\nExplanation:\n- There are no indices to operate on.\n- Change \"a\" to \"b\" requires 4, which is too expensive.\nNote that you can also", "groundtruth": "\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        dis = [[inf] * 26 for _ in range(26)]\n        for i in range(26):\n            dis[i][i] = 0\n\n        for x, y, c in zip(original, changed, cost):\n            x = ord(x) - ord('a')\n            y = ord(y) - ord('a')\n            dis[x][y] = min(dis[x][y], c)\n\n        for k in range(26):\n            for i in range(26):\n                for j in range(26):\n                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))\n        return ans if ans < inf else -1\n"}
{"task_id": "python/74", "content": "\nThe function that is defined in the incomplete code is a dynamic programming recursive function that is defined as follows:\n\ndfs(i) returns the minimum cost to convert the substring of source from the first index to the i-th index to target.\n\nConstraints:\nn == source.length == target.length\n1 <= n <= 105\n1 <= cost[i] <= 1000\n1 <= original[i].length, changed[i].length <= 15\noriginal[i] and changed[i] consist of lowercase English letters.\nNo two strings in original and changed have the same length.\noriginal and changed contain no duplicate strings with the same length.\nsource and target consist of lowercase English letters.\nsource is a prefix of target.\nTime complexity: O(n2)\nSpace complexity: O(n2), where n is the length of source.\n\n**Example 1:**\n![img](https://assets.leetcode.com/uploads/2022/03/06/ex1new2.jpg)\n```\nInput: source = \"sab\", target = \"ca\", original = [\"s\",\"t\",\"a\",\"b\"], changed = [\"c\",\"a\",\"t\",\"\"], cost = [16,3,19,20]\nOutput: 3\nExplanation:\nThere are three ways to convert \"sab\" to \"ca\".\nUsing the first string cost 16: \"s\" -> \"c\" [16] + \"ab\" -> \"a\" + \"t\" [3] + \"ca\" [20].\nUsing the second string cost 19: \"s\" -> \"c\" [16] + \"ab\" -> \"c\" + \"a\" [19] + \"t\" [20].\nUsing the third string cost 20: \"s\" -> \"c\" [16] + \"ab\" -> \"c\" + \"a\" [19] + \"ca\" [20].\nUsing the third string has the least cost, so we output 3.\n```\n\n**Example 2:**\n```\nInput: source = \"s\", target = \"s\", original = [\"s\"], changed = [\"s\"], cost = [0]\nOutput: 0\nExplanation:", "groundtruth": "\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        len_to_strs = defaultdict(set)\n        dis = defaultdict(lambda: defaultdict(lambda: inf))\n        for x, y, c in zip(original, changed, cost):\n            len_to_strs[len(x)].add(x)  \n            len_to_strs[len(y)].add(y)\n            dis[x][y] = min(dis[x][y], c)\n            dis[x][x] = 0\n            dis[y][y] = 0\n\n        for strs in len_to_strs.values():\n            for k in strs:\n                for i in strs:\n                    if dis[i][k] == inf:  \n                        continue\n                    for j in strs:\n                        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        @cache\n        def dfs(i: int) -> int:\n            if i == 0:\n                return 0\n            res = inf\n            if source[i - 1] == target[i - 1]:\n                res = dfs(i - 1) \n            for size, strs in len_to_strs.items():  \n                if i < size:\n                    continue\n                s = source[i - size: i]\n                t = target[i - size: i]\n                if s in strs and t in strs:  \n                    res = min(res, dis[s][t] + dfs(i - size))\n            return res\n        ans = dfs(len(source))\n        return ans if ans < inf else -1\n"}
{"task_id": "python/75", "content": "\n\nExample 1:\n\nInput: source = \"abc\", target = \"bab\", original = [\"bab\",\"aba\",\"aaa\",\"bcc\",\"aab\"], changed = [\"baa\",\"baa\",\"baa\",\"bcc\",\"aab\"], cost = [1,2,3,4,5]\nOutput: 2\nExplanation: We can do the following operations to convert \"abc\" to \"bab\":\n- Change the substring \"baa\" to \"bab\" that is, source[1..3] = \"baa\" and changed[1..3] = \"bab\". This operation is done at an estimated cost of 2, as original[1] == \"baa\" and changed[1] == \"bab\".\n\nExample 2:\n\nInput: source = \"abccba\", target = \"aaccba\", original = [\"aaccba\",\"aaccaa\",\"abccba\",\"aabcaa\",\"aaccab\",\"ababca\",\"aabcca\",\"aaccab\"], changed = [\"aaccba\",\"aaccaa\",\"aaccaa\",\"aabcaa\",\"aaccab\",\"ababca\",\"aabcca\",\"aaccab\"], cost = [7,5,5,4,5,6,6,3]\nOutput: -1\nExplanation: It is impossible to convert source to target.\n\nExample 3:\n\nInput: source = \"bab\", target = \"bba\", original = [\"bab\",\"bab\",\"bab\"], changed = [\"bba\",\"bba\",\"bba\"], cost = [4,1,1]\nOutput: 0\nExplanation: source == target, so no operations are required.\n\nConstraints:\n\nsource.length == n\ntarget.length == n\noriginal.length == changed.length == n\noriginal[i].length == changed[i].length == n\n1 <= original[i].length, n <= 10\noriginal[i] and changed[i] consist of lowercase English letters.\n1 <= cost.length <= 1000\n1 <= cost[i] <= 105\nsource and target contain only lowercase English letters.\n*/\n\nclass Solution {\npublic:\n    const int inf = 1e9;\n    \n    un", "groundtruth": "\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        len_to_strs = defaultdict(set)\n        dis = defaultdict(lambda: defaultdict(lambda: inf))\n        for x, y, c in zip(original, changed, cost):\n            len_to_strs[len(x)].add(x)  \n            len_to_strs[len(y)].add(y)\n            dis[x][y] = min(dis[x][y], c)\n            dis[x][x] = 0\n            dis[y][y] = 0\n\n        for strs in len_to_strs.values():\n            for k in strs:\n                for i in strs:\n                    if dis[i][k] == inf:  \n                        continue\n                    for j in strs:\n                        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        @cache\n        def dfs(i: int) -> int:\n            if i == 0:\n                return 0\n            res = inf\n            if source[i - 1] == target[i - 1]:\n                res = dfs(i - 1) \n            for size, strs in len_to_strs.items():  \n                if i < size:\n                    continue\n                s = source[i - size: i]\n                t = target[i - size: i]\n                if s in strs and t in strs:  \n                    res = min(res, dis[s][t] + dfs(i - size))\n            return res\n        ans = dfs(len(source))\n        return ans if ans < inf else -1\n"}
{"task_id": "cpp/0", "content": "\nSample Input 1\n\n[1, 2, 2]\nSample Output 1\n\n6\n\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef long long int ll;\n#define endl \"\\n\"\n#define maxn 100005\n#define mod 1000000007\n#define all(v) v.begin(),v.end()\n\nclass Solution {public:static const int mod = 1e9 + 7;int specialPerm(vector<int>& nums) {int n = nums.size();vector<vector<int>> f(1 << n, vector<int>(n, -1));function<int(int, int)> dfs = [&](int state, int i) {if (f[state][i] != -1) {return f[state][i];}if (state == (1 << i)) {return 1;}f[state][i] = 0;for (int j = 0; j < n; j++) {if (i == j || !(state >> j & 1)) {continue;}if (nums[i] % nums[j] != 0 && nums[j] % nums[i] != 0) {continue;}f[state][i] = (f[state][i] + dfs(state ^ (1 << j), j)) % mod;}};int res = 0;for (int i = 0; i < n; i++) {res = (res + dfs(1 << i, i)) % mod;}return res;}};\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL); cout.tie(NULL);\n\t\n\tvector<int> nums;\n\tnums.push_back(1);\n\tnums.push_back(2);\n\tnums.push_back(2);\n\t\n\tint n = nums.size();\n\tvector<vector<int>> f(1 << n, vector<int>(n, -1));\n\tfunction<int(int, int)> dfs = [&](", "groundtruth": "class Solution {public:static const int mod = 1e9 + 7;int specialPerm(vector<int>& nums) {int n = nums.size();vector<vector<int>> f(1 << n, vector<int>(n, -1));function<int(int, int)> dfs = [&](int state, int i) {if (f[state][i] != -1) {return f[state][i];}if (state == (1 << i)) {return 1;}f[state][i] = 0;for (int j = 0; j < n; j++) {if (i == j || !(state >> j & 1)) {continue;}if (nums[i] % nums[j] != 0 && nums[j] % nums[i] != 0) {continue;}f[state][i] = (f[state][i] + dfs(state ^ (1 << i), j)) % mod;}return f[state][i];};int res = 0;for (int i = 0; i < n; i++) {res = (res + dfs((1 << n) - 1, i)) % mod;}return res;}};"}
{"task_id": "cpp/1", "content": "The code is compiled using gcc 4.8.5, and the algorithm needs to be completed within the time limit.\nRemember to put the code you have written below the predefined code.\nThe input and output method are the same as", "groundtruth": "class Solution {public:int paintWalls(vector<int>& cost, vector<int>& time) {int n = cost.size();vector<int> f(n * 2 + 1, INT_MAX / 2);f[n] = 0;for (int i = 0; i < n; ++i) {vector<int> g(n * 2 + 1, INT_MAX / 2);for (int j = 0; j <= n * 2; ++j) {// 付费g[min(j + time[i], n * 2)] = min(g[min(j + time[i], n * 2)], f[j] + cost[i]);// 免费if (j > 0) {g[j - 1] = min(g[j - 1], f[j]);}}f = move(g);}return *min_element(f.begin() + n, f.end());}};"}
{"task_id": "cpp/2", "content": "Example1:\n\nInput:s = \"aaacbb\"\nOutput:\"ababab\"\nExplanation:The target string contains only 'b', so all 'a' are replaced by 'b'.\nExample2:\n\nInput:s = \"bbcdd\"\nOutput:\"abcd\"\nExplanation:The first non-empty substring of 'b' is 'bb', therefore the first letter of each string is replaced by 'b'.\nExample3:\n\nInput:s = \"abcd\"\nOutput:\"abcd\"\nExplanation:\"a\" is the first non-empty substring of 'a', so only \"a\" is replaced.\nExample4:\n\nInput:s = \"abc\"\nOutput:\"abc\"\nExplanation:No 'a' is found in the string, so there's nothing to replace.\nExample5:\n\nInput:s = \"abcdddeeeeaabbbcd\"\nOutput:\"abcddeeeeaabcd\"\nExplanation:The target string does not contain 'b', so only \"a\" is replaced.\nExample6:\n\nInput:s = \"abcdddeeeeaabbbcd\"\nOutput:\"abcdddeeeeaabcd\"\nExplanation:The target string does not contain 'b', so only \"a\" is replaced.\n\n*/\nclass Solution {\npublic:\n    string smallestString(string s) {\n        char target = 'a';\n        auto it = std::find_if(s.begin(), s.end(), [target](char c) {return c != target;});\n        int indexOfFirstNonA = std::distance(s.begin(), it);\n        if (indexOfFirstNonA == s.length()) {\n            return s.substr(0, s.length() - 1) + 'z';\n        }\n        size_t indexOfFirstA_AfterFirstNonA = s.find('a', indexOfFirstNonA);\n        if (", "groundtruth": "class Solution {public:string smallestString(string s) {char target = 'a';auto it = std::find_if(s.begin(), s.end(), [target](char c) {return c != target;});int indexOfFirstNonA = std::distance(s.begin(), it);if (indexOfFirstNonA == s.length()) {return s.substr(0, s.length() - 1) + 'z';}size_t indexOfFirstA_AfterFirstNonA = s.find('a', indexOfFirstNonA);if (indexOfFirstA_AfterFirstNonA == string::npos) {indexOfFirstA_AfterFirstNonA = s.length();}string res;for (int i = 0; i < s.length(); ++i) {if (indexOfFirstNonA <= i && i < indexOfFirstA_AfterFirstNonA) {res.push_back(static_cast<char>(s[i] - 1));} else {res.push_back(s[i]);}}return res;}};"}
{"task_id": "cpp/3", "content": "The given code runs on O(K * N), where K is the maximum of all nums[] and N is the size of the array.\n\nConstraints:\n1 <= n <= 10^5\n1 <= nums[i] <= 10^6\n1 <= x <= 10^6\nThe answer is guaranteed to fit within the 64 bit signed integer range.\n\nApproach:\n1. First sort the given array in increasing order and then using the greedy approach to find out the number of elements we need to collect at most once and once per every consecutive elements. So we are basically calculating the maximum possible value of X in such a way that it becomes less then the value of the largest element in the given array. \n2. After we find the value of X in which we will be able to collect all elements only once per every consecutive elements then we will start adding up the elements for the given X.\n3. In the end we will return the sum of the elements which we have collected.\n\nExplanation:\nTime Complexity - O(NlogN) - N is the length of nums \nAuxillary Space - O(N) - Sorting takes O(NlogN) space and also we have to create a temporary f[] array to calculate for X to find the sum of elements. \n\n*/\n\nclass Solution\n{\npublic:\n    long long minCost(vector<int> &nums, int x)\n    {\n        int n = nums.size();\n\n        vector<int> f(nums);\n        long long ans = 0;\n\n        for (int k = 1; k < n; ++k)\n        {\n            for (int i = 0; i < n; ++i)\n            {\n                f[i] = min(f[i], nums[(i + k) % n]);\n            }\n            ans += (f[x % n]);\n        }\n        return ans;\n    }\n};\n\n/*\n  Method 2: (Space optimized) - Using a temp variable to find the minimum value.\n*/\nclass Solution\n{\npublic:\n    long long minCost(vector<int> &nums, int x)\n    {\n        int n = nums.size();\n", "groundtruth": "class Solution {public:long long minCost(vector<int>& nums, int x) {int n = nums.size();vector<int> f(nums);long long ans = accumulate(f.begin(), f.end(), 0LL);for (int k = 1; k < n; ++k) {for (int i = 0; i < n; ++i) {f[i] = min(f[i], nums[(i + k) % n]);}ans = min(ans, static_cast<long long>(k) * x + accumulate(f.begin(), f.end(), 0LL));}return ans;}};"}
{"task_id": "cpp/4", "content": "Constraints:\n2 <= nums1.length == nums2.length == queries.length <= 2 * 104\n0 <= nums1[i], nums2[i] <= 109\n0 <= xi, yi <= nums1.length\nSample Input 1:\nnums1 = [2,3,7,11,15], nums2 = [1,3,7,17], queries = [[1,0],[2,3],[0,3]]\nSample Output 1:\n[7,14,7]\nExplanation: The first query, [1,0], is the maximum sum of any subarray where nums1[1] >= 1 and nums2[0] >= 0 since [] == 7. The second query, [2,3], is the maximum sum of any subarray where nums1[2] >= 2 and nums2[3] >= 3 since [7,11] == 14. The third query, [0,3], is the maximum sum of any subarray where nums1[0] >= 0 and nums2[3] >= 3 since [3,7,11,17] == 7. \nSample Input 2:\nnums1 = [1,4,2,3], nums2 = [1,5,2,4], queries = [[2,3],[1,3],[0,0]]\nSample Output 2:\n[7,6,5]\nExplanation: The first query, [2,3], is the maximum sum of any subarray where nums1[2] >= 2 and nums2[3] >= 3 since [3,4] == 7. The second query, [1,3], is the maximum sum of any subarray where nums1[1] >= 1 and nums2[3] >= 3 since [1,5,2,4] == 6. The third query, [0,0], is the maximum sum of any subarray where nums1[0] >= 0 and nums2[0] >= 0 since [1,4,2,3] == 5. \nSample Input 3:\nnums1 = [6,", "groundtruth": "class Solution {public:vector<int> maximumSumQueries(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {vector<pair<int, int>> sortedNums;vector<tuple<int, int, int>> sortedQueries;for (int i = 0; i < nums1.size(); i++) {sortedNums.emplace_back(nums1[i], nums2[i]);}sort(sortedNums.begin(), sortedNums.end(), greater<pair<int, int>>());for (int i = 0; i < queries.size(); i++) {sortedQueries.emplace_back(i, queries[i][0], queries[i][1]);}sort(sortedQueries.begin(), sortedQueries.end(), [](tuple<int, int, int> &a, tuple<int, int, int> &b) {return get<1>(a) > get<1>(b);});vector<pair<int, int>> stk;vector<int> answer(queries.size(), -1);int j = 0;for (auto &[i, x, y] : sortedQueries) {while (j < sortedNums.size() && sortedNums[j].first >= x) {auto [num1, num2] = sortedNums[j];while (!stk.empty() && stk.back().second <= num1 + num2) {stk.pop_back();}if (stk.empty() || stk.back().first < num2) {stk.emplace_back(num2, num1 + num2);}j++;}int k = lower_bound(stk.begin(), stk.end(), make_pair(y, 0)) - stk.begin();if (k < stk.size()) {answer[i] = stk[k].second;}}return answer;}};"}
{"task_id": "cpp/5", "content": "\n### Example 1:\n\nInput:s = \"abcabca\"\n\nOutput:4\n\nExplanation:The possible subsequences and the length of each are:\n\n\"abc\" - 3\n\n\"abca\" - 4\n\n\"bcab\" - 4\n\n\"cabc\" - 3\n\n### Example 2:\n\nInput:s = \"bbabbabbbaabababba\"\n\nOutput:4\n\nExplanation:The possible subsequences and the length of each are:\n\n\"bbabba\" - 6\n\n\"abba\" - 4\n\n\"bababba\" - 7\n\n\"bbababba\" - 7\n\n### Example 3:\n\nInput:s = \"ababababababababababa\"\n\nOutput:3\n\n### Example 4:\n\nInput:s = \"bbbbbb\"\n\nOutput:1\n\n### Example 5:\n\nInput:s = \"pwwkew\"\n\nOutput:3\n\nConstraints:\n\n3 <= s.length <= 104\n\ns consists only of digits from 0 to 9.\n\n## Code:\n\n```c++\nclass Solution {\npublic:\n    int longestSemiRepetitiveSubstring(string s) {\n        int ans = 1, left = 0, same = 0, n = s.length();\n        for (int right = 1; right < n; right++) {\n            if (s[right] == s[right - 1] && ++same > 1)\n                ans = max(ans, right - left + 1);\n            else\n                left = right, same = 0;\n        }\n        return ans;\n    }\n};\n```\n\n## Result List:\n\n|  Binary    |  Result   | Time        | Memory      |\n| ---------- | --------- | ----------- | ----------- |\n| Main       | Accepted  | 128 ms      | 32.7 MB     |\n| Submission | Accepted  | 128", "groundtruth": "class Solution {public:int longestSemiRepetitiveSubstring(string s) {int ans = 1, left = 0, same = 0, n = s.length();for (int right = 1; right < n; right++) {if (s[right] == s[right - 1] && ++same > 1) {for (left++; s[left] != s[left - 1]; left++);same = 1;}ans = max(ans, right - left + 1);}return ans;}};"}
{"task_id": "cpp/6", "content": "If there is any indeterminacy or ambiguity in the description, go by the sample input and output.\nTime limit: 2.00 seconds (as measured on a standard PC using a built-in C++ compiler).\nMemory limit: 512MB.\nInput:\nThe first line contains two space-separated integers n (2≤n≤100000), d (1≤d≤109). The second line contains n space-separated non-negative integers ai (0≤ai≤109) where 0≤i<n and the third line contains s a string of length n (containing only 'L' and 'R'). Note that there are no white-spaces in s.\nOutput:\nThe sum of the distances between the pairs of robots modulo 109 + 7.\n\n\nProblem 2\nQuestion: \nIn the previous challenge, you were given a string of 'R's and 'L's. Here you are given a string consisting of the characters [ and ]. Each character [ indicates the beginning of a set of brackets (i.e., a pair of '[' and a matching ']') and each character ] indicates the end of a set of brackets. You are also given a number d which is a positive integer. Return the sum of the distances (i.e., the length of each side) of every balanced pair of brackets of the string modulo 109 + 7. If there are no balanced pairs of brackets, return 0. The distance of two balanced brackets is calculated as if the entire pair was on a string of zero length. This distance is the sum of the distances of the pair of brackets from the beginning and ending pair of brackets.\nAn example will help you understand this better:\nExample 1:\n\nInput:\n\nS = [[[[[[[[[[[[[[[[[\nd = 3\nOutput:\n\n23\nExplanation:\n\nHere we have the string [[][][][]]. This contains four balanced pairs of brackets. The first two pairs are distance 2 apart, the third pair is distance 4 apart, and the fourth pair is distance 2 apart.\nWe should return 2 + 2 + 4 + 2 = 10, and since this is greater than 109 we return ", "groundtruth": "class Solution {public:static constexpr int mod = 1e9 + 7;int sumDistance(vector<int>& nums, string s, int d) {int n = nums.size();vector<long long> pos(n);for (int i = 0; i < n; i++) {if (s[i] == 'L') {pos[i] = (long long) nums[i] - d;} else {pos[i] = (long long) nums[i] + d;}}sort(pos.begin(), pos.end());long long res = 0;for (int i = 1; i < n; i++) {res += 1ll * (pos[i] - pos[i - 1]) * i % mod * (n - i) % mod;res %= mod;}return res;}};"}
{"task_id": "cpp/7", "content": "Input: grid = [[2,1,1,2],[1,0,0,1],[0,0,0,0]]\nOutput: [0,2]\nExplanation: The 0th and 2nd rows are the good rows as the sum of each column is less than half the number of rows. Notice that you should only return row indices. \nConstraints:\n\nm == grid.length\nn == grid[i].length\n2 <= n, m <= 50\ngrid[i][j] is either 0 or 1.\n \n\n## LC 1223\n\nGiven a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.\n\nclass Solution {public:int findMaxLength(vector<int>& nums) {vector<int> ans(nums.size()+1, 0);int sum = 0;for (int i = 0; i < nums.size(); i++) {sum += (nums[i] == 0 ? -1 : 1);ans[sum]++;}int temp = 0, res = 0;for (auto x : ans) {temp += x;if (temp == nums.size()) {return nums.size();} if (temp > nums.size()) {temp -= nums.size();res = max(res, temp);}}return res;}\n\n};\n\n\n## LC 1668\nYou have a string s that consists of some words separated by some number of spaces. Each word consists of lowercase English letters only.\nYour task is to convert s into an acceptable string according to the following rules:\nInsert as many pairs of brackets as needed so that every letter in s is inside a pair of brackets.\nYou do not need to add brackets directly to the string s, it is enough to only return a new string with all the necessary brackets inserted.\nThe inserted brackets should neither change the order of the words in s, nor introduce any group of distinct letters that are not already present in s.\nReturn a list of only two integers corresponding to the accepted string in lexicographic order.\n\nclass Solution {public:vector<int> corpFlightBookings(vector<vector<int>>& bookings, int n) {vector<", "groundtruth": "class Solution {public:vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {vector<int> ans;unordered_map<int, int> mp;int m = grid.size();int n = grid[0].size();for (int j = 0; j < m; j++) {int st = 0;for (int i = 0; i < n; i++) {st |= (grid[j][i] << i);}mp[st] = j;}if (mp.count(0)) {ans.push_back(mp[0]);return ans;}for (auto [x, i]: mp) {for (auto [y, j]: mp) {if (!(x & y)) {return {min(i, j), max(i, j)};}}}return ans;}};"}
{"task_id": "cpp/8", "content": "\n\nExample 1:\n\nInput: n = 3, queries = [[1,0,[2,2]],[2,1,[3,3]],[1,0,[2,3]]]\nOutput: 8\nExplanation:\nThe matrix starts as a 3x3 matrix of 0's.\nQuery 1 sets the matrix to [[2,2,2],[2,2,2],[2,2,2]].\nQuery 2 sets the matrix to [[3,3,3],[3,3,3],[3,3,3]].\nQuery 3 sets the matrix to [[2,3,3],[2,3,3],[2,3,3]], which is the final matrix.\nThe number of 3s is 2 + 3 + 3 = 8.\nExample 2:\n\nInput: n = 3, queries = [[2,1,2],[3,1,3],[1,1,[4,3]]]\nOutput: 6\nExplanation:\nThe matrix starts as a 3x3 matrix of 0's.\nQuery 1 sets the matrix to [[0,2,0],[0,2,0],[0,2,0]].\nQuery 2 sets the matrix to [[0,3,0],[0,3,0],[0,3,0]].\nQuery 3 sets the matrix to [[0,0,0],[0,3,0],[0,3,0]].\nThe number of 3s is 0 + 3 + 3 = 6.\n \n\nConstraints:\n\n1 <= n <= 1000\n1 <= queries.length <= 105\nqueries[i].length == 3\n0 <= typei, indexi, vali <= 1000\n\n\n\n\n\n\n\n\n\nclass Solution {\npublic:\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\n        long long ans = 0;\n        unordered_set<int> vis[2];\n        for (int i = queries.size() - 1; i >= 0; i--) {\n            auto& q = queries[i];\n            int type = q[0], index = q", "groundtruth": "class Solution {public:long long matrixSumQueries(int n, vector<vector<int>> &queries) {long long ans = 0;unordered_set<int> vis[2];for (int i = queries.size() - 1; i >= 0; i--) {auto &q = queries[i];int type = q[0], index = q[1], val = q[2];if (!vis[type].count(index)) { // 后面（>i）没有对这一行/列的操作// 这一行/列还剩下 n-vis[type^1].size() 个可以填入的格子ans += (long long) (n - vis[type ^ 1].size()) * val;vis[type].insert(index);}}return ans;}};"}
{"task_id": "cpp/9", "content": "\n \n\nExample 1:\n\nInput:\n\nnum1 = \"32\", num2 = \"13\"\nmin_sum = 0, max_sum = 24\n\nOutput:\n\n15\n\nExplanation:\n\nThere are 24 good integers in the range [0, 24] (inclusive) between 32 and 13. They are: 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43\n \n\nNote:\n\nYou could assume that num1 is always greater than num2.\n\n\n## solution\n\n```python\nclass Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        num2 = str(int(num2) + 1)\n        self.num = num2\n        self.min = min_sum\n        self.max = max_sum\n        self.n = len(num2)\n\n        if num1 == num2:\n            return self.count_one(num1, max_sum - min_sum + 1)\n        self.cache = [-1] * self.n * 1001\n        return self.dfs(self.n - 1, max_sum)\n\n    def count_one(self, num1: str, max_sum: int) -> int:\n        res = 0\n        for i in range(int(num1), max_sum + 1):\n            if self.check(str(i)):\n                res += 1\n        return res\n\n    def check(self, num):\n        return self.min <= int(num) <= self.max and self.sum(num) <= self.max and self.sum(num) >= self.min\n\n    def sum(self, num):", "groundtruth": "class Solution {static constexpr int N = 23;static constexpr int M = 401;static constexpr int MOD = 1e9 + 7;int d[N][M];string num;int min_sum;int max_sum;int dfs(int i, int j, bool limit) {if (j > max_sum) {return 0;}if (i == -1) {return j >= min_sum;}if (!limit && d[i][j] != -1) {return d[i][j];}int res = 0;int up = limit ? num[i] - '0' : 9;for (int x = 0; x <= up; x++) {res = (res + dfs(i - 1, j + x, limit && x == up)) % MOD;}if (!limit) {d[i][j] = res;}return res;}int get(string num) {reverse(num.begin(), num.end());this->num = num;return dfs(num.size() - 1, 0, true);}// 求解 num - 1，先把最后一个非 0 字符减去 1，再把后面的 0 字符变为 9string sub(string num) {int i = num.size() - 1;while (num[i] == '0') {i--;}num[i]--;i++;while (i < num.size()) {num[i] = '9';i++;}return num;}public:int count(string num1, string num2, int min_sum, int max_sum) {memset(d, -1, sizeof d);this->min_sum = min_sum;this->max_sum = max_sum;return (get(num2) - get(sub(num1)) + MOD) % MOD;}};"}
{"task_id": "cpp/10", "content": "\nNote: The input/output format and example provided are used for system testing, and should be used by a standard input/output method. The description is merely an example, so you may adapt it to the format required by the system.\n\nConstraints\n-----------\nm == mat.length\nn == mat[i].length\n1 <= m, n <= 500\n1 <= m * n <= 500\n0 <= arr.length <= 1000\n1 <= arr[i] <= m * n\n1 <= m * n <= 1000\nThe integers in arr are unique and all integers in arr are present in mat.\n\nInput\n-----\nYour input consists of two lines:\nThe first line contains a single integer m.\nThe second line contains a single integer n.\n\nOutput\n------\nPrint a single integer indicating the smallest index i.\n\nSample Input 1\n0\n3\n2\n0\n0\n0\n2\n\nSample Output 1\n3\n\nExplanation 1\nFor the following matrix,\n\n2  2  2\n1  1  1\n2  2  2\nFor the given array,\n\n0,0,0,1,2\nThe 3rd element in the array is the smallest element in the first unpainted row or column of the matrix.\n\nSample Input 2\n2\n2\n2\n0\n0\n1\n0\n1\n\nSample Output 2\n-1\n\nExplanation 2\nFor the following matrix,\n\n2  2\n2  1\nAll elements in the array will be painted, so no index satisfies the constraints.\n\"\"\"\nimport heapq\n\nclass Solution:\n    def firstCompleteIndex(self, arr: list, mat: list) -> int:\n        m, n = len(mat), len(mat[0])\n        heap = []\n        seen = set()\n        for v in arr:\n            if v not in seen:\n                heapq.heappush(heap, v)\n                seen.add(v)\n        \n        if heap[0] != 1 or heap[0] != 2:\n            return -1\n        \n        for v in arr:\n            x, y = 0, 0\n            for i", "groundtruth": "class Solution {public:int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {int n = mat.size();int m = mat[0].size();unordered_map<int, pair<int, int>> mp;for (int i = 0; i < n; ++i) {for (int j = 0; j < m; ++j) {mp[mat[i][j]] = {i, j};}}vector<int> rowCnt(n, 0);vector<int> colCnt(m, 0);for (int i = 0; i < arr.size(); ++i) {auto& v = mp[arr[i]];++rowCnt[v.first];if (rowCnt[v.first] == m) {return i;}++colCnt[v.second];if (colCnt[v.second] == n) {return i;}}return -1;}};"}
{"task_id": "cpp/11", "content": "If you have more questions, please contact us at qing.s@buaa.edu.cn.\n\n \n\n## Solution\n``` cpp\nclass Solution {\npublic:\n    int minimumCost(vector<int> &start, vector<int> &target, vector <vector<int>> &specialRoads) {\n        using LL = long long;\n        LL t = (LL) target[0] << 32 | target[1];\n        unordered_map<LL, int> dis = {{(LL) start[0] << 32 | start[1], 0}, {t, INT_MAX}};\n        unordered_set<LL> vis;\n        for (;;) {\n            LL v = -1;\n            int dv = -1;\n            for (auto &[p, d]: dis)if (!vis.count(p) && (dv < 0 || d < dv))v = p, dv = d;\n            if (v == t) return dv; // 到终点的最短路已确定\n            vis.insert(v);\n            int vx = v >> 32, vy = v & UINT32_MAX;// 更新到终点的最短路\n            for (auto &r: specialRoads) {\n                int d = r[4];\n                LL w = (LL) r[2] << 32 | r[3];\n                if (!dis.count(w) || d < dis[w])dis[w] = d;\n            }\n        }\n    }\n};\n```\n\n## 总结\n\n一开始没做好边界处理,造成了错误.需要注意一下. 如何边界", "groundtruth": "class Solution {public:int minimumCost(vector<int> &start, vector<int> &target, vector <vector<int>> &specialRoads) {using LL = long long;LL t = (LL) target[0] << 32 | target[1];unordered_map<LL, int> dis = {{(LL) start[0] << 32 | start[1], 0}, {t, INT_MAX}};unordered_set<LL> vis;for (;;) {LL v = -1;int dv = -1;for (auto &[p, d]: dis)if (!vis.count(p) && (dv < 0 || d < dv))v = p, dv = d;if (v == t) return dv; // 到终点的最短路已确定vis.insert(v);int vx = v >> 32, vy = v & UINT32_MAX;// 更新到终点的最短路dis[t] = min(dis[t], dv + target[0] - vx + target[1] - vy);for (auto &r: specialRoads) {int d = dv + abs(r[0] - vx) + abs(r[1] - vy) + r[4];LL w = (LL) r[2] << 32 | r[3];if (!dis.count(w) || d < dis[w])dis[w] = d;}}}};"}
{"task_id": "cpp/12", "content": "\n \n\nExample 1:\n\nInput: s = \"ba\", k = 1\nOutput: \"ab\"\nExplanation:\nThe first beautiful string of length 2 is \"ab\".\nNote that \"a\" is a substring of \"ab\".\nThe second beautiful string of length 2 is \"ac\".\nThe input \"ba\" is a beautiful string of length 2 because no string of length 2 is a substring of \"ba\".\nExample 2:\n\nInput: s = \"abc\", k = 1\nOutput: \"ac\"\nExplanation: \nThe first beautiful string of length 3 is \"ac\".\nThe input \"abc\" is a beautiful string of length 3 because no string of length 3 is a substring of \"abc\".\nExample 3:\n\nInput: s = \"aabcb\", k = 2\nOutput: \"bbcb\"\nExplanation: \nThe first beautiful string of length 4 is \"bbcb\".\nThe input \"aabcb\" is a beautiful string of length 4 because no string of length 4 is a substring of \"aabcb\".\nExample 4:\n\nInput: s = \"aabcb\", k = 1\nOutput: \"bbca\"\nExplanation: \nThe first beautiful string of length 5 is \"bbca\".\nExample 5:\n\nInput: s = \"aabb\", k = 2\nOutput: \"\"\n \n\nNote:\n\ns will consist of only lowercase English letters.\n1 <= k <= s.length <= 1000\n\n```\n/*\n * @lc app=leetcode.cn id=954 lang=javascript\n *\n * [954] 美好子字符串\n */\n\n// @lc code=start\n/**\n * @param {string} s\n * @param {number} k\n * @return {string}\n */\nvar smallestBeautifulString = function (s, k) {\n\n};\n// @lc code=end\n```\n\n[![-----------------------------------------------------](https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png)](#926-使用数组实现链表)\n", "groundtruth": "class Solution {public:string smallestBeautifulString(string s, int k) {for (int i = s.length() - 1; i >= 0; --i) {unordered_set<char> blockedCharacters;for (int j = 1; j <= 2; ++j) {if (i - j >= 0) {____}}for (int j = 1; j <= 3; ++j) {if (s[i] - 'a' + j + 1 <= k && blockedCharacters.find(s[i] + j) == blockedCharacters.end()) {return generate(s, i, j);}}}return \"\";}string generate(string s, int idx, int offset) {s[idx] += offset;for (int i = idx + 1; i < s.length(); ++i) {unordered_set<char> blockedCharacters;for (int j = 1; j <= 2; ++j) {if (i - j >= 0) {blockedCharacters.insert(s[i - j]);}}for (int j = 0; j < 3; ++j) {if (____) {s[i] = 'a' + j;break;}}}return s;}};"}
{"task_id": "cpp/13", "content": "Input:", "groundtruth": "class Solution {public:vector<int> findThePrefixCommonArray(vector<int> &a, vector<int> &b) {int n = a.size();vector<int> ans(n);long long p = 0, q = 0;for (int i = 0; i < n; ++i) {p |= 1LL << a[i];q |= 1LL << b[i];ans[i] = __builtin_popcountll(p & q);}return ans;}};"}
{"task_id": "cpp/14", "content": "This", "groundtruth": "class Solution {static constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};public:int findMaxFish(vector<vector<int>> &grid) {int m = grid.size(), n = grid[0].size(), ans = 0;function<int(int, int)> dfs = [&](int x, int y) -> int {if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0)return 0;int sum = grid[x][y];grid[x][y] = 0; // 标记成访问过for (auto &d: dirs) // 四方向移动sum += dfs(x + d[0], y + d[1]);return sum;};for (int i = 0; i < m; ++i)for (int j = 0; j < n; ++j)ans = max(ans, dfs(i, j));return ans;}};"}
{"task_id": "cpp/15", "content": "Example 1:\nInput: nums = [100,200,300,400]\nOutput: 1\nExplanation: 1. Remove 100 and insert 200 at the end. 200 becomes the first element. nums = [200,300,400,100]\nWe have to make nums empty, so we use the minimum operation allowed.\nExample 2:\nInput: nums = [1,2,3,4,5,6]\nOutput: 5\nExplanation: 5. Remove 1 and insert 6 at the end. 6 becomes the first element. nums = [6,2,3,4,5,1]\nRemove 6 and insert 1 at the end. 1 becomes the first element. nums = [1,2,3,4,5,6]\nRemove 1 and insert 2 at the end. 2 becomes the first element. nums = [2,3,4,5,6,1]\nRemove 2 and insert 3 at the end. 3 becomes the first element. nums = [3,4,5,6,1,2]\nRemove 3 and insert 4 at the end. 4 becomes the first element. nums = [4,5,6,1,2,3]\nRemove 4 and insert 5 at the end. 5 becomes the first element. nums = [5,6,1,2,3,4]\nRemove 5 and insert 6 at the end. 6 becomes the first element. nums = [6,1,2,3,4,5]\nRemove 6 and insert 1 at the end. 1 becomes the first element. nums = [1,6,2,3,4,5]\nWe have to make nums empty, so we use 5 operations.\nExample 3:\nInput: nums = [1,1,1,1,1,1,1,1,1,1]\nOutput: 9\nConstraints:\n1 <= nums.length <= 105\n104 <= nums[i] <= 109\nnums is a permutation of all the numbers between", "groundtruth": "// 树状数组模板class BIT {vector<int> tree;public:BIT(int n) : tree(n) {}// 将下标 i 上的数加一void inc(int i) {while (i < tree.size()) {++tree[i];i += i & -i;}}// 返回闭区间 [1, i] 的元素和int sum(int x) {int res = 0;while (x > 0) {res += tree[x];x &= x - 1;}return res;}// 返回闭区间 [left, right] 的元素和int query(int left, int right) {return sum(right) - sum(left - 1);}};class Solution {public:long long countOperationsToEmptyArray(vector<int> &nums) {int n = nums.size(), id[n];iota(id, id + n, 0);sort(id, id + n, [&](int i, int j) {return nums[i] < nums[j];});long long ans = n; // 先把 n 计入答案BIT t(n + 1); // 下标从 1 开始int pre = 1; // 上一个最小值的位置，初始为 1for (int k = 0; k < n; ++k) {int i = id[k] + 1; // 下标从 1 开始if (i >= pre) // 从 pre 移动到 i，跳过已经删除的数ans += i - pre - t.query(pre, i);else // 从 pre 移动到 n，再从 1 移动到 i，跳过已经删除的数ans += n - pre + i - k + t.query(i, pre - 1);t.inc(i); // 删除 ipre = i;}return ans;}};"}
{"task_id": "cpp/16", "content": "You may assume k is always valid. Note:\n1≤k≤200001≤k≤2000\n1≤x≤20001≤x≤2000\nThe number of elements in the given array will be in the range [2, 50000] [2,50000]\nThe range of the integers in the given array will be in the range [-50000000, 50000000] [−50000000,50000000]\n\nclass Solution {\npublic:\n    vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x) {\n        int n = nums.size();\n        // nums 中负数的偏移量为 BIAS\n        const int BIAS = 50;\n        vector<int> ret(n - k + 1);\n        // cnt 用来记录 nums 中的负数的个数。 \n        // 由于题目要求计算美丽值，因此 cnt 中要统计的数为 -nums[i] + BIAS 。\n        // 假设 cnt 中记录了 nums[0,i] 中的美丽值，\n        // 那么 nums[i,i+k] 中的美丽值就等于 cnt[ nums[i+k] + BIAS ] - cnt[ nums[i] + BIAS ]\n        int cnt[BIAS * 2 + 1]{};\n        // 先往窗口内添加 k-1 个数\n        // 此时不记录 cnt 信息\n        // 考虑每个数出现多少次，使用cnt\n        for (int i = 0; i < n; ++i)\n        {\n            if (i >= k)\n                // 释放 nums[i-k] 的记录信息\n                cnt[nums[i - k", "groundtruth": "class Solution {public:vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x) {const int BIAS = 50;int cnt[BIAS * 2 + 1]{}, n = nums.size();for (int i = 0; i < k - 1; ++i) // 先往窗口内添加 k-1 个数++cnt[nums[i] + BIAS];vector<int> ans(n - k + 1);for (int i = k - 1; i < n; ++i) {++cnt[nums[i] + BIAS]; // 进入窗口（保证窗口有恰好 k 个数）int left = x;for (int j = 0; j < BIAS; ++j) { // 暴力枚举负数范围 [-50,-1]left -= cnt[j];if (left <= 0) { // 找到美丽值ans[i - k + 1] = j - BIAS;break;}}--cnt[nums[i - k + 1] + BIAS]; // 离开窗口}return ans;}};"}
{"task_id": "cpp/17", "content": "Note: gcd(a, b) is the greatest common divisor of a and b.\n\nThe answer will be accepted in any of the forms:\nclass Solution {public:int minOperations(vector<int> &nums) {......}};\nint func(vector<int> &nums, ...) {......};\n\nInput: nums = [1,5,9]\nOutput: 2\nExplanation: Replace 9 with 1 in 1 operation and replace 1 with 1 in another operation.\n\nInput: nums = [2,3,4,8,10]\nOutput: 5\nExplanation: Replace 8 with 4 and 10 with 2 in the first operation. Replace 2 with 2 and 3 with 1 in the second operation. Replace 4 with 2 and 2 with 1 in the third operation. Replace 1 with 1 and 2 with 1 in the fourth operation. Replace 2 with 1 in the fifth operation.\n\nInput: nums = [3,2,3,2,2,2,3,3,3]\nOutput: 6\nExplanation: Replace 3 with 3 and 2 with 2 in the first 2 operations. Replace 3 with 3 and 2 with 1 in the next 2 operations. Replace 3 with 3 and 2 with 2 in the next 2 operations. Total number of operations = 2 + 2 + 2 + 2 + 1 = 6.\n\nInput: nums = [1,1,1,2,2,2,3,3,3,4,4,4,4,5,5,5,5,5]\nOutput: 4\n\nInput: nums = [1,2,3]\nOutput: -1\nExplanation: It is not possible to make all elements equal.\n\n \n\nConstraints:\n\n    1 <= nums.length <= 105\n    1 <= nums[i] <= 109\n*/\n\nclass Solution {\npublic:\n    int minOperations(vector<int>& nums) {\n        int n = nums.size(), gcd_all = 0, cnt1 = 0;", "groundtruth": "class Solution {public:int minOperations(vector<int> &nums) {int n = nums.size(), gcd_all = 0, cnt1 = 0;for (int x: nums) {gcd_all = gcd(gcd_all, x);cnt1 += x == 1;}if (gcd_all > 1) return -1;if (cnt1) return n - cnt1;int min_size = n;for (int i = 0; i < n; ++i) {int g = 0;for (int j = i; j < n; ++j) {g = gcd(g, nums[j]);if (g == 1) {// 这里本来是 j-i+1，把 +1 提出来合并到 return 中min_size = min(min_size, j - i);break;}}}return min_size + n - 1;}};"}
{"task_id": "cpp/18", "content": "\n```python\nclass Solution:\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\n        ans = -1\n        for num in divisors:\n            cnt = 0\n            for n in nums:\n                if n%num == 0:\n                    cnt += 1\n            if cnt > ans or (ans == cnt and num < ans):\n                ans = num\n        return ans\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "class Solution {public:int maxDivScore(vector<int>& nums, vector<int>& divisors) {int cnt = -1, ans = 0;for (int i = 0; i < divisors.size(); i++) {int tmp = 0;for (int j = 0; j < nums.size(); j++) {if (nums[j] % divisors[i] == 0) {tmp++;}}if (tmp > cnt || (tmp == cnt && divisors[i] < ans)) {ans = divisors[i];cnt = tmp;}}return ans;}};"}
{"task_id": "cpp/19", "content": "Example:\nThe sample input data: abc\nThe sample output data: 3\n", "groundtruth": "class Solution {public:int addMinimum(string word) {int n = word.size();vector<int> d(n + 1);for (int i = 1; i <= n; i++) {d[i] = d[i - 1] + 2;if (i > 1 && word[i - 1] > word[i - 2]) {d[i] = d[i - 1] - 1;}}return d[n];}};"}
{"task_id": "cpp/20", "content": "* A tree is an undirected graph in which any two vertices are connected by exactly one path. This definition ensures that a tree is connected.\n* A rooted tree is a tree such that there is exactly one vertex, called the root, without any incoming edges.\n* A rooted tree is called unrooted if it is not rooted.\n* The number of nodes in the tree is n, where 1 <= n <= 10^5.\n* There are n - 1 edges in the tree, where 1 <= n - 1 <= 10^5.\n* 0 <= ai, bi < n, where ai != bi\n* All pairs of node indices are unique.\n* The graph may contain self-loops.\n* The graph is unrooted.\n* 0 <= price[i] <= 10^4\n* 1 <= trips.length <= 10^5\n* There will be at most 100 trips[i].length == 2.\n* trips[i][0] != trips[i][1]\n* 0 <= starti < trips.length\n* 0 <= endi < trips.length\n* All integers in trips[i] are unique.\n\n\n\n## Solution \n\n```\nclass Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        \"\"\"\n        假设原树为T = (V, E), 一个子树为T', 两棵子树的价值为dp[i]，dp[i]表示从节点i出发到任意子树的价值和，那么我们要求的结果为\n        ans = dp[0] + dp[1] + dp[2] + ... + dp[n - 1]\n        其中\n        dp[0] = 0（由于节点0不存在边，所以节点0对dp[i]没有贡献）\n        对每个节点i，dp[i] = min(dp[i", "groundtruth": "class Solution {public:int minimumTotalPrice(int n, vector<vector<int>> &edges, vector<int> &price, vector<vector<int>> &trips) {vector<vector<int>> next(n);for (auto &edge : edges) {next[edge[0]].push_back(edge[1]);next[edge[1]].push_back(edge[0]);}vector<int> count(n);function<bool(int, int, int)> dfs = [&](int node, int parent, int end) -> bool {if (node == end) {count[node]++;return true;}for (int child : next[node]) {if (child == parent) {continue;}if (dfs(child, node, end)) {count[node]++;return true;}}return false;};for (auto &trip: trips) {dfs(trip[0], -1, trip[1]);}function<pair<int, int>(int, int)> dp = [&](int node, int parent) -> pair<int, int> {pair<int, int> res = {price[node] * count[node], price[node] * count[node] / 2};for (int child : next[node]) {if (child == parent) {continue;}auto [x, y] = dp(child, node);res.first += min(x, y); // node 没有减半，因此可以取子树的两种情况的最小值res.second += x; // node 减半，只能取子树没有减半的情况}return res;};auto [x, y] = dp(0, -1);return min(x, y);}};"}
{"task_id": "cpp/21", "content": "\nConstraints:\nnums.length == n\n1 <= n <= 10^5\n0 <= nums[i] <= 10^6\nThere are at most 100 testcases.\n\nExample 1:\nInput: nums = [2, 1, 4, 3, 6, 10, 8, 9]\nOutput: [2, 5, 11, 17, 23, 31, 36, 37]\n\nExplanation:\nAt index i, we have the prefix [2, 1, 4, 3, 6, 10, 8, 9] with sum: 2 + 1 + 4 + 3 + 6 + 10 + 8 + 9 = 37\nSo, we return [2, 5, 11, 17, 23, 31, 36, 37]\nExample 2:\n\nInput: nums = [4,4,4,4]\nOutput: [4,8,16,32]\n\nExplanation:\nAt index i, we have the prefix [4, 4, 4, 4] with sum: 4 + 4 + 4 + 4 = 16\nSo, we return [4,8,16,32]\n \n*/\n\nclass Solution {\npublic:\n    vector<long long> findPrefixScore(vector<int>& nums) {\n        vector<long long> ans;\n        int tmp = nums[0];\n        ans.push_back(nums[0] * 2);\n        for (int i = 1; i < nums.size(); ++i) {\n            if (nums[i] > tmp) tmp = nums[i];\n            ans.push_back(ans[i-1] + (nums[i] + tmp)*2);\n        }\n        return ans;\n    }\n};\n\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvoid test_solution() {\n\n    Solution sol;\n    vector<int> nums;", "groundtruth": "class Solution {public:vector<long long> findPrefixScore(vector<int>& nums) {vector<long long> ans;int tmp = nums[0];ans.push_back(nums[0] * 2);for (int i = 1; i < nums.size(); ++i) {if (nums[i] > tmp) tmp = nums[i];ans.push_back(nums[i] + tmp + ans[i - 1]);}return ans;}};"}
{"task_id": "cpp/22", "content": "Sample input: 1,2,3,4,5,6\nExpected output: 19,19,18,17,15,15\nExample:\nroot = [1,2,3,4,5,null,6]\nOutput: [19,19,18,17,15,15,null,null,6]\n  Explanation:\n    [1,2,3,4,5,null,6]\n      1  2  3  4  5\n         \\\n          2   3\n        [6]\n   The tree is look like:\n   (The following represents an input tree. The tree is represented by the list of each node's value,\n   and each node is separated by a comma.)\n   We call the above tree node 'N'.\n   The value of the root node 'N' is 19. (19 = 15 + 3(2) + 2(3))\n   The value of the left child node 'L' is 19. (19 = 15 + 4 + 6)\n   The value of the right child node 'R' is 18. (18 = 15 + 1 + 2)\n   The value of the left-left child node 'LL' is 17. (17 = 14 + 3)\n   The value of the left-right child node 'LR' is 15. (15 = 14 + 1)\n   The value of the right-left child node 'RL' is 15. (15 = 13 + 1)\n   The value of the right-right child node 'RR' is null.\n \n*/\n\nclass Solution\n{\npublic:\n  TreeNode *replaceValueInTree(TreeNode *root)\n  {\n    if (root == NULL)\n      return root;\n    queue<TreeNode *> q1;\n    queue<TreeNode *> q2;\n\n    q1.push(root);\n    q2.push(root);\n\n    while (q1.empty() == false)\n    {\n      int sum = 0;\n      q1.push(NULL);\n", "groundtruth": "class Solution {public:TreeNode* replaceValueInTree(TreeNode* root) {vector<TreeNode*> q = {root};root->val = 0;while (!q.empty()) {vector<TreeNode*> q2;int sum = 0;for (auto fa : q) {if (fa->left) {q2.push_back(fa->left);sum += fa->left->val;}if (fa->right) {q2.push_back(fa->right);sum += fa->right->val;}}for (auto fa : q) {int child_sum = (fa->left ? fa->left->val : 0) +(fa->right ? fa->right->val : 0);if (fa->left) {fa->left->val = sum - child_sum;}if (fa->right) {fa->right->val = sum - child_sum;}}q = move(q2);}return root;}};"}
{"task_id": "cpp/23", "content": "\nThe code is:\n```c++\nclass Graph {\npublic:\n  using pii = pair<int, int>;\n  Graph(int n, vector<vector<int>>& edges) {\n    this->graph = vector<vector<pii>>(n);\n    for (auto& vec : edges) {\n      int x = vec[0];\n      int y = vec[1];\n      int cost = vec[2];\n      graph[x].emplace_back(y, cost);\n    }\n  }\n  void addEdge(vector<int> edge) {\n    int x = edge[0];\n    int y = edge[1];\n    int cost = edge[2];\n    graph[x].emplace_back(y, cost);\n  }\n  int shortestPath(int node1, int node2) {\n    priority_queue<pii, vector<pii>, greater<pii>> pq;\n    vector<int> dist(graph.size(), INT_MAX);\n    dist[node1] = 0;\n    pq.emplace(0, node1);\n    while (!pq.empty()) {\n      auto [cost, cur] = pq.top();\n      pq.pop();\n      if (cur == node2) {\n        return cost;\n      }\n      for (int i = 0; i < graph[cur].size(); i++) {\n        int next = graph[cur][i].first;\n        int ncost = graph[cur][i].second;\n        if (dist[next] > cost + ncost) {\n          dist[next] = cost + ncost;\n          pq.emplace(cost + ncost, next);\n        }\n      }\n    }\n    return -1;\n  }\nprivate:\n  vector<vector<pii>> graph;\n};\n```\n\n- [Problem link](https://leetcode.com/discuss/general-discussion/626428/shortest-path-using-dijkstras-algorithm-%2810-mins%29)\n\n## Problem: 160. Intersection of Two Linked Lists (Easy)\n\n- [Problem link", "groundtruth": "class Graph {public:using pii = pair<int, int>;Graph(int n, vector<vector<int>>& edges) {this->graph = vector<vector<pii>>(n);for (auto &vec : edges) {int x = vec[0];int y = vec[1];int cost = vec[2];graph[x].emplace_back(y, cost);}}void addEdge(vector<int> edge) {int x = edge[0];int y = edge[1];int cost = edge[2];graph[x].emplace_back(y, cost);}int shortestPath(int node1, int node2) {priority_queue<pii, vector<pii>, greater<pii>> pq;vector<int> dist(graph.size(), INT_MAX);dist[node1] = 0;pq.emplace(0, node1);while (!pq.empty()) {auto [cost, cur] = pq.top();pq.pop();if (cur == node2) {return cost;}for (auto [next, ncost] : graph[cur]) {if (dist[next] > cost + ncost) {dist[next] = cost + ncost;pq.emplace(cost + ncost, next);}}}return -1;}private:vector<vector<pii>> graph;};"}
{"task_id": "cpp/24", "content": "Input Specification:\nEach input file contains one test case. For each case, the first line contains a positive integer N (≤2×105), the number of integers in the array nums. The second line contains N positive integers nums[i] (where 0<nums[i]≤109), with all distinct numbers.\nOutput Specification:\nFor each test case, print the array arr in one line, where each integer is separated by a space.\nSample Input 1:\n6\n1 2 3 4 5 6\nSample Output 1:\n2 3 6 7 5 4\nSample Input 2:\n5\n10 10 9 8 8\nSample Output 2:\n6 5 1 2 3\n\n*/\n\n\nclass Solution {\npublic:\n    vector<long long> distance(vector<int> &nums) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> groups;\n        for (int i = 0; i < n; ++i)\n            groups[nums[i]].push_back(i);\n        \n        vector<long long> ans(n);\n        long long s[n + 1];\n        s[0] = 0;\n        for (auto &[_, a]: groups) {\n            int m = a.size();\n            for (int i = 0; i < m; ++i)\n                s[i + 1] = s[i] + a[i];\n            \n            for (int i = 0; i < m; ++i) {\n                long long target = a[i];\n                long long left = 0, right = s[m] - s[i] - target * (m - i);\n                while (left + 1 < right) {\n                    long long mid = (left + right) / 2;\n                    if (mid == target) {\n                        left = mid;\n                    } else if (mid < target) {\n                        left = mid;\n                    } else {\n                        right = mid;\n                    }\n                }\n                ans[a[i]] += target - left;", "groundtruth": "class Solution {public:vector<long long> distance(vector<int> &nums) {int n = nums.size();unordered_map<int, vector<int>> groups;for (int i = 0; i < n; ++i)groups[nums[i]].push_back(i); // 相同元素分到同一组，记录下标vector<long long> ans(n);long long s[n + 1];s[0] = 0;for (auto &[_, a]: groups) {int m = a.size();for (int i = 0; i < m; ++i)s[i + 1] = s[i] + a[i]; // 前缀和for (int i = 0; i < m; ++i) {long long target = a[i];long long left = target * i - s[i]; // 蓝色面积long long right = s[m] - s[i] - target * (m - i); // 绿色面积ans[target] = left + right;}}return ans;}};"}
{"task_id": "cpp/25", "content": "Please take note of the following points:\nThe code you write only defines the function 'minimizeMax'. We will use the function to test the code. You can change the input, but you cannot change the definition of the function 'minimizeMax' and the function 'main'.\nThe return value is always 0, and we will only test your code in the main function. \nYou can leave your code unfinished as long as you have not defined the function 'minimizeMax'.\n\n'''\n\n\nclass Solution:\n    def minimizeMax(self, nums, p):\n        nums.sort()\n        left, right = -1, nums[-1] - nums[0]\n        while left + 1 < right:\n            mid = (left + right) >> 1\n            cnt = 0\n            for i in range(len(nums) - 1):\n                if nums[i + 1] - nums[i] >= mid:\n                    cnt += 1\n                if cnt >= p:\n                    break\n            return right if cnt >= p else left\n\nif __name__ == '__main__':\n    test_cases = [[[11, 21, 1, 1, 10, 31], 5], [[1, 4, 100, 10, 2], 3]]\n    for case in test_cases:\n        ans = Solution().minimizeMax(*case)\n        print(ans)\n", "groundtruth": "class Solution {public:int minimizeMax(vector<int> &nums, int p) {sort(nums.begin(), nums.end());int left = -1, right = nums.back() - nums[0]; // 开区间while (left + 1 < right) { // 开区间int mid = left + (right - left) / 2, cnt = 0;for (int i = 0; i < nums.size() - 1; ++i)if (nums[i + 1] - nums[i] <= mid) { // 都选++cnt;++i;}(cnt >= p ? right : left) = mid;}return right;}};"}
{"task_id": "cpp/26", "content": "Note: The input grid is only used for initializing the object of class Solution and only the following line of code will use the class instance:Solution ob = Solution();ob.minimumVisitedCells(grid);\n \n\nExample 1:\n\nInput: grid = [[0,0,0,1,1],[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,1],[1,0,0,0,0]]\nOutput: 5\nExplanation: \nThe grid is shown above.\nThe bold elements represent the minimum number of visited cells to reach that cell. Note that cell (1, 2) is reached in at least 2 different ways.\nExample 2:\n\nInput: grid = [[0,1,1,1,1],[1,0,0,0,1],[1,1,0,0,1],[1,1,0,0,1],[1,1,1,1,1]]\nOutput: 13\nExplanation:\nThe grid is shown above.\nThe elements in the first row and the last column are all 1.\nWe need to visit each cell at least once.\nThe cells to the right and below are either 0 or 1. So we can stop on (0, 0), (1, 0), and (1, 3) cells.\nThus the answer is at least 1 + 1 + 1 = 3 but no more than 1 + 3 + 1 = 5.\nSo the answer is 5.\nExample 3:\n\nInput: grid = [[1,1,1,1,1,1,1]]\nOutput: 7\nExplanation: We can reach cell (7, 7) from cell (0, 0).\nExample 4:\n\nInput: grid = [[1,1,1,1,1,1,1,1,1,1,1,1]]\nOutput: 14\n \n\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 105\n1 <= grid[i][j] <= 105\n \n\nFollow up: Could you solve this problem in O", "groundtruth": "class Solution {public:int minimumVisitedCells(vector<vector<int>>& grid) {int m = grid.size(), n = grid[0].size();vector<vector<int>> dist(m, vector<int>(n, -1));dist[0][0] = 1;vector<priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>>> row(m), col(n);auto update = [](int& x, int y) {if (x == -1 || y < x) {x = y;}};for (int i = 0; i < m; ++i) {for (int j = 0; j < n; ++j) {while (!row[i].empty() && row[i].top().second + grid[i][row[i].top().second] < j) {row[i].pop();}if (!row[i].empty()) {update(dist[i][j], dist[i][row[i].top().second] + 1);}while (!col[j].empty() && col[j].top().second + grid[col[j].top().second][j] < i) {col[j].pop();}if (!col[j].empty()) {update(dist[i][j], dist[col[j].top().second][j] + 1);}if (dist[i][j] != -1) {row[i].emplace(dist[i][j], j);col[j].emplace(dist[i][j], i);}}}return dist[m - 1][n - 1];}};"}
{"task_id": "cpp/27", "content": "\nInput: nums = [1,1,2,2,3,3,4,4,5,5]\n\nOutput: [[1,2,3,4,5],[1,2,3,4,5]]\n\nExplanation: This is the only possible answer that satisfies all the conditions.\n\nclass Solution {public:vector<vector<int>> findMatrix(vector<int> &nums) {unordered_map<int, int> cnt;for (int x: nums) ++cnt[x];vector<vector<int>> ans;while (!cnt.empty()) {vector<int> row;for (auto it = cnt.begin(); it != cnt.end();) {row.push_back(it->first);if (____) ____;else ++it;}ans.push_blank_()row;}}return ans;}};\n\nclass Solution {public:vector<vector<int>> findMatrix(vector<int> &nums) {unordered_map<int, int> cnt;for (int x: nums) ++cnt[x];vector<vector<int>> ans;while (!cnt.empty()) {vector<int> row;for (auto it = cnt.begin(); it != cnt.end();) {row.push_back(it->first);if (____) ____;else ++it;}ans.push_back(row);}return ans;}};\n\nclass Solution {public:vector<vector<int>> findMatrix(vector<int> &nums) {unordered_map<int, int> cnt;for (int x: nums) ++cnt[x];vector<vector<int>> ans;while (!cnt.empty()) {vector<int> row;for (auto it = cnt.begin(); it != cnt.end();) {row.push_back(it->first);if (____) ____;else ++it;}ans.push_back(row);}return ans;}};\n\nclass Solution {public:vector<vector<int>> findMatrix(vector<int> &nums) {unordered_map<int, int> cnt;for (int x: nums) ++cnt[x];vector<vector<int>> ans;while (!cnt.empty()) {vector", "groundtruth": "class Solution {public:vector<vector<int>> findMatrix(vector<int> &nums) {unordered_map<int, int> cnt;for (int x: nums) ++cnt[x];vector<vector<int>> ans;while (!cnt.empty()) {vector<int> row;for (auto it = cnt.begin(); it != cnt.end();) {row.push_back(it->first);if (--it->second == 0) it = cnt.erase(it);else ++it;}ans.push_back(row);}return ans;}};"}
{"task_id": "cpp/28", "content": "Input Format\nThe first argument given is the integer array reward1. The second argument is the integer array reward2. The third argument is the integer k.\nOutput Format\nReturn the maximum points the mice can achieve if the first mouse eats exactly k types of cheese.\nConstraints\nn ≤ 105\nreward1[i], reward2[i], and k are integers between 1 and 100.\nExample Input 0\nExample Output 0\nExplanation 0\nIf the first mouse eats cheese at index 0, the mouse can achieve 20 points (reward1[0] - reward2[0] + reward1[1] - reward2[1] + ... + reward1[k-1] - reward2[k-1] ).\nThe mice can achieve a total of 20 points.\nExample Input 1\nExample Output 1\nExplanation 1\nIf the first mouse eats cheese at index 0, the mouse can achieve 18 points (reward1[0] - reward2[0] + reward1[1] - reward2[1] + ... + reward1[k-1] - reward2[k-1] ).\nIf the first mouse eats cheese at index 1, the mouse can achieve 10 points (reward1[1] - reward2[1] + reward1[2] - reward2[2] + ... + reward1[k-1] - reward2[k-1] ).\nIf the first mouse eats cheese at index 2, the mouse can achieve 4 points (reward1[2] - reward2[2] + reward1[3] - reward2[3] + ... + reward1[k-1] - reward2[k-1] ).\nThe mice can achieve a total of 42 points.\nExample Input 2\nExample Output 2\nExplanation 2\nIf the first mouse eats cheese at index 0, the mouse can achieve 33 points (reward1[0] - reward2[0] + reward1[1] - reward2[1] + ... + reward1[k-1] - reward2[k-1] ).\nIf the first mouse eats cheese at index 1,", "groundtruth": "class Solution {public:int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {int ans = 0;int n = reward1.size();vector<int> diffs(n);for (int i = 0; i < n; i++) {ans += reward2[i];diffs[i] = reward1[i] - reward2[i];}sort(diffs.begin(), diffs.end());for (int i = 1; i <= k; i++) {ans += diffs[n - i];}return ans;}};"}
{"task_id": "cpp/29", "content": "\nExample 1:\nInput: n = 18, p = 6, banned = [3,5], k = 2\nOutput: [10,3,4]\nExplanation: The answer is [10,3,4], where the first 10 operations take the index 6 from 0 to 10. The next 3 operations take the index 8 to 10. The last 4 operations take the index 6 to 11.\nThe index 5 is set to 1 at first operation, which is impossible.\nThe index 6 to 11 is set to 1 at the last 4 operations, which is impossible.\nExample 2:\nInput: n = 2, p = 0, banned = [], k = 1\nOutput: [1]\nExplanation: The answer is [1], where the single 1 is set to the index 0.\nExample 3:\nInput: n = 7, p = 3, banned = [2,4], k = 2\nOutput: [-1,-1,3,-1,-1]\nExplanation: The operations take the index 0 to 3 or 4.\nThe index 1 is set to 1 at first operation, which is impossible.\nThe index 2 is set to 1 at third operation, which is impossible.\nExample 4:\nInput: n = 4, p = 0, banned = [3], k = 3\nOutput: [2]\nExplanation: The answer is [2], where the single 1 is set to the index 0.\nExample 5:\nInput: n = 5, p = 1, banned = [0], k = 2\nOutput: [-1]\nExplanation: The answer is [-1], as the index 1 is set to 1 in the first step.\nConstraints:\n1 <= n <= 105\n0 <= p < n\n0 <= banned.length <= 105\n0 <= banned[i] < n\n0 <= k <= n\n1 <= p - k < n - k\np - k != banned[i] for all i\np - k != banned[i] - 1 for all i\np -", "groundtruth": "class Solution {public:vector<int> minReverseOperations(int n, int p, vector<int> &banned, int k) {unordered_set<int> ban{banned.begin(), banned.end()};set<int> sets[2];for (int i = 0; i < n; ++i)if (i != p && !ban.count(i))sets[i % 2].insert(i);sets[0].insert(n);sets[1].insert(n); // 哨兵vector<int> ans(n, -1);vector<int> q = {p};for (int step = 0; !q.empty(); ++step) {vector<int> nq;for (int i: q) {ans[i] = step;// 从 mn 到 mx 的所有位置都可以翻转到int mn = max(i - k + 1, k - i - 1);int mx = min(i + k - 1, n * 2 - k - i - 1);auto &s = sets[mn % 2];for (auto it = s.lower_bound(mn); *it <= mx; it = s.erase(it))nq.push_back(*it);}q = move(nq);}return ans;}};"}