{"task_id": "cpp/0", "content": "'''\n\nclass Solution(object):\n    def lastNonEmptyString(self, input_string):\n        \"\"\"\n        :type input_string: str\n        :rtype: str\n        \"\"\"\n        char_frequency = {}\n        result = \"\" \n        unique_chars = set()\n        \n        for c in input_string:\n            if c in char_frequency:\n                char_frequency[c] += 1\n            else:\n                char_frequency[c] = 1\n\n        sorted_frequency = sorted(char_frequency.iteritems(), key=lambda x: x[1], reverse=True)\n\n        max_frequency = sorted_frequency[0][1]\n\n        for p in sorted_frequency:\n            if p[1] == max_frequency:\n                unique_chars.add(p[0])\n            if p[1] < max_frequency:\n                break\n\n        for i in xrange(len(input_string)-1, -1, -1):\n            if input_string[i] in unique_chars:\n                result += input_string[i]\n                unique_chars.remove(input_string[i])\n            if len(unique_chars) == 0:\n                break\n\n        result = result[::-1]\n        return result\n\nif __name__ == '__main__':\n    solution = Solution()\n    print solution.lastNonEmptyString('aabb')\n", "groundtruth": {"s": "aabcbbca"}}
{"task_id": "cpp/1", "content": "'''\n# Difficulty: Medium\n#9 / 9 test cases passed.\n#Runtime: 52 ms\n#Memory Usage: 31.6 MB\n\n#Runtime: 52 ms, faster than 36.69% of Python3 online submissions for Maximum Number of Coins You Can Get.\n#Memory Usage: 31.6 MB, less than 5.43% of Python3 online submissions for Maximum Number of Coins You Can Get.\n\nclass Solution:\n    def maxOperations(self, nums: List[int]) -> int:\n        length = len(nums)\n        nums.sort()\n        if nums[0] == nums[-1]:\n            return min(length//2, nums[0])\n        maximum = min(nums[0]+nums[-1], nums[length//2] + nums[length//2-1])\n        result = 0\n        for i in range(length-1, length//2-1, -1):\n            if nums[i] + nums[length-i-1] == maximum:\n                result += 1\n                maximum = max(nums[i] + nums[i-1], nums[i] + nums[length-i-2])\n        return result\n", "groundtruth": {"nums": [3, 2, 6, 1, 4]}}
{"task_id": "cpp/2", "content": "\nExample 1:\n\nInput: [3,5,7,8,12]\nOutput: 5\nExplanation: The subarray [3,5,7,8,12] has the longest possible length of 5.\nExample 2:\n\nInput: [5,8,11,13,15]\nOutput: 3\nExplanation: The subarray [5,8,11,13,15] has the longest possible length of 3.\nExample 3:\n\nInput: [9,13,15,18,23,28,30]\nOutput: 7\nExplanation: The subarray [9,13,15,18,23,28,30] has the longest possible length of 7.\n'''\n\nclass Solution(object):\n    def __init__(self):\n        self.ans = 0\n        self.dp = dict()\n        self.max = 0\n\n    def maxSelectedElements(self, nums):\n        sorted_nums = sorted(nums)\n        for i in range(1, len(sorted_nums)+1):\n            self.dp[sorted_nums[i-1]+1] = max(1, self.dp.get(sorted_nums[i-1]+1, 0)+1)\n            self.dp[sorted_nums[i-1]] = max(1, self.dp.get(sorted_nums[i-1]-1, 0)+1)\n            if self.dp[sorted_nums[i-1]] > self.max:\n                self.max = self.dp[sorted_nums[i-1]]\n            if self.dp[sorted_nums[i-1]+1] > self.max:\n                self.max = self.dp[sorted_nums[i-1]+1]\n        return self.max", "groundtruth": {"nums": [1, 4, 7, 10]}}
{"task_id": "cpp/3", "content": "\nSolution: [Solution: 3](https://leetcode.com/problems/longest-common-prefix/solution/solution/)\n\nFor each iteration, use the information from previous iteration if the answer is \"yes\" or \"no\".\n\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res = \"\";\n        if (strs.empty()) return res;\n        sort(strs.begin(), strs.end());\n        for (int i = 0; i < strs[0].size(); ++i) {\n            for (auto it = strs.begin(); it != strs.end(); ++it) {\n                if ((*it)[i] != strs[0][i]) {\n                    return res;\n                }\n            }\n            res += strs[0][i];\n        }\n        return res;\n    }\n};\n\nThe output is:\n2\nGive only the deduced input of the code snippet. Do not output any additional information.\n\nSolution: [Solution: 2](https://leetcode.com/problems/longest-common-prefix/solution/solution/)\n\nThe idea is similar to the idea from \"Find the Longest Common Substring\" solution 3\n\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        if (strs.empty()) return \"\";\n        string res = \"\";\n        int i = 0;\n        while (i < strs[0].size()) {\n            char ch = strs[0][i];\n            int j = 1;\n            while (j < strs.size()) {\n                if (strs[j].size() <= i || strs[j][i] != ch) {\n                    return res;\n                }\n                j++;\n            }\n            res += ch;\n            i++;\n        }\n        return res;\n    }\n};\n\nThe output is:\n3\nGive only the deduced input of the code snippet. Do not output any additional information.\n\nSolution: [Solution: 3](https://leetcode.com/problems/longest-common-prefix/solution/solution/)\n\npublic int longestCommonPrefix(String[] strs) {\n        int resLen = 0;\n        if (strs.length == 0) return resLen;\n        for (int i = 0; i < strs[0].length(); i", "groundtruth": {"arr1": [1, 10, 100], "arr2": [1000]}}
{"task_id": "cpp/4", "content": "\n'''\n\nclass Solution {\npublic:\n    \n    int isPrefixAndSuffix(string str1,string str2){\n        \n          if(str1.size()<=str2.size()){\n            int j=0,i=0;\n            while(i<str1.size()){ //&& j<str2.size()){\n             //   cout<< \"First while  str1[i] \" <<str1[i]<< \" str2[j] \" <<str2[j]<< endl;\n                if(str1[i++]!=str2[j++])\n                    return 0;\n                 if(i==str1.size())break;\n            }\n              \n            i=str1.size()-1;j=str2.size()-1;\n            while(i>=0){ //&& j>=str2.size()-str1.size()){\n                cout<< \"Second while str1[i] \" <<str1[i]<< \" str2[j] \" <<str2[j]<< endl;\n                if(str1[i--]!=str2[j--])\n                    return 0;\n                   if(i<0)break;\n            }\n           //   cout<< \"->>> ans  == 1  str1  \" << str1 <<  \" str2 \"<< str2<<  endl;\n              return 1;\n          }\n        return 0;\n        \n    }\n    \n    int countPrefixSuffixPairs(vector<string>& words) {\n        // sort(words.begin(),words.end());\n        int ans=0;\n        for(int i=0;i<words.size()-1;i++){\n            for(int j=i+1;j<words.size();j++){\n             // cout<< \"main func words[i] \" <<words[i]<< \" words[j] \" <<words[j]<< endl;\n                ans+=isPrefixAndSuffix(words[i], words[j]);\n                }\n            \n        }\n        return ans;\n    }\n};\n", "groundtruth": {"words": ["pa", "papa", "ma", "mama"]}}
{"task_id": "cpp/5", "content": "\nExample 1\nInput\n[[1,1,3,3,5,5,7,7]]\nOutput\n97\nExample 2\nInput\n[[1,3,5,7,9]]\nOutput\n-1\n'''\n\nfrom collections import deque\n\nclass Solution:\n    def mostFrequentPrime(self, v):\n        # Write your code here\n        mp={}\n        q=deque([(0,0)])\n        n,m=len(v),len(v[0])\n        while q:\n            x,y=q.popleft()\n            for dx,dy in [(1,0),(0,1),(-1,0),(0,-1)]:\n                if 0<=x+dx<n and 0<=y+dy<m and not v[x+dx][y+dy] and not mp.get(v[x+dx][y+dy],0):\n                    mp[v[x+dx][y+dy]]=mp.get(v[x+dx][y+dy],0)+1\n                    q.append((x+dx,y+dy))\n        \n        res=0\n        for i in mp:\n            if mp[i]>=res and self.prime(i):\n                res=mp[i]\n        if res==0:\n            return -1\n        mx=0\n        for i in mp:\n            if mp[i]==res:\n                mx=max(mx,i)\n        return mx\n    \n    def prime(self, n):\n        if n<2:\n            return False\n        for i in range(2, int(n**0.5)+1):\n            if n%i==0:\n                return False\n        return True\n\n", "groundtruth": {"mat": [[9, 7, 8], [4, 6, 5], [2, 8, 6]]}}
{"task_id": "cpp/6", "content": "'''\n\n\nclass Solution {\npublic:\n    int countPrefixSuffixPairs(vector<string>& words) {\n        map<string,int> mp;\n        int n=words.size();\n        long long ans=0;\n        for(int i=0 ; i<n  ; i++){\n            string s=words[i];\n            string w1=\"\";\n            string w2=\"\";\n            for(int j=0 ; j<words[i].size() ; j++){\n                w1+=words[i][j];\n                w2+=words[i][words[i].size()-1-j];\n                if(mp.count(w1)){\n                    string r=w2;\n                    reverse(r.begin(),r.end());\n                    if(r==w1){\n                        ans+=mp[w1];\n                    }\n                }\n            }\n            mp[s]++;\n        }\n        return ans;\n    }\n};\n", "groundtruth": {"words": ["pa", "papa", "ma", "mama"]}}
{"task_id": "cpp/7", "content": "Explanation:\nl2 = 1, r2 = 6\nl1 = 1, r1 = 6,\nl2 <= l1, r2 >= r1, return r1 - l1 = 0\nl1 <= l2, r1 >= r2, return r2 - l2 = 5\nl2 <= r1, r2 >= r1, return r1 - l2 = 0\nl2 <= r1, r2 >= l1, return r2 - l1 = 6\nSo, the largest square area is the 5 * 0 = 0, which is not the square of the output (1)\n'''\n\ndef getIntersection(l1, r1, l2, r2):\n    if l2 <= l1 and r2 >= r1: return r1 - l1\n    if l1 <= l2 and r1 >= r2: return r2 - l2\n    if l2 <= r1 and r2 >= r1: return r1 - l2\n    if l2 <= r1 and r2 >= l1: return r2 - l1\n    return 0\n\ndef largestSquareArea(bottomLeft, topRight):\n    ans = 0\n    for i in range(len(bottomLeft)):\n        for j in range(i + 1, len(topRight)):\n            x = getIntersection(bottomLeft[i][0], topRight[i][0], bottomLeft[j][0], topRight[j][0])\n            y = getIntersection(bottomLeft[i][1], topRight[i][1], bottomLeft[j][1], topRight[j][1])\n            ans = max(ans, min(x, y))\n    return ans * ans", "groundtruth": {"bottomLeft": [[1, 1], [2, 2], [1, 2]], "topRight": [[3, 3], [4, 4], [3, 4]]}}
{"task_id": "cpp/8", "content": "\nThe code snippet is:\nclass Solution {\npublic:\n    bool isPos(int moves, vector<int> &nums, vector<int> &changeIndices)\n    {\n       int n = nums.size();\n       int m = changeIndices.size();\n        \n        int count = 0;\n        int i = 0;\n        int prev = 0;\n        int k = 0;\n        while(i < m)\n        {\n            if(k == moves)\n            {\n                count += changeIndices[i] - prev + 1;\n                prev = changeIndices[i] + 1;\n                k = 0;\n            }\n            if(changeIndices[i] >= moves + prev)\n                return false;\n            prev = changeIndices[i];\n            i++;\n            k++;\n        }\n        return true;\n        \n        \n    }\n    int earliestSecondToMarkIndices(vector<int>& nums, vector<int>& changeIndices) {\n        int n = nums.size();\n        int m = changeIndices.size();\n        int lo = 1;\n        int hi = m;\n        while(lo < hi)\n        {\n            int mid = (lo + hi)/2;\n            if(isPos(mid, nums, changeIndices))\n                lo = mid;\n            else\n                hi = mid;\n        }\n        if(isPos(lo, nums, changeIndices))\n            return lo;\n        return -1;\n        \n    }\n};\n'''", "groundtruth": {"nums": [1, 3], "changeIndices": [1, 1, 1, 2, 1, 1, 1]}}
{"task_id": "cpp/9", "content": "\nYour submission will be judged based on the deduced input of the code snippet only. It is recommended to discuss the deduced input format on the forums, and post the solution in the corresponding subforum.\n# The Solution:\n\n## [Solution by me (the one with comments)](https://leetcode.com/problems/earliest-possible-day-of-full-bloom/discuss/643506/JavaC%2B%2BPython-Binary-Search-%2B-Greedy)\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def earliestFullBloom(self, tree: TreeNode) -> int:\n        nums = []\n        changeIndices = []\n        \n        def dfs(node, i):\n            if not node:\n                return\n            \n            if not node.left and not node.right:\n                nums.append(node.val)\n            else:\n                changeIndices.append(i)\n                dfs(node.left, 2*i+1)\n                dfs(node.right, 2*i+2)\n\n        dfs(tree, 0)\n        \n        lo, hi = 1, len(nums)\n        while lo < hi:\n            mid = (lo+hi)//2\n            # Check if it's possible to plant the same bloom on the \n            # `mid`-th index (i.e., all nodes with val==1 will be blooms).\n            # If it's possible then this `mid` is a valid answer, otherwise\n            # check the other half.\n            if all(num == 1 for num in nums[:mid]):\n                # It's possible, update the upper bound of the answer\n                hi = mid\n            else:\n                lo = mid+1\n        \n        # Now the upper bound of the answer is either the max number of\n        # blooms that we can plant or it's just the length of `nums`.\n        ans = lo\n        for i in changeIndices:\n            # Let's see if `i` is a valid index to plant the blooms. If we\n            # plant all blooms to the left of `i`, we still need to make\n            # sure that we have", "groundtruth": {"nums": [0, 0, 1, 2], "changeIndices": [1, 2, 1, 2, 1, 2, 1, 2]}}
{"task_id": "cpp/10", "content": "\nExample 2\nInput: grid = [[1,1,1],[1,1,0],[1,0,1]], k = 0\nOutput: 13\n\nExample 3\nInput: grid = [[9,1,2,1,1],[1,3,3,2,4],[2,2,2,3,3]], k = 3\nOutput: 24\nExplanation:\nWe calculate the histogram of row 0, row 1, and row 2.\nThe following rows are calculated similarly:\nRow 0: [9, 1, 2, 1, 1]. The largest sum is 9.\nRow 1: [1, 4, 6, 4, 5]. The largest sum is 6.\nRow 2: [2, 3, 3, 3, 4]. The largest sum is 4.\nThe 2 x 2 submatrix with the largest sum is:\n2 3\n3 4\n\"\"\"\nfrom typing import List\n\n\nclass Solution:\n    def countSubmatrices(self, grid: List[List[int]], k: int) -> int:\n        \"\"\"\n        Time complexity: O(N^3 * M^2)\n        Space complexity: O(M)\n        \"\"\"\n        rows = len(grid)\n        cols = len(grid[0])\n        sums = [[0] * cols for _ in range(rows)]\n\n        def prefix_sums(index, col_left, col_right):\n            if index < 0:\n                return 0\n            elif index == 0:\n                return sums[0][col_right]\n            elif col_left > col_right:\n                return sums[index][col_left]\n            else:\n                return sums[index][col_right] + sums[index][col_left] - sums[index - 1][col_right]\n\n        def max_rect_sum(row_left, row_right, col_left, col_right):\n            row_left, row_right = max(row_left, 0), min(row_right, rows - 1)\n            col_left, col_right = max(col_left, 0), min(col_right, cols - 1)\n\n            if row_right == row_left:\n                return prefix_sums(", "groundtruth": {"grid": [[7, 2, 9], [1, 5, 0], [2, 6, 6]], "k": 20}}
{"task_id": "cpp/11", "content": "\nThe code snippet says:\nThe matrix v[i][j] has value 1 if it is a black square and value 0 if it is a white square. Each black square occupies a white square. Each white square may be surrounded by black squares.\n\nYou need to find the smallest number of moves you need to erase the white squares that surround the black squares in the matrix.\n\nIt is guaranteed that at least one black square is surrounded by white squares. No two black squares are adjacent. No black squares are surrounded by another black square. All white squares are unoccupied.\n\nFor example, for the following matrix, you can erase the white squares in red lines to obtain the result.\n[0,1,1,1,0] -> [0,1,1,1,1]\n[1,1,1,1,1]\n[1,1,1,1,1]\n[1,1,1,1,1]\n[0,0,1,1,0] -> [0,0,1,1,1]\n\nNote\nTwo operations are considered as one move:\n\nErasing a black square.\nMoving the white square outside the matrix.\n'''\n'''\nclass Solution {\npublic:\n    int minimumOperationsToWriteY(vector<vector<int>>& v) {\n        int n = v.size();\n        int c1 = 0, c2 = 0;\n        vector<vector<int>> vis(n, vector<int>(n, 0));\n        fill(vis, v);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                if(vis[i][j]==1) {\n                    c1++;\n                }\n            }\n        }\n        c2 = n*n - 2*c1;\n        return min(c1, c2);\n    }\n};\n'''\n", "groundtruth": {"grid": [[0, 1, 0, 1, 0], [2, 1, 0, 1, 2], [2, 2, 2, 0, 1], [2, 2, 2, 2, 2], [2, 1, 2, 2, 2]]}}
{"task_id": "cpp/12", "content": "'''\n\nclass Solution(object):\n    def resultArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums.insert(0, 0)\n        nums.sort()\n        result=[]\n        result.append(nums[1])\n        result.append(nums[2])\n        return result+nums[3:]\n        \n", "groundtruth": {"nums": [5, 14, 3, 1, 2]}}
{"task_id": "cpp/13", "content": "\nExample 1\nInput:\n1 2 3 4 5 6 7 8 9\n3\nOutput:\n22\nExplanation:\nAt first we sort happ in ascending order then we deduce k = 3, we have these numbers in the following order:\n1 2 3 4 5 6 7 8 9\n7 6 5 4 3 2 1 0 -1\nSo we can get the happiness value of the last four students who get this number of hats.\nTheir happiness value is\n7 + 6 + 5 + 4 = 22.\nExample 2\nInput:\n-1 0 2\n1\nOutput:\n-2\nExplanation:\nWe have 3 students and their happiness value are\n-1 0 2\nWe just need to deduce k = 1. Then we can get the happiness value of the last two students who get this number of hats.\nTheir happiness value is\n0 + 2 = -2.\n\"\"\"\n", "groundtruth": {"happiness": [1, 1, 1, 1], "k": 2}}
{"task_id": "cpp/14", "content": "\n'''\n", "groundtruth": {"arr": ["abc", "bcd", "abcd"]}}
{"task_id": "cpp/15", "content": "\nThe given code snippet computes the maximum strength of a sequence of coin denominations using dynamic programming, a simple mathematical algorithm to optimize the computing process.\n\nThe algorithm starts at the beginning of the sequence and sets two variables to store the maximum subarray strength at each time point, for the case that the coin is not taken and for the case that it is taken.\n\nThe case that the coin is not taken is defined as to take the maximum strength of the first subarray of length k (K for short), because we need K coins to make up the whole subarray, instead of taking the maximum strength of any subarray of length (k+1).\n\nThe case that the coin is taken is defined as the sum of two values.\n\nThe first value is to take the maximum strength of the first subarray of length (p+1), the second value is to take the maximum strength of the first subarray of length p, all the while the coin is not taken.\n\nBoth of the values are the maximum of the two, because the maximum subarray strength always decreases when we take a coin.\n\nThe last step is to output the larger value of the two.\n\nThere are some problems in this problem that require you to think about the solution first and analyze it from many different perspectives, because the solution has such a strong influence on your thought process.\n\nAmong them, the most useful one is the mathematical proof of the algorithm.\n\nYou can use this type of proof to pass the coding interview, but the specifics of the proof will be different for different companies and for different rounds.\n\nI want to give you a general idea of how to think about the problem, instead of giving you a specific example.\n\nIf you want to use such a mathematical proof to prove your solution, you should first analyze what it is asking from you, then draw a tree diagram, then write down a mathematical proof from the tree diagram.\n\nIn our problem, our task is to tell the largest strength of the subarray when using the first k coins to complete the array.\n\nIf you are asked to find the largest strength of a subarray, it is easier to understand if you visualize the array and then look for the largest subarray.\n\nFor example, we have an array containing four elements and using three coins to take the largest subarray:\n\n 1,4,3,2\nThe maximum strength is 4", "groundtruth": {"nums": [12, -2, -2, -2, -2], "k": 5}}
{"task_id": "cpp/16", "content": "\nInput:\n[4,5,8,8,4,4,9,9,8,8,6,4,4,8,1,9,3,1,9,5,9,8,9,7,4,5,9,6,2,9,6,7,7,3,7,4,1,9,5,6,5,9,3,4,3,9,4,8,8,4,5,8,9,4,4,2,9,8,8,4,9,1,8,2,3,2,9,3,3,4,8,7,8,9,2,6,9,9,6,9,4,2,9,2,8,7,9,3,3,5,3,9,6,7,7,9,3,5,7,4,9,2,5,9,8,2,2,2,9,7,8,9,2,7,8,6,5,6,5,2,9,7,2,8,4,8,9,1,3,4,3,3,5,3,9,3,5,8,3,3,9,3,9,9,8,8,8,7,6,5,7,6,8,3,1,3,5,5,7,8,9,2,6,6,5,6,6,3,2,5,7,9,6,8,7,2,6,2,6,4,9,7,5,9,8,1,9,8,4,2,8,3,4,8,1,9,5,8,1,2,8,9,7,8,8,4,8,9,2,8,1,8,8,4,6,8,1,9,7,3,3,1,1,9,1,3,1,5,5,9,6,9,5,9,6,9,3,4,5,5,7,2,8,2,9,2,9,4,2,8,2,6,5,8", "groundtruth": {"nums": [1, 4, 2, 3], "queries": [[0, 1]]}}
{"task_id": "cpp/17", "content": "\nSolution:- https://www.hackerearth.com/practice/basic-programming/input-output/basics-of-input-output/practice-problems/algorithm/little-boy-s-dream-1/description/\n\n\"\"\"\n\nimport sys\n\n#time taken :- 23 seconds\n\n\nT = int(input())\n\nfor _ in range(T):\n\tn = input()\n\tl = [0] * 26\n\n\tfor i in n:\n\t\tif i != '?':\n\t\t\tl[ord(i) - ord('a')] += 1\n\n\ti = 0\n\tdum = \"\"\n\tn = list(n)\n\n\twhile i < len(n):\n\t\tif n[i] == '?':\n\t\t\tc = 1\n\t\t\tj = 0\n\t\t\tmin = 25\n\t\t\t\n\t\t\twhile j < 26:\n\t\t\t\tif l[j] < c:\n\t\t\t\t\tc = l[j]\n\t\t\t\t\tmin = j\n\t\t\t\tj += 1\n\n\t\t\tl[min] += 1\n\t\t\tdum += chr(min + ord('a'))\n\t\ti += 1\n\n\tdum.sort()\n\tj = 0\n\tfor i in range(len(n)):\n\t\tif n[i] == '?':\n\t\t\tn[i] = dum[j]\n\t\t\tj += 1\n\n\tprint(\"\".join(n))", "groundtruth": {"s": "a?a?"}}
{"task_id": "cpp/18", "content": "\nExample:\nInput: \nnums = [1,2,3,4]\nk = 5\n\nOutput:\n3\n'''\n\n# 2018-9-15\n# 1580. Put Boxes Into the Warehouse I\n# https://leetcode.com/problems/put-boxes-into-the-warehouse-i/\n\n# 思路\n# 如果没有进货，那肯定没有发货（没有进货，则无法再发货）\n# 如果有进货，则有可能发货，又因为发货数量无限，又需要消耗进货，所以总是发满（没有空闲的货位了，必然可以发满）\n\nclass Solution:\n    def numBoxes(self, boxes):\n        \"\"\"\n        :type boxes: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(boxes)\n        if not n: return 0\n\n        boxes = sorted(boxes)\n\n        start = 0\n        end = 0\n        res = 0\n        while end < n:\n            if end == start:\n                # 没有进货，那么发货肯定没有了\n                # 所以end无限变大，start也无限变大，无法发货\n                end += 1\n            else:\n                total = boxes[end] - boxes[start]\n\n                j = end - 1\n                while j >= start:\n                    if boxes[j] > total - boxes[j] + boxes[start]:\n                        break\n                    j -= 1\n                end = j\n\n                res += end - start + 1\n            # 无论发了多少个，无论发了多少个，都要让end+1，保证发货可以继续发货\n            end += 1\n\n        return res\n\n# test\ns = Solution()\n# print(s.numBoxes([1,2,3,4]))\n\n## test1\n# n = 3\n# boxes = [2,2]\n# [2,2] [2] [3]\n# \n# [2,2] [2,2,2]\n# 2\n# boxes = [2,2,2]\n# [2,2,2]\n# [2,2] [2] [3]\n\n# [2,2]", "groundtruth": {"nums": [1, 2, 3], "k": 3}}
{"task_id": "cpp/19", "content": "\"\"\"\n__author__ = '<NAME>'\n__email__ = '<EMAIL>'\n__date__ = '1/8/2021 9:32 PM'\n\n\nclass Solution:\n    def countSubstrings(self, s: str, c: str) -> int:\n        cnt = 0\n        if c == s[0]: cnt += 1\n        if c == s[-1]: cnt += 1\n\n        res = 0\n        for i in range(1, len(s)):\n            if c == s[i]:\n                cnt += 1\n            res += cnt\n            if c == s[i - 1]:\n                cnt -= 1\n        return res\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.countSubstrings(s, 'r'))\n", "groundtruth": {"s": "zzz", "c": "z"}}
{"task_id": "cpp/20", "content": "'''\n\n'''\nThis is actually a dynamic programming question. Consider the case:\naaabbbcccd -> aaaaabbccccd\nThen after removing the last 'c', we will have:\naaaabbcccc -> aaaabbbbcccc\nBut there are more choices of the second 'b' to be removed than the last 'c'.\nThus we can compute:\ndp[i] is the minimum number of deletions to transform word[:i + 1] into a valid word.\ndp[i + 1] = 1 + min(dp[j] where cnt[j] + k > cnt[i + 1]) for all j such that word[:j] is a valid word.\nAt the end we return dp[-1]\n'''\n\n\nclass Solution:\n    def minimumDeletions(self, word, k):\n        cnt = [0 for _ in range(26)]\n        for c in word:\n            cnt[ord(c) - ord('a')] += 1\n        \n        dp = [0 for _ in range(len(word))]\n        for i in range(len(word) - 1, -1, -1):\n            dp[i] = 1e9\n            for j in range(i, 26):\n                if cnt[j] + k > cnt[i]:\n                    dp[i] = min(dp[i], dp[j] + 1)\n        \n        return dp[0]\n", "groundtruth": {"word": "dabdcbdcdcd", "k": 2}}
{"task_id": "numpy/0", "content": "'''\n\n'''\n[1, 3, 5, 2, 4, 6]\n'''\n\n\n'''\nSolution \n'''\nimport numpy as np\n\ndef reshape_and_transpose(arr):\n    reshaped_arr = np.reshape(arr, (3, 2))\n    transposed_arr = np.transpose(reshaped_arr)\n    return transposed_arr\n\nprint(reshape_and_transpose([1, 3, 5, 2, 4, 6]))", "groundtruth": [1, 2, 3, 4, 5, 6]}
{"task_id": "numpy/1", "content": "\nHence, deducing the input can be:\n\nstack_and_split(np.array([1,2,3,4]),np.array([5,6,7,8]))\n\nReferences\n1. https://realpython.com/numpy-ndarray/#hstack\n2. https://numpy.org/doc/stable/reference/generated/numpy.hstack.html\n3. https://stackoverflow.com/questions/8370204/how-to-use-split-in-numpy\n\"\"\"\n\nimport numpy as np\n\ndef stack_and_split(arr1, arr2):\n    stacked_arr = np.hstack((arr1, arr2))\n    split_arr1, split_arr2 = np.split(stacked_arr, 2, axis=1)\n    return (split_arr1, split_arr2)\n\nprint(stack_and_split(np.array([1,2,3,4]),np.array([5,6,7,8])))\n", "groundtruth": [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]}
{"task_id": "numpy/2", "content": "\"\"\"\n\n\nclass NumpyTranspose:\n    def __init__(self, shape):\n        self.shape = shape\n        self.arr = np.random.randint(10, size=shape)\n\n    def expand_transpose_squeeze(self):\n        self.result = np.transpose(np.squeeze(np.expand_dims(self.arr, axis=0), axis=3), axis=(1, 2, 0))\n\n\ndef solution(arr):\n    expanded_arr = np.expand_dims(arr, axis=0)\n    transposed_arr = np.transpose(expanded_arr, (0, 2, 1, 3))\n    squeezed_arr = np.squeeze(transposed_arr)\n    return squeezed_arr\n\n\ndef main():\n    test_case1 = NumpyTranspose(shape=(2, 4))\n    test_case1.expand_transpose_squeeze()\n\n    assert np.array_equal(\n        test_case1.result,\n        solution(test_case1.arr)\n    )\n\n\nif __name__ == '__main__':\n    main()", "groundtruth": [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]}
{"task_id": "numpy/4", "content": "'''\n\n# [input] array.array.integer arr1\n\n# [input] array.array.integer arr2\n\n# [output] integer\nimport numpy as np\n\ndef concat_and_product(arr1, arr2):\n    combined_arr = np.vstack((arr1, arr2))\n    product = np.prod(combined_arr)\n    return product\n\n# combined_arr = np.vstack((arr1, arr2))  --> [(1, 2, 3), (4, 5, 6)]\n# product = np.prod(combined_arr) --> product = np.prod([(1, 2, 3), (4, 5, 6)]) --> product = 720 = 1*2*3*4*5*6\n# return product --> output is 720\n\n\ndef concat_and_product_improved(arr1, arr2):\n    combined_arr = np.vstack((arr1, arr2))\n    product = np.prod(combined_arr, axis = 0)\n    return product\n\n# combined_arr = np.vstack((arr1, arr2))  --> [(1, 2, 3), (4, 5, 6)]\n# product = np.prod(combined_arr) --> product = np.prod([(1, 2, 3), (4, 5, 6)])\n# product_2d = np.prod(combined_arr, axis = 0) --> product_2d = np.prod([(1, 2, 3), (4, 5, 6)], axis = 0)  --> product_2d = (720, 120, 2160)\n# product = product_2d[0] --> product = 720\n# return product --> output is 720\n", "groundtruth": [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]}
{"task_id": "numpy/5", "content": "\n'''\n\nimport numpy as np\n\ndef create_exp_rounded(start, stop, num):\n    lin_arr = np.linspace(start, stop, num)\n    exp_arr = np.exp(lin_arr)\n    rounded_arr = np.round(exp_arr, 2)\n    return rounded_arr\n\nprint(create_exp_rounded(1, 5, 5))\n", "groundtruth": [0, 1, 5]}
{"task_id": "numpy/6", "content": "\nExample:\nFor a = [[[1, 2, 3, 4, 5, 6]]], the output should be\nreshaping_and_transposing(a) = [[1], [2], [3]].\n\"\"\"\n\n\"\"\"\ndef reshaping_and_transposing(a):\n\n    reshaped_a = np.reshape(a, (3, 2))\n    transposed_a = np.transpose(reshaped_a)\n\n    return transposed_a\n\"\"\"\n\n\ndef reshaping_and_transposing(a):\n    a = np.reshape(np.transpose(a), (3, 2))\n\n    return a\n", "groundtruth": [1, 2, 3, 4, 5, 6]}
{"task_id": "numpy/7", "content": "'''\nimport numpy as np\n\ndef stack_and_split(arr1, arr2):\n    stacked_arr = np.hstack((arr1, arr2))\n    split_arr1, split_arr2 = np.split(stacked_arr, 2, axis=1)\n    return (split_arr1, split_arr2)\n\narr1 = np.array([[1, 2], [3, 4]])\narr2 = np.array([[5, 6], [7, 8]])\nres = stack_and_split(arr1, arr2)\nprint(res)\n# [[[ 1  2]\n#   [ 3  4]]\n\n#  [[ 5  6]\n#   [ 7  8]]]\n\n'''\nInput of np.hstack:\n\nnumpy.hstack(tup)\n\nHorizontal stack function for NumPy arrays.\n\nThis is equivalent to concatenation along the second axis, except for 1-D arrays where it concatenates along the first axis. Rebuilds arrays divided by split.\n\nParameters:\ttup : Sequence of arrays. This tuple must have the same shape, except in the dimension corresponding to axis (the first, by default).\n\nReturns:\tThe concatenation of the input arrays.\n'''\n'''\nInput of np.split:\n\nnumpy.split(ary, indices_or_sections, axis=0)\n\nSplit an array into multiple sub-arrays.\n\nParameters:\tary : Array to be divided into sub-arrays. axis : Axis along which to split, default is 0. If axis is None, the array is flattened before splitting along axis. If axis is negative, the axis to split along is found by counting from the last to the first axis. indices_or_sections : If axis is an integer, indices_or_sections is the number of equal sized sub-arrays. If axis is a 1-D array, indices_or_sections is a list of relative locations along axis in the array where the division is performed. The endpoints of the sub-arrays do not need to match the breakpoints. In this case, if the breakpoints do not match the array shape, an error is raised.\n\nReturns:\tsub-arrays\n'''", "groundtruth": [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]}
{"task_id": "numpy/8", "content": "\nHint:\nTry to use the NumPy documentation.\n'''\nimport numpy as np\n\ndef expand_transpose_squeeze(arr):\n    expanded_arr = np.expand_dims(arr, axis=0)\n    transposed_arr = np.transpose(expanded_arr, (0, 2, 1, 3))\n    squeezed_arr = np.squeeze(transposed_arr)\n    return squeezed_arr\n\nif __name__ == \"__main__\":\n    a = [[1, 5], [3, 7], [2, 6], [4, 8]]\n    b = expand_transpose_squeeze(a)\n    print(b)\n\n'''\nExplanation:\nimport numpy as np\n\ndef expand_transpose_squeeze(arr):\n    expanded_arr = np.expand_dims(arr, axis=0)\n    transposed_arr = np.transpose(expanded_arr, (0, 2, 1, 3))\n    squeezed_arr = np.squeeze(transposed_arr)\n    return squeezed_arr\nThe array \"a\" has two dimensions.\nAfter np.expand_dims(arr, axis=0), a becomes a one-dimensional array.\nAfter np.transpose(expanded_arr, (0, 2, 1, 3)), the dimension becomes (1,2,2,1).\nAfter np.squeeze(transposed_arr), a becomes an array with 4 dimensions.\nHence, the output is:\n[[[1, 5], [3, 7]], [[2, 6], [4, 8]]]\n'''\n", "groundtruth": [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]}
{"task_id": "numpy/9", "content": "'''\narr1 = np.array([0, 1, 2])\narr2 = np.array([3, 4, 5])\narr3 = np.array([6, 7, 8])\nconstant = 1\n\nresult = np.add(arr1, arr2)\nprint(result)\n\nresult = np.subtract(result, constant)\nprint(result)\n\nfinal_result = np.multiply(result, arr3)\nprint(final_result)", "groundtruth": [[2, 4, 6], [1, 3, 5], [7, 9, 11], 5]}
{"task_id": "numpy/10", "content": "'''\nimport numpy as np\n\ndef power_sum(arr1, arr2):\n    powered_arr = np.power(arr1, arr2)\n    result_sum = np.sum(powered_arr)\n    return result_sum\n\nprint (power_sum(np.array([2, 3, 4]), np.array([4, 5, 6])))\n", "groundtruth": [[2, 3, 4], [1, 2, 3]]}
{"task_id": "numpy/11", "content": "\ndef det_and_inv(matrix):\n    determinant = np.linalg.det(matrix)\n    if determinant == 0:\n        return 'Matrix is singular, cannot compute inverse.'\n    else:\n        inverse = np.linalg.inv(matrix)\n        return determinant, inverse\nimport numpy as np\nnp.set_printoptions(precision = 1)\n\n# Test\nA = np.array([[2,3],[5,8]])\nprint(det_and_inv(A))\n\n# A = np.array([[2,3,5],[5,8,6]])\n# print(det_and_inv(A))", "groundtruth": [[2, 6], [4, 7]]}
{"task_id": "numpy/12", "content": "\nx1 = np.array([[ 1,  0, -1], [-3, -7,  6], [ 2, -3,  4]])\nx2 = np.array([[ 1, -5,  0], [ 2, -4,  1], [ 1,  7,  2]])\nx3 = np.array([[ 2,  1,  3], [-2,  7,  2], [ 2,  1, -8]])\n\nprint(sum_multiply_det(x1, x2, x3))\n\n'''\n", "groundtruth": [[[1, 2], [3, 4]], [[1, 0], [0, 1]], [[2, 0], [0, 2]]]}
{"task_id": "numpy/13", "content": "#Given a list of numbers and a number k, divide the list into k consecutive sublists.\n\nThe list has at least k elements and the lengths of the sublists are all equal.\n\nThe goal of this function is to split a list into k parts, and each element in the list belongs to one and only one sublist.\n\nThe division process is similar to the merging process.\n\nExample:\n\ninput: k=5, arr=[1,2,3,4,5,6,7,8,9,10]\n\noutput: [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]\n\nThis problem can be easily solved by using the built-in functions.\n\ndef split(k, arr):\n    return [arr[i::k] for i in range(k)]\nPlease do not change the above code, and you should not import any library.\n'''\n\ndef split_median(arr):\n    half = len(arr) // 2\n    median_first_half = sorted(arr[:half])\n    median_second_half = sorted(arr[half:])\n    return median_first_half, median_second_half\n\nif __name__ == '__main__':\n    #These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert split_median([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == ([3, 4, 5, 6, 7], [1, 2, 8, 9, 10])\n    assert split_median([1, 2, 3, 4, 5, 6, 7, 8, 9]) == ([3, 4, 5, 6], [1, 2, 7, 8, 9])\n    assert split_median([1, 2, 3, 4, 5, 6, 7, 8]) == ([3, 4, 5], [1, 2, 6, 7, 8])\n    print('\"Run\" is good. How is \"Check\"?')\n", "groundtruth": [9, 3, 5, 1, 8, 7]}
{"task_id": "numpy/14", "content": "\n'''\n#%%\n'''\nMethod 1\n'''\n# %%\nimport numpy as np\n\ndef min_max_masked(arr, threshold):\n    min_val = np.min(arr)\n    max_val = np.max(arr)\n    min_index = np.argmin(arr)\n    max_index = np.argmax(arr)\n    mask = arr >= threshold\n    masked_arr = np.ma.masked_array(arr, ~mask)\n    return min_val, max_val, min_index, max_index, masked_arr\n\na = min_max_masked(np.array([4, 8, 6, 7, 9, 1]), 6)\nprint(a)\n\n# %%\n'''\nMethod 2\n'''\n# %%\nimport numpy as np\n\ndef min_max_masked(arr, threshold):\n    min_val = np.min(arr)\n    max_val = np.max(arr)\n    min_index = np.argmin(arr)\n    max_index = np.argmax(arr)\n    mask = arr >= threshold\n    masked_arr = np.ma.masked_array(arr, ~mask)\n    return min_val, max_val, min_index, max_index, masked_arr\n\nprint(np.ma.masked_array([4, 8, 6, 7, 9, 1], [False, False, True, False, False, False]))\nprint(np.ma.masked_array([4, 8, 6, 7, 9, 1], [False, False, True, False, False, True]))\nprint(np.ma.masked_array([4, 8, 6, 7, 9, 1], [False, True, True, False, False, True]))\n\n# %%\n'''\nMethod 3\n'''\n# %%\nimport numpy as np\n\ndef min_max_masked(arr, threshold):\n    min_val = np.min(arr)\n    max_val = np.max(arr)\n    min_index = np.argmin(arr)\n    max_index = np.argmax(arr)\n    mask = arr >= threshold\n    masked_arr = np.ma.masked_array(arr, ~mask)", "groundtruth": [4, 8, 1, 7, 3, 9, 2]}
{"task_id": "numpy/15", "content": "\n'''\n# Please fill the correct input of the following code snippet: \nimport numpy as np\n\ndef normalized_variance_and_extreme_median(arr):\n    normalized_arr = (arr - np.mean(arr)) / np.std(arr)\n    variance_val = np.var(normalized_arr)\n    extreme_median = np.median([np.max(arr), np.min(arr)])\n    return variance_val, extreme_median\n", "groundtruth": [5, 10, 15, 20, 25]}
{"task_id": "numpy/16", "content": "\nInput format\nThe input format is one number on each line separated by space.\n\nOutput format\nOutput one single number.\n\nConstraints:\nn=10\nmin_val=0\nmax_val=100\n\nSample Input 0\n10\n0\n100\nSample Output 0\n19\n\nExplanation 0\nThe numpy package is imported.\nThe function filter_between is called.\nmin_val=0 and max_val=100. The code snippet uses logical_and to generate the array.\nThe elements of the array are passed into np.sum to return the sum.\nSample Input 1\n3\n30\n40\nSample Output 1\n120\nExplanation 1\nThe numpy package is imported.\nThe function filter_between is called.\nmin_val=30 and max_val=40. The code snippet uses logical_and to generate the array.\nThe elements of the array are passed into np.sum to return the sum.\n'''\nimport numpy as np\n\n# define a function\ndef filter_between(arr, min_val, max_val):\n    filtered_arr = arr[np.logical_and(arr > min_val, arr < max_val)]\n    return np.sum(filtered_arr)\n\n# input number of testcases\nn = int(input())\n\n# iterate through testcases\nfor i in range(n):\n    # input min_val and max_val\n    min_val = int(input())\n    max_val = int(input())\n\n    # call the function and input\n    arr = []\n    for i in range(10):\n        num = int(input())\n        arr.append(num)\n    \n    # pass in arr, min_val and max_val and get output\n    result = filter_between(arr, min_val, max_val)\n\n    # print result\n    print(result)", "groundtruth": [[1, 2, 3, 4, 5, 6], 2, 5]}
{"task_id": "numpy/17", "content": "\nHints:\nnp.where()\nnp.logical_or()\n'''\n#%%\n'''\nAnswer:\n\nimport numpy as np\n\ndef replace_and_find_eq(arr, replace_val, find_val1, find_val2):\n    modified_arr = np.where(arr < replace_val, -1, arr)\n    result = modified_arr[np.logical_or(modified_arr == find_val1, modified_arr == find_val2)]\n    return modified_arr, result\n\narr = np.array([5, 7, 6, 5, 4, 3, 2, 1])\nfind_val1 = 5\nfind_val2 = 6\nreplace_val = 4\n\nreplace_and_find_eq(arr, replace_val, find_val1, find_val2)\n'''", "groundtruth": [[3, 6, 1, 9, 3, 6], 4, 3, 9]}
{"task_id": "numpy/18", "content": "\n'''", "groundtruth": [[2, 4, 6, 8, 10], 4, 8]}
{"task_id": "numpy/19", "content": "\"\"\"\n\n\n# The code snippet is:\nimport numpy as np\n\ndef fft_and_ifft(arr):\n    fft_result = np.fft.fft(arr)\n    ifft_result = np.fft.ifft(fft_result)\n    absolute_values = np.abs(ifft_result)\n    return absolute_values\n\n# The output is:\n# [2.0, 6.0, 4.0, 7.0, 3.0, 1.0]\n\n# The input of the above code is:\n# np.array([0,1,2,3,4,5])\n\n\n# Note that:\n# import numpy as np\n# def fft_and_ifft(arr):\n#     fft_result = np.fft.fft(arr)\n#     ifft_result = np.fft.ifft(fft_result)\n#     absolute_values = np.abs(ifft_result)\n#     return absolute_values\n# print(fft_and_ifft(np.array([0,1,2,3,4,5])))\n# print(np.fft.fft(np.array([0,1,2,3,4,5])))\n# print(np.fft.ifft(np.fft.fft(np.array([0,1,2,3,4,5]))))\n# print(np.abs(np.fft.ifft(np.fft.fft(np.array([0,1,2,3,4,5])))))\n\n\n\n# [2.0+0.j, 6.0+0.j, 4.0+0.j, 7.0+0.j, 3.0+0.j, 1.0+0.j]\n# [2.0+0.j, 6.0+0.j, 4.0+0.j, 7.0+0.j, 3.0+0.j, 1.0+0.j]\n# [-2.56000000e-01+4.83594254e-17j  2.00000000e+00+1", "groundtruth": [2, 6, 4, 7, 3, 1]}
{"task_id": "numpy/20", "content": "Example:\ndeduce the input of the code snippet above. Then copy and paste this input to the text box.\n'''\nimport numpy as np\n\ndef fft_2d_shift(arr):\n    fft_result = np.fft.fft2(arr)\n    shifted_fft = np.fft.fftshift(fft_result)\n    inv_shifted_fft = np.fft.ifftshift(shifted_fft)\n    ifft_result = np.fft.ifft2(inv_shifted_fft)\n    absolute_values = np.abs(ifft_result)\n    return absolute_values\n", "groundtruth": [[2, 6, 4], [7, 3, 1], [5, 8, 9]]}
{"task_id": "numpy/21", "content": "\n\"\"\"\n#\n# The code snippet is:\nimport numpy as np\n\ndef fft_high_pass_filter(arr, threshold):\n    fft_result = np.fft.fft(arr)\n    fft_result[np.abs(fft_result) < threshold] = 0\n    ifft_result = np.fft.ifft(fft_result)\n    filtered_values = np.abs(ifft_result)\n    return filtered_values\n\nresult = fft_high_pass_filter([0.0, 1.0, 0.0, 1.0, 0.0, 0.0], 1)\nprint(result)", "groundtruth": [[2, 6, 4, 7, 3, 1], 5]}
{"task_id": "numpy/22", "content": "'''\n\n\nimport numpy as np\n\ndef sort_and_find_indices(arr):\n    sorted_arr = np.sort(arr)\n    max_index = np.argmax(sorted_arr)\n    min_index = np.argmin(sorted_arr)\n    return {'sorted_array': sorted_arr, 'max_index': max_index, 'min_index': min_index}\n", "groundtruth": [2, 6, 4, 7, 3, 1]}
{"task_id": "numpy/23", "content": "\nHints:\n1. The code snippet above first sorts the array along a particular axis, then finds all non-zero values and stores the sorted array and the non-zero values' positions separately.\n'''\n\n", "groundtruth": [[0, 6, 4], [7, 0, 1], [5, 3, 0]]}
{"task_id": "numpy/24", "content": "The input can be any list, arr1, arr2, sorted_arr, and the output is a dictionary.\n'''\ndef concatenate_sort_searchsorted(arr1, arr2, value):\n    concatenated_arr = np.concatenate((arr1, arr2))\n    sorted_arr = np.sort(concatenated_arr)\n    insert_index = np.searchsorted(sorted_arr, value)\n    return sorted_arr\nconcatenate_sort_searchsorted(arr1, arr2, value)\n", "groundtruth": [[2, 6, 4], [7, 3, 1], 5]}
{"task_id": "numpy/25", "content": "'''\n# import numpy as np\n\n# def combine_clip_round(arr1, arr2, min_val, max_val, decimals):\n#     combined_arr = np.concatenate((arr1, arr2))\n#     unique_arr = np.unique(combined_arr)\n#     clipped_arr = np.clip(unique_arr, min_val, max_val)\n#     rounded_arr = np.round(clipped_arr, decimals=decimals)\n#     return rounded_arr\n\n# print(combine_clip_round(np.array([2, 2.1, 3, 3.5, 3.8]), np.array([2.5, 4.3, 5, 4.9]), min_val = 2, max_val = 5, decimals = 1))\n\n'''\nAnswer:\n\narr1 = np.array([2, 2.1, 3, 3.5, 3.8])\narr2 = np.array([2.5, 4.3, 5, 4.9])\n\nround(unique_arr, 1)\n'''", "groundtruth": [[1.1, 2.5, 3.8], [2.5, 4.9, 6.2], 2, 5, 1]}
{"task_id": "numpy/26", "content": "\n\"\"\"\n\n#Import the array-generating function from NumPy\nfrom numpy import array\n\n#Generate an array from which to make the set:\narray1 = array([1,2,3,4,5,6,7,8])\nprint(\"Array 1 is:\", array1)\n\n#Generate a second array from which to make the set:\narray2 = array([8,7,6,5,4,3,2,1])\nprint(\"Array 2 is:\", array2)\n\n#Concatenate the array from which to make the set with the array that was used to generate it\nconcatenated = array1+array2\nprint(\"Concatenated array is:\", concatenated)\n\n#Get the unique elements of the set:\nunique = np.unique(concatenated)\nprint(\"Unique array is:\", unique)", "groundtruth": [[1, 2, 3], [3, 4, 5]]}
{"task_id": "numpy/27", "content": "\"\"\"\n\n", "groundtruth": [[7, 7.5, 3, 1.2, 9], [6.5, 10, 3, 7, 1.2], 2, 8]}
{"task_id": "java/0", "content": "\"\"\"\nclass Solution:\n    \"\"\"\n    @param nums: an array of Integer\n    @param target: target = nums[index1] + nums[index2]\n    @return: [index1 + 1, index2 + 1] (index1 < index2)\n    \"\"\"\n    def twoSum(self, nums, target):\n        # Write your code here\n        if not nums or len(nums) < 2:\n            return [-1, -1]\n\n        dic = {}\n        for i, n in enumerate(nums):\n            if target - n in dic:\n                return [dic[target - n], i]\n            dic[n] = i\n\n        return [-1, -1]", "groundtruth": {"nums": [2, 7, 11, 15], "target": 9}}
{"task_id": "java/1", "content": "\nExample:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n'''\n\n'''\nRuntime: 41 ms\nMemory Usage: 22 MB\n'''\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        n = len(nums)\n        for i in range(n):\n            complement = target - nums[i]\n            for j in range(i+1, n):\n                if nums[j] == complement:\n                    return [i, j]\n\n\n'''\nRuntime: 52 ms, faster than 81.09% of Python3 online submissions for Two Sum.\nMemory Usage: 24.1 MB, less than 17.75% of Python3 online submissions for Two Sum.\n'''\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        numMap = {}\n        n = len(nums)\n        for i in range(n):\n            if nums[i] in numMap:\n                return [i, numMap[nums[i]]]\n            numMap[target - nums[i]] = i\n\n\n'''\nRuntime: 36 ms, faster than 98.13% of Python3 online submissions for Two Sum.\nMemory Usage: 19.1 MB, less than 99.39% of Python3 online submissions for Two Sum.\n'''\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        numMap = {}\n        for i in range(len(nums)):\n            if target - nums[i] in numMap:\n                return [i, numMap[target - nums[i]]]\n            numMap[nums[i]] = i\n", "groundtruth": {"nums": [2, 7, 11, 15], "target": 9}}
{"task_id": "java/2", "content": "'''\n\n# The is a very intuitive question.\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n\n        p = dummy = ListNode(0)\n        carry = 0\n\n        while l1 or l2 or carry:\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n\n            p.next = ListNode(carry % 10)\n            p = p.next\n            carry /= 10\n\n        return dummy.next\n\n\n", "groundtruth": {"nums": [2, 7, 11, 15], "target": 9}}
{"task_id": "java/3", "content": "\n\"\"\"\nclass Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n\n        \"\"\"\n        Method 1: Stack\n\n        * Push first k elements into the stack and append the first element on the result array\n        * If the element at the top of the stack is not in the valid range, pop the top element from the stack\n        and append it on the result array. Keep doing this, till the stack is empty, or the top element is not out of the valid range\n\n        Your runtime beats 95.63 % of python submissions.\n        \"\"\"\n\n        if len(nums) == 0:\n            return None\n\n        stack = []\n        window_start = 0\n\n        result = []\n\n        for window_end in range(len(nums)):\n\n            if window_end >= k:\n                if stack[0] == window_start:\n                    stack.pop(0)\n                window_start += 1\n\n            while stack and nums[stack[-1]] < nums[window_end]:\n                stack.pop()\n            stack.append(window_end)\n\n            if window_end >= k - 1:\n                result.append(nums[stack[0]])\n\n        return result", "groundtruth": {"nums": [1, 3, -1, -3, 5, 3, 6, 7], "k": 3}}
{"task_id": "java/4", "content": "\nExample\nExample 1\nIf the input is:\n[[1,2],[2,3],[3,4],[3,1],[2,3],[1,2]]\nThe output is:\n48\n\"\"\"\n\n\n# Version 1.0:\n# Brute Force\nclass Solution:\n    \"\"\"\n    @param dimensions: the coordinates of the buildings\n    @return: find the maximum area\n    \"\"\"\n\n    def findMaxArea(self, dimensions):\n        # Write your code here\n        def helper(i):\n            temp_list = []\n            while i < len(dimensions):\n                width, length = dimensions[i]\n                for j in range(i+1, len(dimensions)):\n                    if width * length < dimensions[j][0] * dimensions[j][1]:\n                        break\n                temp_list.append((i, j))\n                i = j\n            return temp_list\n\n        list_diag = helper(0)\n        area_list = []\n        for (i, j) in list_diag:\n            width, length = dimensions[i]\n            for k in range(i+1, j):\n                width2, length2 = dimensions[k]\n                if width + width2 <= length and length2 < length:\n                    area = width * length + width2 * length2\n                    area_list.append(area)\n\n        return max(area_list)\n\n    \"\"\"\n    @param dimensions: the coordinates of the buildings\n    @return: find the maximum area\n    \"\"\"\n\n    def findMaxArea(self, dimensions):\n        # Write your code here\n        area_list = []\n        for i in range(len(dimensions)):\n            width, length = dimensions[i]\n            area_list.append(max(width*length, area_list[i-1] if i>0 else 0))\n\n        maxArea = max(area_list)\n        return maxArea\n\n\n# Version 2.0:\n# Brute Force Optimized\nclass Solution:\n    \"\"\"\n    @param dimensions: the coordinates of the buildings\n    @return: find the maximum area\n    \"\"\"\n\n    def findMaxArea(self, dimensions):\n        max_area = 0\n        for width, length in dimensions:\n            max_area = max(max_area, (width*length)*(width*length))\n            for i in range(length):\n                max_area = max(max_area, (width*length)*(i*", "groundtruth": [[9, 3], [8, 6]]}
{"task_id": "java/5", "content": "\nNote that you need to know the rules of chess game. Otherwise it is hard for you to find the solution.\n\nThis problem is an extension of a normal problem. Normal chess queen cannot go through a\nking. In a normal chess game, a rook can move on 1 row. A bishop can move in\ndiagonal lines and a king can move in any direction.\n\nFor the chess queen to move through a king, it may move on 2 rows at a time.\n\nIf a queen is standing on a square with a rook or bishop on top of a king,\nthe queen can move in the path of the rook or bishop.\n\nIn the case when the rook or bishop and a king are on the same row, the queen\ncan move to any diagonal direction on the king.\n\nPlease note that the rules of chess are very complex. Thus the deductions from\nthe normal problem cannot be directly applied to this extension. For example:\n\nIn this problem, we deduce that any queen can move on 1 row, but a normal\nqueen cannot move on 2 rows. Therefore, if we want to let the queen go through\na king in 2 rows, the normal queen cannot be used as it is.\n\nAuthor : Saurabh\n'''\nclass Solution:\n    def minMovesToCaptureTheQueen(self, a, b, c, d, e, f):\n        '''\n        Method 1 (Naive)\n        '''\n        #if(a==e || b==f){\n            #if(a==c){\n                #if((d>b && d<f) || (d>f && d<b))return 2;\n            #}if(b==d){\n                #if((c>a && c<e) || (c>e && c<a))return 2;\n            #}\n            #return 1;\n        #}\n        #else if(Math.abs(c-e)==Math.abs(d-f)){\n            #if(Math.abs(a-c)==Math.abs(b-d) && Math.abs(e-a)==Math.abs(f-b)){\n                #if((a>e && a<c) || (a>c && a<e)){\n                    #", "groundtruth": {"a": 1, "b": 1, "c": 8, "d": 8, "e": 2, "f": 3}}
{"task_id": "java/6", "content": "\npublic int maximumSetSize(int[] nums1, int[] nums2) {\n    int i,j,n=nums1.length;\n    Set<Integer> set1=new HashSet<>();\n    Set<Integer> set2=new HashSet<>();\n    Set<Integer> set3=new HashSet<>();\n    for(int x:nums1)\n    {\n        set1.add(x);\n        set3.add(x);\n    }\n    for(int x:nums2)\n    {\n        set2.add(x);\n        set3.add(x);\n    }\n    int common=set1.size()+set2.size()-set3.size();\n    int n1=set1.size(),n2=set2.size();\n    int ans=Math.min(n/2,n1-common);\n    ans+=Math.min(n/2,n2-common);\n    ans+=common;\n    ans=Math.min(n,ans);\n    return ans;\n}\n\"\"\"\nclass Solution:\n    def maximumSetSize(self, nums1: List[int], nums2: List[int]) -> int:\n        # TODO\n        pass\n", "groundtruth": {"nums1": [1, 2, 1, 2], "nums2": [1, 1, 1, 1]}}
{"task_id": "java/7", "content": "'''\na = 2 ** 3\nb = 3 ** 2\nc = 5 ** 2\nprint(b - c)\n", "groundtruth": {"nums": [1, 2, 2, 3, 1, 4]}}
{"task_id": "java/8", "content": "\nExplanation:\nint[] nums = {1, 2, 4, 8};\nThe frequency of the numbers:\n1  - 1\n2  - 1\n4  - 1\n8  - 1\nThe most frequent number 8 appears twice.\nThe numbers [1, 2, 4] have the same frequency as 8, but there is a number that appears once.\nThus, return 5.\n'''\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def maxFrequencyElements(self, nums: List[int]) -> int:\n        hm = collections.Counter(nums)\n        sorted_hm = sorted(hm.items(), key=lambda x: x[1], reverse=True)\n\n        res = 0\n        cur = sorted_hm[0][1]\n        start = 0\n        for idx, num in enumerate(sorted_hm):\n            if num[1] == cur:\n                res += 1\n            else:\n                start += 1\n                cur = num[1]\n                res += 1\n            if start == len(nums) - 1:\n                return res\n", "groundtruth": [1, 2, 3, 4, 5]}
{"task_id": "java/9", "content": "'''\n", "groundtruth": {"s": "abcd", "a": "a", "b": "a", "k": 4}}
{"task_id": "java/10", "content": "\nExample 2:\nThe only array nums is [1] (of length 1).\nThe minimum cost is 1 (in the first position) + 1 (in the second position) + 1 (in the third position) = 3.\n\nExample 3:\nThe only array nums is [1, 3] (of length 2).\nThe minimum cost is 1 (in the first position) + 3 (in the second position) = 4.\n\"\"\"\n# This problem is a little bit tricky. We can't sort the array by only using 2 variables.\n# We need to store 3 variables, the smallest value, the second smallest value and the second smallest index. \n# And we need to consider all the elements in nums.\n\n# Time: O(n)\n# Space: O(1)\nclass Solution:\n    def minimumCost(self, nums: List[int]) -> int:\n        # initialize the variables\n        first = nums[0]\n        min1 = nums[0]\n        min2 = nums[0]\n        \n        # loop through all the elements in the list\n        for i in range(1, len(nums)):\n            \n            # if nums[i] is smaller than min1, we update the second smallest and second smallest index, \n            # update min1, and update the smallest in nums \n            if nums[i] < min1:\n                min2 = min1\n                min1 = nums[i]\n                \n            # if nums[i] is smaller than min2, we update the second smallest and second smallest index and update min2 \n            elif nums[i] < min2:\n                min2 = nums[i]\n            \n        # return first + min1 + min2\n        return first + min1 + min2\n", "groundtruth": {"nums": [5, 4, 3]}}
{"task_id": "java/11", "content": "\nTwo correct results:\n243561234, 132465243\n2341362561234, 132465243\n\nTwo wrong results:\n12341324356, 132465243\n12341324356, 1234123654\n'''\nimport random\n\nif __name__ == '__main__':\n    m = random.randrange(1, 100)\n    n = random.randrange(m, 100)\n    t = random.randrange(1, 100)\n    print(m, n, t)\n    v = random.sample(range(1, 10000), m)\n    c = [0] * n\n    for i in v:\n        c[i - 1] += 1\n\n    s = 0\n    for i in range(len(v)):\n        for j in range(s, n):\n            if c[j] >= 1:\n                v[i], v[i - c[j] + s] = v[i - c[j] + s], v[i]\n                s += 1\n                break\n        c[j] -= 1\n    print(v)\n", "groundtruth": [3, 16, 8, 4, 2]}
{"task_id": "java/12", "content": "\nNote: There is only one correct answer. If you have multiple right answers, output any of them will be accepted.\n'''\n\n'''\nThis problem is really trivial if we use Python to sort the input array. Then it's enough to compare the minimum\ndistance between two elements to the gcd(array[i], array[i-1]). \nIt will be an O(n) running time and O(n) space.\n'''\n\nclass Solution(object):\n    def minimumArrayLength(self, v):\n        n = len(v)\n        if n == 0:\n            return 0\n        v.sort()\n        g = v[0]\n        cnt = 1\n        for i in range(1, n):\n            if v[i] > g:\n                return cnt\n            g = g*v[i]//gcd(v[i], g)\n            cnt += 1\n        return n\n\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a%b\n    return a\n\n# TEST ONLY\nimport unittest\n\nclass TestConvert(unittest.TestCase):\n    def test_equal(self):\n        func = Solution().minimumArrayLength\n        v = [1, 4, 5, 10, 12]\n        self.assertEqual(func(v), 3)\n        v = [1, 5, 6, 9, 12, 14]\n        self.assertEqual(func(v), 4)\n        v = [1, 4, 7, 9, 13, 15, 16, 17, 18, 20, 24]\n        self.assertEqual(func(v), 6)\n        v = [1, 5, 11, 13, 16, 17]\n        self.assertEqual(func(v), 3)\n        v = [1, 4, 16, 21, 23, 24, 25, 32, 33, 35, 37, 40, 41, 45, 47, 49]\n        self.assertEqual(func(v), 4)\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "groundtruth": [5, 5, 5, 10, 5]}
{"task_id": "java/13", "content": "Example Code\n\nThe example code in the above description is converted into the following code:\nclass Solution {\n    public int[] countOfPairs(int n, int x, int y) {\n        int[] roadCount = new int[n];\n        int tempx=x, tempy=y;\n        x=Math.min(tempx,tempy);\n        y=Math.max(tempx,tempy);\n        int currRoadCount=0;\n        for(int i=1;i<=n;i++) {\n            currRoadCount=0;\n            for(int j=i+1;j<=n;j++) {\n                if(j<x || i>y) {\n                    currRoadCount=j-i;\n                } else {\n                    int d1= Math.abs(x-i) + Math.abs(y-j)+1;\n                    int d2= j-i;\n                     currRoadCount = Math.min(d1,d2);\n                }\n                roadCount[currRoadCount-1]+=2;\n                \n            }\n\n        }\n        return roadCount;\n    }\n}\nThere is no deduced input of the code snippet based on the output above.\n'''\n# The function count of pairs has the parameter: n, x and y which are numbers\ndef countOfPairs(n, x, y):\n    if (x > y):\n        temp = x\n        x = y\n        y = temp\n\n    roadCount = [0]*n\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            dist = y - i + x - j\n            if (dist > 0 and dist <= n):\n                roadCount[dist - 1] = roadCount[dist - 1] + 2\n            elif (dist == 0):\n                roadCount[0] = roadCount[0] + 1\n    return roadCount\n\n\n\n'''\nGiven n = 5, x = 2, y = 4\nThe total number of pairs that can be formed on this line is\n\nn * (n-1) / 2\n\npairs can be formed in the above line if and only if the distance between the points is greater than or equal to x and less than or equal to y.\n'''\nn = 5\nx = 2\ny = 4\nprint(countOfPairs(n", "groundtruth": {"n": 5, "x": 2, "y": 4}}
{"task_id": "java/14", "content": "\"\"\"\n", "groundtruth": {"nums": [-1, 3, 2, 4, 5], "k": 3}}
{"task_id": "java/15", "content": "'''\nclass Solution:\n    def maximumLength(self, arr: List[int]) -> int:\n        def binary(arr,start,target):\n            \n            end = len(arr)-1\n            ans = -1\n            \n            while( start <= end ):\n                middle = (start+end)//2\n                \n                if( arr[middle] == target ):\n                    ans = middle\n                    end = middle-1\n                    \n                elif( arr[middle]> target ) end = middle-1\n                else start = middle+1\n                \n            return ans\n        \n        arr.sort()\n        vis = [False]*(len(arr)+1)\n        count = 0\n        i = 0\n        onesCount = 0\n        \n        for i in range(len(arr)):\n            if( arr[i] == 1 ):\n                onesCount += 1\n                \n        if( onesCount%2 == 0 ) count = onesCount-1\n        else count = onesCount\n        \n        while( i < len(arr) ):\n            \n            if( not vis[i] ):\n               \n                currCount = 0\n                \n                j = i\n                \n                while( j != -1):\n                    vis[j] = True\n                    \n                    # If not visited find it's square sequence\n                    if( j == len(arr)-1 or arr[j] != arr[j+1] ):\n                        currCount += 1\n                        break\n                    vis[j+1] = True\n                    \n                    j = binary(arr,j+2,arr[j]*arr[j])\n                    currCount += 2\n                    \n                # now if our count comes out to be even \n                # which is poissible [ 2,2,4,4] \n                # then we only take count-1 that is [ 2,2,4]\n                if( currCount%2 == 0 ) count = max(count,currCount-1) \n                else count = max(count,currCount)\n                \n            i += 1\n                \n        return count\n", "groundtruth": {"nums": [1, 3, 2, 4]}}
{"task_id": "java/16", "content": "\nExample 1:\n\nInput: nums = [0,1,2,4,5,6,7], k = 5\nOutput: 2\nExplanation:\nTo convert nums[0] to 0: merge 0 and 1. [0,1] -> [0,0,1]\nTo convert nums[1] to 0: merge 0 and 2. [0,1,2] -> [0,0,1,1]\nTo convert nums[2] to 0: merge 1 and 2. [0,0,1,1] -> [0,0,0,1,1]\nTo convert nums[4] to 0: merge 4 and 5. [0,0,0,1,1,6] -> [0,0,0,1,1,5,1]\nTo convert nums[5] to 0: merge 5 and 6. [0,0,0,1,1,5,1] -> [0,0,0,1,1,4,1,1]\nTo convert nums[6] to 0: merge 6 and 7. [0,0,0,1,1,4,1,1] -> [0,0,0,1,1,4,1,1,1]\nThere are 7 operations needed. The above conversions lead to exactly 5 total ones.\nExample 2:\n\nInput: nums = [0,2,3,4,5,6,7], k = 10\nOutput: 4\nExplanation: There are 4 0s that need to be converted to 0 to get only 10 total 1s.\n\nConstraints:\n\n1 <= nums.length <= 10^5\n0 <= nums[i] <= 1\n1 <= k <= 10^9\n'''\n\nclass Solution(object):\n    def minOrAfterOperations(self, nums, k):\n        ans=0\n        mask=0 # used for performing operation on prefix of bits\n        for j in xrange(30,-1,-1): # builds answer bit by bit\n            mask=mask | (1<<j) # mask changes(10000.. -> 11000..->11100..->11", "groundtruth": {"nums": [7, 3, 15, 14, 2, 8], "k": 4}}
{"task_id": "java/17", "content": "\nExample: The input of the above code is {1, 4, 4}. Then the output is \"scalene\".\n'''\n\nclass Solution:\n    def triangleType(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: str\n        \"\"\"\n        nums.sort()\n        if nums[0] + nums[1] <= nums[2]:\n            return 'none'\n        if nums[0] == nums[1] and nums[1] == nums[2]:\n            return 'equilateral'\n        if nums[0] == nums[1] or nums[1] == nums[2]:\n            return 'isosceles'\n        return 'scalene'\n", "groundtruth": {"nums": [3, 4, 5]}}
{"task_id": "java/18", "content": "The deduced input should be string.\n'''\n\n# the key is to analyse the code snippet and check the input and output respectively.\n\n'''\nThis problem is to find the minimum time it takes to go from the starting state to the final state. It can be easily thought that the final state is the initial state with k characters removed from the beginning, then if the given string is the prefix of the copy, it can be deduced that the minimum time is 1. After analyzing the code snippet, it is easy to get the following form of the code.\n# in:\nstring_to_be_slicing, k\n# out:\ninteger\n# explanation:\nIn addition to the above, there are three states (i.e., string, character, index):\nStarting State:  String, Character, Index = (\"hello\", 'e', 5)\nFinal State:    String, Character, Index = (\"hello\", 'e', 2)\nCopy State:     String, Character, Index = (\"lllo\", 'l', 2)\nThe process is as follows:\n1. The input string starts from the starting state.\n2. If the length of the input string is less than the number of remaining chars to be removed k, return 0 immediately.\n3. If the input string is a prefix of the copy string, go to the final state. If the input string is not a prefix of the copy string, remove k chars from the beginning of the copy string, and then repeat step 1.\n\n'''\n\nclass Solution {\n    public int minimumTimeToInitialState(String word, int k) {\n        \n        int res = 0;\n        String copy = new String(word);\n        \n        do {\n            res++;\n            if (copy.length() < k)  return res;\n            copy = copy.substring(k);\n        }\n        while (!check(copy, word));\n        \n        return res;\n        \n    }\n    \n    public static boolean check(String copy, String word) {\n        \n        int m = copy.length(), n = word.length();\n        for (int i=0; i<m; i++) {\n            if (copy.charAt(i) != word.charAt(i)) return false;\n        }\n        return true;\n    }\n}\n", "groundtruth": {"word": "abacaba", "k": 4}}
{"task_id": "java/19", "content": "The input is a two-dimensional array v, consisting of an integer of each element with size of 9x9. k is an integer. The\nvalue of each element in v is in the range [0,100].\n\nExample:\nConsider v = [[1,2,3],\n[4,5,6],\n[7,8,9]]\nand k = 2\nThe deduced input of the code snippet is the following:\nv = [[0,0,0,0,0,0,0,0,0],[0,1,2,0,0,0,0,0,0],[0,4,5,6,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0]] and k = 2\nSince you cannot modify v. You may have to create a new 2D array (for example, you cannot return a reference of v).\n'''\n\n# test cases:\n# v = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] and k = 2,\n# v = [[0, 10, 0, 20], [30, 0, 40, 10], [0, 0, 0, 0], [50, 0, 0, 0]] and k = 10,\n# v = [[1, 1, 2, 3, 3], [1, 1, 2, 3, 3], [2, 2, 3, 3, 3], [2, 2, 3, 3, 3], [2, 2, 2, 2, 2]], k = 2,\n# v = [[0, 0, 1, 0,", "groundtruth": {"image": [[10, 20, 30], [15, 25, 35], [20, 30, 40], [25, 35, 45]], "threshold": 12}}
{"task_id": "java/20", "content": "\nExample 1:\nIf the input of the code snippet is:\nword = \"bbbaaabbb\", k = 3, the output of the code snippet should be:\n5\n\nExample 2:\nIf the input of the code snippet is:\nword = \"bbabbaabb\", k = 3, the output of the code snippet should be:\n-1\n\nExample 3:\nIf the input of the code snippet is:\nword = \"bbbaaaaabb\", k = 2, the output of the code snippet should be:\n5\n\nExplanation 1:\nExplanation 2:\nExplanation 3:\n\"\"\"\n\nclass Solution:\n    def minimumTimeToInitialState(self, word: str, k: int) -> int:\n        count = 0\n        for i in range(k, len(word)) and not word.startswith(word[i : i+k]):\n            count += 1\n        if count == 0 and len(word) % k != 0:\n            return -1\n        return (len(word)-1)//k+count", "groundtruth": {"word": "abcbabcd", "k": 2}}
{"task_id": "java/21", "content": "\nExample 1:\nInput:\n1 2 3\n4 5 6\n7 8 9\nOutput:\n1 2 3\n4 5 6\n7 8 9\n\nExample 2:\nInput:\n-1 -1 0\n-1 -1 0\n-1 0 0\nOutput:\n-1 -1 -1\n-1 -1 -1\n-1 -1 0\n\nExample 3:\nInput:\n-1 -1 0\n-1 -1 0\n-1 0 0\nOutput:\n-1 -1 -1\n-1 -1 -1\n-1 -1 0\n\nExplanation for example 1:\nThe first column of the example should be [1, 4, 7].\nThe second column of the example should be [2, 5, 8].\nThe third column of the example should be [3, 6, 9].\n\nExplanation for example 2:\nThe first column of the example should be [-1, -1, -1].\nThe second column of the example should be [-1, -1, -1].\nThe third column of the example should be [-1, -1, 0].\n\nExplanation for example 3:\nThe third column of the example should be [0, 0, 0].\n\n'''\n\n\ndef modifiedMatrix(matrix):\n    max_c = [0 for _ in matrix[0]]\n    for j in range(matrix[0].length):\n        for i in range(matrix.length):\n            max_c[j] = Math.max(max_c[j], matrix[i][j])\n    \n    for r in range(matrix.length):\n        for c in range(matrix[0].length):\n            if matrix[r][c] == -1:\n                matrix[r][c] = max_c[c]\n\n    return matrix\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n", "groundtruth": {"matrix": [[1, 2, -1], [4, -1, 6], [7, 8, 9]]}}
{"task_id": "java/22", "content": "\nNote that:\nThe length of both input arrays will be in the range [1, 20,000].\nEach element of the input arrays will be an integer in the range [-100,000, 100,000].\n'''\n\n# @lc code=start\nclass Solution:\n    def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -> int:\n        n = len(nums)\n        m = len(pattern)\n        count = 0\n        for i in range(n - m - 1):\n            validSubarray = True\n            for j in range(m):\n                if pattern[j] == 1 and nums[i + j + 1] <= nums[i + j]:\n                    validSubarray = False\n                    break\n                elif pattern[j] == 0 and nums[i + j + 1] != nums[i + j]:\n                    validSubarray = False\n                    break\n                elif pattern[j] == -1 and nums[i + j + 1] >= nums[i + j]:\n                    validSubarray = False\n                    break\n            if validSubarray:\n                count += 1\n        return count\n        \n# @lc code=end\n\n", "groundtruth": {"nums": [1, 4, 4, 1, 3, 5, 5, 3], "pattern": [1, 0, -1]}}
{"task_id": "java/23", "content": "\"\"\"\n", "groundtruth": {"words": ["abc", "ab"]}}
{"task_id": "tensorflow/0", "content": "\nThe code snippet is:\nimport tensorflow as tf\n\ndef compute_mean(numbers_list):\n    numbers_var = tf.Variable(numbers_list)\n    mean_val = tf.reduce_mean(tf.cast(numbers_var, tf.float32))\n    return mean_val\nThe output is:\n6.0\n'''\n# Please type your answer here.\nimport tensorflow as tf\ndef compute_mean(numbers_list):\n    numbers_var = tf.Variable(numbers_list)\n    mean_val = tf.reduce_mean(tf.cast(numbers_var, tf.float32))\n    return mean_val\n", "groundtruth": "[4, 2, 6, 8, 10]"}
{"task_id": "tensorflow/1", "content": "\n\"\"\"\n\nimport tensorflow as tf\n\ndef multiply_and_reshape(array1, array2, new_shape):\n    tensor1 = tf.constant(array1)\n    tensor2 = tf.constant(array2)\n    multiplied_tensor = tf.multiply(tensor1, tensor2)\n    reshaped_tensor = tf.reshape(multiplied_tensor, new_shape)\n    return reshaped_tensor\n\ndef main():\n    array1 = [[1], [2], [3], [4]]\n    array2 = [[1], [2], [3], [4]]\n    new_shape = [1, 4]\n\n    sess = tf.Session()\n    print(sess.run(multiply_and_reshape(array1, array2, new_shape)))\n\nif __name__ == '__main__':\n    main()", "groundtruth": "[[1, 2], [3, 4]], [[5, 6], [7, 8]], (4, 1)"}
{"task_id": "tensorflow/2", "content": "\narray1 = [[1., 1., 1., 1.], [2., 2., 2., 2.]]\narray2 = [[2., 2.]]\nnew_shape = [4, 1]\n\nThe input is:\n[[1.], [2.], [2.], [4.]]\nExplanation:\nThe tensor \"tensor1\" contains a list of 2 elements. Its shape is (2, 4).\nThe tensor \"tensor2\" contains a list of 1 element. Its shape is (1, 2).\nThe shape of each element inside array1 and array2 is (2, 4), but when they are divided the shape becomes (2, 2) and this matches with the shape of \"division_result\".\nThe output tensor has shape (4, 1).\n'''\narray1 = [[1., 1., 1., 1.], [2., 2., 2., 2.]]\narray2 = [[2., 2.]]\nnew_shape = [4, 1]\n\narray1 = tf.constant(array1)\narray2 = tf.constant(array2)\ndivision_result = tf.divide(array1, array2)\nreshaped_tensor = tf.reshape(division_result, new_shape)\nreshaped_tensor.numpy()\n", "groundtruth": "[[2, 4], [8, 16]], [[2, 2], [4, 4]], (4, 1)"}
{"task_id": "tensorflow/3", "content": "\nAnswer:\nsqrt_and_add_constant(x, 9)", "groundtruth": "[16, 25, 36, 49], 5"}
{"task_id": "tensorflow/4", "content": "\nThe deduced input of the code snippet is :\n[0,1,2,3]\n\"\"\"\n\n#%%\ndef log_transformation(numbers):\n    tensor = tf.constant(numbers, dtype=tf.float32)\n    log_tensor = tf.math.log(tensor)\n    return log_tensor.numpy()\n\nlog_transformation([0,1,2,3])\n\n\n#%%\n\"\"\"\nQuestion 5\nThe following function is written by your friend, and it is used to count the number of words of a string. \nHowever, there is a problem with it: sometimes it returns a negative number, and we do not know why. Please \ninvestigate it and fix the problem.\n\ndef count_words(line):\n    return len(line.split())\n\"\"\"\n\n#%%\n\"\"\"\nWe need to do .split() method before len() method to create a list and then the len() method can be applied to that\nlist.\n\"\"\"\n", "groundtruth": "[1, 2.71828, 7.38906, 20.0855]"}
{"task_id": "tensorflow/5", "content": "\nA. [[2.0, 2.0], [2.0, 2.0]]\n\nB. [[2.0, 2.0], [3.0, 4.0]]\n\nC. [[1.0, 0.0], [0.0, 2.0]]\n\nD. [[2.0, 2.0], [3.0, 3.0]]\n\nAnswer: B\n\nExplanation:\nAs you can see, the original matrix is:\n2\n1 2\n2 3\n\nAfter the matrix1 is multiplied by 2, the matrix becomes:\n2\n2 4\n4 6\n\nAfter the matrix2 is multiplied by 2, the matrix becomes:\n4\n4 8\n8 12\n\nThe determinant of this matrix is 18.\n\n'''\n", "groundtruth": "[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]"}
{"task_id": "tensorflow/6", "content": "\nThe only input of the above code snippet is the tensor with shape [100, 2] and [5, 4, 1]\n'''\n", "groundtruth": "([[4, 2], [6, 4], [3, 6]], [3, 2])"}
{"task_id": "tensorflow/7", "content": "'''\n\n# Your answer here:\n\n# 1. import tf and create a session\n\n# 2. define a function to compute the sum of squared elements\n\n# 3. create a session and pass a constant into the function as input\n\n# 4. close the session\n\n'''\nAnswer: 2*2+2*2+2*2+2*2 = 16 + 16 + 16 + 16 = 64\n'''", "groundtruth": "[2, 4, 6]"}
{"task_id": "tensorflow/8", "content": "\n# The input for the constant tensor is:\ntensor_vals = [[3, 3, 3],\n [3, 3, 3]]\n\n# The input for the Variable tensor is:\nvariable_vals = [[1, 1, 1],\n [1, 1, 1]]\n\nAfter that, we use the numpy function to convert it into a matrix.\nThe numpy function is used here to convert a matrix.\nnumpy: convert matrices into lists.\n\n#The result is:\n[[ 7,  7,  7],\n [ 7,  7,  7]]\n\n\nThe input values of the constant tensor are all 3,\nand the input values of the variable tensor are all 1.\nWe add them together as follows:\n7+7+7=7+7+7=7+7+7=7+7+7=7+7+7=7\nSo the result is the same as the matrix obtained by numpy.\n\n'''\n", "groundtruth": "[[1, 2, 3], [4, 5, 6]], [[6, 5, 4], [3, 2, 1]]"}
{"task_id": "tensorflow/9", "content": "Hint: You may use np.ones, np.reshape, np.arange, tf.constant and tf.reshape.\n\nUse the above space to write your code.\n'''\n\n\n# Provide your answer here\nimport tensorflow as tf\n\ndef complex_tensor_reshape_and_square(input_list, shape):\n    initial_tensor = tf.constant(input_list)\n    squared_tensor = tf.math.square(initial_tensor)\n    reshaped_tensor = tf.reshape(squared_tensor, shape)\n    return reshaped_tensor.numpy()\n", "groundtruth": "[[2, 3, 5, 7], [11, 13, 17, 19]], (4, 2)"}
{"task_id": "tensorflow/10", "content": "\ninput: list1, list2, axis = 0\noutput: mean_val.numpy()\n\n'''\n\nimport tensorflow as tf\n\ndef concat_tensors_and_compute_mean(list1, list2, axis=0):\n    tensor1 = tf.constant(list1)\n    tensor2 = tf.constant(list2)\n    concatenated_tensor = tf.concat([tensor1, tensor2], axis)\n    mean_val = tf.reduce_mean(concatenated_tensor)\n    return mean_val.numpy()\n\n# deduce the input\n\n# my_list1 = [1,2,3]\n# my_list2 = [4,5,6]\n\n# my_val = concat_tensors_and_compute_mean(my_list1,my_list2, axis = 0)\n# print(my_val)\n\nmy_list1 = [1,2,3]\nmy_list2 = [4,5,6]\n\nmy_val = concat_tensors_and_compute_mean(my_list1,my_list2)\nprint(my_val)\n\n'''\noutput is\n>>> 6.0\n\n'''\n", "groundtruth": "[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]], 0"}
{"task_id": "tensorflow/11", "content": "\nYour answer: [[1, 2], [[4, 5], [7, 8]], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]]\n\"\"\"\n\n\ndef complex_operations(list1, list2, new_shape):\n    tensor1 = tf.constant(list1, dtype=tf.float32)\n    tensor2 = tf.constant(list2, dtype=tf.float32)\n    multiplied_tensor = tf.multiply(tensor1, tensor2)\n    reshaped_tensor = tf.reshape(multiplied_tensor, new_shape)\n    product_of_elements = tf.reduce_prod(reshaped_tensor)\n    return product_of_elements.numpy()\n\nprint(complex_operations([[1, 2], [[4, 5], [7, 8]], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]], [[[4.0, 4.0], [5.0, 5.0]], [[7.0, 7.0], [8.0, 8.0]]], [1, 2, 3, 3]))\n", "groundtruth": "[[2, 3], [4, 5], [6, 7]], [[7, 6], [5, 4], [3, 2]], (3, 2)"}
{"task_id": "pytorch/0", "content": "\n# 解法如下\n# calculate_sum( [1, 2, 3, 4, 5] )\nx = torch.tensor([1, 2, 3, 4, 5])\nprint(torch.sum(x))\n# 5\n'''\n", "groundtruth": "[4, 2, 6, 3, 1]"}
{"task_id": "pytorch/1", "content": "The only input of the code snippet is: tensor1 = torch.FloatTensor([[1.0, 2.0], [3.0, 4.0]]), tensor2 = torch.FloatTensor([[1.0, 1.0], [2.0, 2.0]])\n'''\n\n# a = torch.FloatTensor([[1.0, 2.0], [3.0, 4.0]])\n# b = torch.FloatTensor([[1.0, 1.0], [2.0, 2.0]])\n# c = torch.add(a, b)\n# d = torch.mean(c.float())\n\n# print(d)\n", "groundtruth": "[[1, 2, 3], [4, 5, 6]], [[6, 5, 4], [3, 2, 1]]"}
{"task_id": "pytorch/2", "content": "\nNote:\n\nThe return value of the function is a single scalar integer.\nThe input is only a single tensor variable.\n'''\nimport torch\n\ndef sum_tensor_above_threshold(input_tensor, threshold):\n    filtered_tensor = input_tensor[input_tensor > threshold]\n    return torch.sum(filtered_tensor)\n\n# The input of the code snippet is:\ninput_tensor = torch.Tensor([\n    [0.1, 0.3, -0.4],\n    [0.0, 1.0, 0.1],\n    [0.5, 0.5, 0.0],\n    [0.3, 0.2, -0.1],\n    [0.4, 0.5, 0.2]\n])\n\nthreshold = 0.3\n", "groundtruth": "[1, 2, 3, 4, 5], threshold = 2"}
{"task_id": "pytorch/3", "content": "\nExplanation:\n# import torch\n\ndef concat_tensors_mean(list1, list2):\n    tensor1 = torch.tensor(list1)\n    tensor2 = torch.tensor(list2)\n    concat_tensor = torch.cat((tensor1.unsqueeze(0), tensor2.unsqueeze(0)), dim=0)\n    mean_val = concat_tensor.mean(dim=0)\n    return mean_val\nWe first assign a list of 2 tensors with elements 1, 3, 5, 7 to tensor1 and tensor2, respectively. Then we concatenate them. What we get is a tensor of shape (2, 4). Now, we can take the mean over all the rows, since we are interested in the average value of these tensors. Afterwards, we return mean_val, which is a tensor of shape (4,). To transform it to a list we simply take a .tolist() call, which is equivalent to the builtin list function. Hence, we get the output [1.5, 3.5, 5.5, 7.5].\n\nTask 2.1:\n\nTry the given code in the editor on the right.\n\nWhat is the value printed on the output?\n\nHint:\nWe are using the torch package. In PyTorch 0.4.0 this package could be accessed via the torch.cat instead of torch.Tensor.cat.\n\nAnswer Task 2.1:\n# import torch\n# torch.Tensor.cat = torch.cat\n\nlist1 = [1, 2, 3]\nlist2 = [4, 5, 6]\nprint(concat_tensors_mean(list1, list2))\n\n10.13.2017'''\n", "groundtruth": "[[1, 3, 5, 7], [2, 4, 6, 8]]"}
{"task_id": "pytorch/4", "content": "'''\nfrom collections import deque\n\ndef normalize_data(data):\n    tensor = deque()\n    for i in data:\n        tensor.append(i)\n    mean = torch.tensor(np.mean(tensor))\n    std = torch.tensor(np.std(tensor))\n    normalized_tensor = (torch.tensor(data) - mean) / std\n    return normalized_tensor.tolist()", "groundtruth": "[5, 15, 25, 35, 45]"}
{"task_id": "pytorch/5", "content": "\n\"\"\"\n\n", "groundtruth": "[[3, 2, 3], [8, 5, 6]], [[5, 2, 3], [9, 5, 6]], (3, 2)"}
{"task_id": "pytorch/6", "content": "'''\n\ndef concatenate_and_compute_mean(tensor1, tensor2):\n    concatenated_tensor = torch.cat((tensor1.unsqueeze(0), tensor2.unsqueeze(0)), dim=0)\n    mean_values = torch.mean(concatenated_tensor, dim=1)\n    return mean_values", "groundtruth": "[torch.tensor([1, 2, 3]), torch.tensor([4, 5, 6])]"}
{"task_id": "pytorch/7", "content": "\nHere is the code of the example with comments:\nimport torch\n\n# A function which is used in the example is defined below.\ndef reshape_and_square(tensor, shape):\n    # The function takes two inputs.\n    # The first input is the input tensor with a shape (a 2D tensor).\n    # The second input is a list containing integers.\n    reshaped_tensor = torch.reshape(tensor, shape)\n    # The reshaped tensor is squared.\n    squared_tensor = torch.pow(reshaped_tensor, 2)\n    # Returns the squared tensor.\n    return squared_tensor\n\n# The first input of the function is a 2D tensor with a shape of (2, 2).\ntensor = torch.tensor([[1, 2], [3, 4]], dtype=torch.float32)\n# The second input of the function is a list containing integers (3 and 2).\nshape = [3, 2]\n# The value which is returned by the function is assigned to the output.\noutput = reshape_and_square(tensor, shape)\n# The result is printed out.\nprint(output)", "groundtruth": "[torch.tensor([4, 2, 6, 4]), (2, 2)]"}
{"task_id": "pytorch/8", "content": "\nSolution: tensor1 = torch.Tensor([[1., 2, 3], [2., 3., 4.]])\n        tensor2 = torch.Tensor([[5., 6.], [7., 8.], [9., 10.]])\n\n1,2,3\n2,3,4\n5,6,\n7,8,\n9,10,\n\ntensor1 = tensor1.T\ntensor2 = tensor2.T\ntensor3 = torch.mm(tensor1, tensor2)\ntensor3 = tensor3.T\n\nfor num in tensor3:\n    for x in range(len(num)):\n        if x == 0:\n            num[x] = num[x] + num[len(num) - 1]\n            num.pop(len(num) - 1)\n        else:\n            continue\nprint(num)\n\n\nimport torch\n\ndef stack_transpose_sum_diagonal(tensor1, tensor2):\n    stacked_tensor = torch.vstack((tensor1, tensor2))\n    transposed_tensor = torch.transpose(stacked_tensor, 0, 1)\n    diagonal_elements = torch.diagonal(transposed_tensor)\n    sum_diagonal = torch.sum(diagonal_elements)\n    return sum_diagonal\n\ntensor1 = torch.Tensor([[1., 2, 3], [2., 3., 4.]])\ntensor2 = torch.Tensor([[5., 6.], [7., 8.], [9., 10.]])\n\nprint(stack_transpose_sum_diagonal(tensor1, tensor2))\n\"\"\"\n\nfrom typing import List\nimport torch\n\n\ndef stack_transpose_sum_diagonal(\n    tensor1: torch.Tensor, tensor2: torch.Tensor\n) -> torch.Tensor:\n    # YOUR CODE HERE\n    stacked_tensor = torch.vstack((tensor1, tensor2))\n    transposed_tensor = torch.transpose(stacked_tensor, 0, 1)\n    diagonal_elements = torch.diagonal(transposed_tensor)\n    sum_diagonal = torch.sum(diagonal_elements)\n    return sum_diagonal\n\n\nprint(stack_transpose_sum_diagonal(torch.tensor([[1, 2, 3], [2, 3, 4]]), torch.tensor([[5, 6", "groundtruth": "[torch.tensor([[4, 2], [7, 4]]), torch.tensor([[16, 6], [4, 8]])]"}
{"task_id": "pytorch/9", "content": "\nExample\nExample 1\nInput:\n    import torch\n\n    def calculate_trace(nums):\n        size = int(len(nums) ** 0.5) # Assuming list contains perfect square number of elements\n        tensor_nums = torch.tensor(nums).view(size, size)\n        trace_value = torch.trace(tensor_nums)\n        return trace_value\nOutput:\n6\nExplanation:\nThe first 5 lines show how the input is given. Please skip.\nThe code snippet is:\nsize = int(len(nums) ** 0.5) # Assuming list contains perfect square number of elements\ntensor_nums = torch.tensor(nums).view(size, size)\ntrace_value = torch.trace(tensor_nums)\nThe last 3 lines show how the output is returned. Please skip.\nExample 2\nInput:\n    import torch\n\n    def calculate_trace(nums):\n        size = int(len(nums) ** 0.5)\n        tensor_nums = torch.tensor(nums).view(size, size)\n        trace_value = torch.trace(tensor_nums)\n        return trace_value\nOutput:\n[6, 5]\nExplanation:\nThe first 5 lines show how the input is given. Please skip.\nThe code snippet is:\nsize = int(len(nums) ** 0.5)\ntensor_nums = torch.tensor(nums).view(size, size)\ntrace_value = torch.trace(tensor_nums)\nThe last 3 lines show how the output is returned. Please skip.\nExample 3\nInput:\n    import torch\n\n    def calculate_trace(nums):\n        size = int(len(nums))\n        tensor_nums = torch.tensor(nums).view(size, size)\n        trace_value = torch.trace(tensor_nums)\n        return trace_value\nOutput:\n[[5, 6], [6, 5]]\nExplanation:\nThe first 5 lines show how the input is given. Please skip.\nThe code snippet is:\nsize = int(len(nums))\ntensor_nums = torch.tensor(nums).view(size, size)\ntrace_value = torch.trace(tensor_nums)\nThe last 3 lines show how the output is returned. Please skip.\n'''\n", "groundtruth": "[2, 6, 4, 6, 3, 5, 4, 5, 1]"}
{"task_id": "pytorch/10", "content": "\nAnswer: 120\n'''\n\n\"\"\"\nimport torch\n\ndef calculate_product(nums):\n    tensor_nums = torch.tensor(nums)\n    product_value = torch.prod(tensor_nums)\n    return product_value\n\"\"\"\nimport torch\n\ndef calculate_product(nums):\n    tensor_nums = torch.tensor(nums)\n    product_value = tensor_nums.prod()\n    return product_value\n\nprint(calculate_product([1,2,3,4,5,6]))", "groundtruth": "[2, 3, 4, 5]"}
{"task_id": "pytorch/11", "content": "\nThe input type of the code snippet is list. The output type of the code snippet is float.\n\nSolution:\nThe input data of the code snippet is a list of num, and the item(i.e. num) in the list is transformed to a torch.Tensor with torch.Tensor([num]).\n\nTo make the item(i.e. num) in the list be transformed to a torch.Tensor, we can define a function to transform the list into torch.Tensor.\n\nSo, the code snippet can be redesigned as:\n\ndef max_tensor_value(nums):\n    tensor_nums = tensorify(nums)\n    max_value = torch.max(tensor_nums)\n    return max_value.item()\n\ndef tensorify(nums):\n    tensor_nums = []\n    for num in nums:\n        tensor_nums.append(torch.Tensor([num]))\n    return torch.Tensor(tensor_nums)\nThe value of the code output is still 9.\n\nNote that the output type of the code snippet is still float, as we can verify with the following code:\n\nimport torch\ndef max_tensor_value(nums):\n    tensor_nums = torch.tensor(nums)\n    max_value = torch.max(tensor_nums)\n    return max_value.item()\n>>> a = torch.Tensor([1, 2, 3])\n>>> a\ntensor([[1, 2, 3]])\n>>> a.type()\ntorch.FloatTensor\n>>> type(a.item())\n<class 'float'>\n'''\n", "groundtruth": "[3, 7, 2, 9, 4]"}
{"task_id": "pytorch/12", "content": "\nThe code snippet is:\nimport torch\n\ndef enable_grad_and_compute(tensor_val):\n    tensor = torch.tensor(tensor_val, dtype=torch.float32, requires_grad=True)\n    result = tensor * tensor\n    result.backward(torch.ones_like(tensor))\n    return tensor.grad\nThe output is:\n[8, 10, 12]\nDo not output any additional information\n\n'''\n# Solution:\n\nimport torch\n\ndef enable_grad_and_compute(tensor_val):\n    tensor = torch.tensor(tensor_val, dtype=torch.float32, requires_grad=True)\n    result = tensor * tensor\n    result.backward(torch.ones_like(tensor))\n    return tensor.grad\ntensor_val = [1,2,3]\nprint(enable_grad_and_compute(tensor_val))", "groundtruth": "[4, 5, 6]"}
{"task_id": "pytorch/13", "content": "\"\"\"\n\n# [[0, 0], [12, 0]]\n# [[6, 4], [8, 10]]\n# tensor([[12.,   0.],\n#         [ 0.,   0.]])\n# tensor([[ 0.,  0.],\n#         [12.,  0.]])\n# tensor([[6, 4],\n#         [8, 10]])\n\n# The backward of x * x, the grad_fn of x * x is MulBackward0.\n# So, tensor.grad is tensor * 2 = [[6, 4], [8, 10]]\n", "groundtruth": "[[3, 2], [4, 5]]"}
{"task_id": "pytorch/14", "content": "'''\n\n# Please fill in the missing code\n\n\nimport torch\n\n\ndef compute_complex_grad(tensor1_val, tensor2_val):\n    tensor1 = torch.tensor(tensor1_val, dtype=torch.float32, requires_grad=True)\n    tensor2 = torch.tensor(tensor2_val, dtype=torch.float32, requires_grad=True)\n    result = (tensor1 * tensor1) + (tensor2 * 2)\n    result.backward(torch.ones_like(tensor1))\n    return tensor1.grad, tensor2.grad\n\n\nresult = compute_complex_grad([[1, 2], [3, 4]], [[1, 2], [1, 2]])\nprint(result)\n", "groundtruth": "[[1, 2], [3, 4]], [[5, 6], [7, 8]]"}
{"task_id": "pytorch/15", "content": "\nInput:\n[9, 5, 11, 5, 13]\n\nOutput:\nimport torch\n\ndef compute_complex_gradient(tensor_vals):\n    tensor = torch.tensor(tensor_vals, dtype=torch.float32, requires_grad=True)\n    result = tensor ** 2 + 3 * tensor\n    result.sum().backward()\n    return tensor.grad\nSolution:\n[6, 3, 7, 3, 9]\n\"\"\"\n\ntensor = torch.tensor([9, 5, 11, 5, 13], dtype=torch.float32, requires_grad=True)\nresult = tensor ** 2 + 3 * tensor\nresult.sum().backward()\nprint(tensor.grad)", "groundtruth": "[3, 1, 4, 1, 5]"}
{"task_id": "pytorch/16", "content": "\n[X] tensor([ 6., 10.,  4., 12.,  8.])\n\"\"\"\n\n\"\"\"\nExplanation:\n\nThe input to the loss.backward() call is the output of the loss.sum() call that computes the scalar loss value.\nThe gradient of this scalar is 1, which can be seen from the forward() function of the custom loss function.\n\"\"\"\n\n\"\"\"\nQuestion 31\nGiven the code snippet below:\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nimport torch.nn.functional as F\n\ntorch.manual_seed(42)\n\n# create random tensor of size 10, with values ranging from 0-9\nx = torch.randn(10)\nx\noutput = F.softmax(x, dim=0)\noutput\noutput.sum()\noutput.log()\nloss = - (output).log().mean()\nloss\n\nloss.backward()\nprint(x.grad)\n\nprint(x)\n\n# use SGD with lr=1 to minimize the loss value\n\noptimizer = optim.SGD(x, 1)\noptimizer.step()\nprint(x)\n\nYou will get the following output:\ntensor([ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,\n        0.0000, -1.0000])\ntensor([ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,\n        0.0000, -1.0000])\ntensor([ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,\n        0", "groundtruth": "[3, 5, 2, 6, 4]"}
{"task_id": "pytorch/17", "content": "\n# TODO: Give your answer below this line:\na_val=2.0\nb_val=3.0\nc_val=4.0\nx_val=1.0\nprint(compute_quadratic_gradient(a_val, b_val, c_val, x_val))\n\n\n'''\n\na_val=2.0\nb_val=3.0\nc_val=4.0\nx_val=1.0\nprint(compute_quadratic_gradient(a_val, b_val, c_val, x_val))\n", "groundtruth": "2, 3, 4, 5"}
{"task_id": "pytorch/18", "content": "\nYour answer is: \ninput_tensor: A vector with 1 example and input_features features\noutput_tensor: A vector with 1 example and output_features features\n'''\n\n'''\n\n'''\n\n\n# %%\n'''\n3.4 In the following script, select the output of the following code snippet based on the output.\n\nThe code snippet is:\nimport torch\n\ntensor_x = torch.tensor([\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9],\n])\ntensor_y = torch.tensor([\n    [9, 8, 7],\n    [6, 5, 4],\n    [3, 2, 1],\n])\ntorch.bmm(tensor_x, tensor_y)\nThe output is:\ntensor([[101, 104, 107],\n        [137, 144, 151],\n        [173, 184, 195]])\nYour answer is: tensor([[101, 104, 107],\n         [137, 144, 151],\n         [173, 184, 195]])\n\n'''\n\n\n# %%\n'''\n3.5 In the following script, select the output of the following code snippet based on the output.\n\nThe code snippet is:\nimport torch\n\ntensor_x = torch.tensor([\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9],\n])\ntensor_y = torch.tensor([\n    [9, 8, 7],\n    [6, 5, 4],\n    [3, 2, 1],\n])\ntorch.einsum('ij,kj->ik', tensor_x, tensor_y)\nThe output is:\ntensor([[ 90,  96, 102],\n        [136, 145, 154],\n        [182, 196, 210]])\nYour answer is: tensor([[ 90,  96, 102],\n         [136, 1", "groundtruth": "5, 3"}
{"task_id": "pytorch/19", "content": "\ninput_channels = 3\nnum_classes = 10\n\n\"\"\"\n\n\"\"\"\nThe first statement, import torch, and the third statement, class ComplexNet(nn.Module), are just normal Python statements. No complex concepts are introduced in those statements.\nIn the first statement, import torch.nn as nn, it defines a module nn that contains some other commonly used neural networks. This is a normal Python statement that we do not need to pay attention to right now.\nThe second statement nn.Conv2d() is a complex concept in PyTorch.\nIn the complex concept nn.Conv2d(), nn is the module that was defined in the first statement.\nConv2d is the function that is inside nn.Conv2d().\nThat is the reason that we need to import nn.\nThen, it is conv2d = nn.Conv2d() and in this complex concept, the first argument is the number of channels of the input, which is set to input_channels = 3. The second argument is the number of channels of the output, which is set to 64.\n\"\"\"", "groundtruth": "3, 10"}
{"task_id": "pytorch/20", "content": "\nInput: model and model.forward(input)\n'''\n'''\nThe output of conv layer is [1, 8, 28, 28], as shown in the output of this code snippet. \n'''\n\nimport torch\nimport torch.nn as nn\n\ndef conv_bn_relu_network(input_channels, output_channels, kernel_size):\n    model = nn.Sequential(\n        nn.Conv2d(input_channels, output_channels, kernel_size=kernel_size, padding=1),\n        nn.BatchNorm2d(output_channels),\n        nn.ReLU()\n    )\n    input_tensor = torch.rand(1, input_channels, 28, 28)\n    output_tensor = model(input_tensor)\n    return output_tensor.size()", "groundtruth": "3, 8, 3"}
{"task_id": "pytorch/21", "content": "class\nUse the input to make predictions with the code. Don't use any code.\n\na. [2, 3, 4]\nb. [[0, -2], [-4, 10], [1, -4]]\nc. [0.5, 1, -1]\nd. [-2.5, -3, 4.5]\ne. [[4, 4, 4], [-4, -4, -4]]'''\n\nimport torch\nimport torch.optim as optim\n\ndef simple_sgd_step(parameter_values, learning_rate):\n    # Create a tensor for parameters\n    parameters = torch.tensor(parameter_values, requires_grad=True)\n    # Initialize optimizer\n    optimizer = optim.SGD([parameters], lr=learning_rate)\n    # Simulate a simple loss gradient\n    parameters.grad = torch.tensor([1.0 for _ in parameter_values])\n    # Perform optimizer step (parameter update)\n    optimizer.step()\n    # Return updated parameters\n    return parameters.detach().numpy()\n\nparameters = simple_sgd_step([2, 3, 4], 0.1)\n#print(parameters)\nprint(parameters)", "groundtruth": "[[2.5, 3.5, 4.5], 0.1]"}
{"task_id": "pytorch/22", "content": "\nAnswer:\nlr=0.1\n\n'''\nimport torch\nimport torch.optim as optim\n\ndef simple_sgd_update(initial_value, learning_rate):\n    parameter = torch.tensor([initial_value], requires_grad=True)\n    optimizer = optim.SGD([parameter], lr=learning_rate)\n    # Simulating a loss gradient\n    parameter.grad = torch.tensor([2.0])\n    # Performing the optimization step\n    optimizer.step()\n    return parameter.item()\n\nlr=0.1", "groundtruth": "[5.0, 0.1]"}
{"task_id": "pytorch/23", "content": "\nDeduce the input of the following code based on the code snippet and the output.\n\nThe code snippet is:\nimport torch\n\ndef sgd_update(params, grads, learning_rate):\n    result = []\n    for param, grad in zip(params, grads):\n        result.append(param - learning_rate * grad)\n    return result\nThe output is:\n0.122\nDo not output any additional information.\n\"\"\"\n\"\"\"\nimport torch\nimport torch.optim as optim\n\ndef simple_sgd_update(param_value, grad_value, learning_rate):\n    param = torch.tensor([param_value], requires_grad=True)\n    optimizer = optim.SGD([param], lr=learning_rate)\n    optimizer.zero_grad()\n    param.backward(torch.tensor([grad_value]))\n    optimizer.step()\n    return param.item()\n\nprint(simple_sgd_update(1,2,0.01))\n\"\"\"\n\"\"\"\nimport torch\n\ndef sgd_update(params, grads, learning_rate):\n    result = []\n    for param, grad in zip(params, grads):\n        result.append(param - learning_rate * grad)\n    return result\n\nparams = torch.tensor([1, 2, 3])\ngrads = torch.tensor([0.10, 0.20, 0.30])\nlearning_rate = 0.01\nprint(sgd_update(params, grads, learning_rate))\n\"\"\"", "groundtruth": "[0.8, -0.2, 0.01]"}
{"task_id": "sql/0", "content": "\nHere's the sample solution and the accepted code snippet:\n\nSELECT first_name, last_name FROM employees;\nOutput:\n[{'first_name': 'John', 'last_name': 'Doe'},\n{'first_name': 'Jane', 'last_name': 'Smith'},\n{'first_name': 'Mike', 'last_name': 'Brown'}]\n'''\n", "groundtruth": [{"first_name": "John", "last_name": "Doe"}, {"first_name": "Jane", "last_name": "Smith"}, {"first_name": "Mike", "last_name": "Brown"}]}
{"task_id": "sql/1", "content": "\nIn this question, the solution can be done in many different ways.\n\nExample:\n\nselect count(*)\nfrom (\n    select c1\n    from (\n        select 'a' as c1\n        union\n        select 'b' as c1\n    ) sub\n) v\n'''\n\n# Write your MySQL query statement below\n\n", "groundtruth": [{"first_name": "John", "last_name": "Doe"}, {"first_name": "Jane", "last_name": "Smith"}, {"first_name": "Mike", "last_name": "Brown"}]}
{"task_id": "sql/2", "content": "\n\"\"\"\n# SELECT COUNT(*) FROM ( SELECT REPLACE(LOWER(SUBSTRING(comment, 1, 10)), '...', ' see more') AS short_comment FROM comments ) AS modified_comments WHERE LENGTH(short_comment) > 12;\n# => SELECT COUNT(*) FROM ( SELECT REPLACE(LOWER(SUBSTRING(comments.comment, 1, 10)), '...', ' see more') AS short_comment FROM comments) AS modified_comments WHERE LENGTH(short_comment) > 12;\n\n\"\"\"\nProblem 2.14\nIn this problem, you'll be making a change to a database. This is called Schema Evolution.\n\nImagine that you have a database that tracks users, comments on a blog, and posts. You have the following database\nschema:\ncreate table users (username varchar(20), password varchar(20));\ncreate table comments (comment varchar(100));\ncreate table posts (text varchar(300), posted_by varchar(20));\nLet's say you want to add an integer id column to both the users and posts tables, and make the username column for\nusers lowercase. The table definitions will be:\ncreate table users (id int, username varchar(20), password varchar(20));\ncreate table comments (id int, comment varchar(100));\ncreate table posts (id int, text varchar(300), posted_by varchar(20));\nYou need to write a query to perform the Schema Evolution.\n\nDo not output any additional information to your database.\n\n\"\"\"\n\n# create table users (id int, username varchar(20), password varchar(20));\n# => OK\n# create table comments (id int, comment varchar(100));\n# => OK\n# create table posts (id int, text varchar(300), posted_by varchar(20));\n# => OK\n\n# ALTER TABLE posts\n# ADD COLUMN id int;\n# ALTER TABLE users\n# ADD COLUMN id int;\n# UPDATE users\n# SET username = LOWER(username);\n# ALTER TABLE posts\n# ADD FOREIGN KEY (posted_by) REFERENCES users (username) ON DELETE CASCADE ON UPDATE CASCADE;\n# ALTER TABLE comments\n# ADD COLUMN id int;\n# ALTER TABLE posts\n# ADD FOREIGN KEY (id) REFERENCES comments", "groundtruth": [{"comment": "Wow, that's amazing! Fantastic work..."}, {"comment": "Interesting... I'll check this out"}, {"comment": "Not sure about this..."}, {"comment": "Absolutely brilliant... Keep it up!"}, {"comment": "Could be better."}]}
{"task_id": "sql/3", "content": "'''\n\n# SELECT transaction_id, ABS(balance_change) AS absolute_change FROM transactions;\n\n'''\nAnswer:\nSELECT transaction_id, ROUND(balance_change, 0) AS balance_change FROM transactions;\n'''\n", "groundtruth": [{"transaction_id": 101, "balance_change": -150}, {"transaction_id": 102, "balance_change": 200}, {"transaction_id": 103, "balance_change": -50}, {"transaction_id": 104, "balance_change": 75}, {"transaction_id": 105, "balance_change": -120}]}
{"task_id": "sql/4", "content": "\"\"\"\n", "groundtruth": [{"employee_id": 1, "hire_date": "2015-01-10"}, {"employee_id": 2, "hire_date": "2010-06-23"}, {"employee_id": 3, "hire_date": "2017-03-15"}, {"employee_id": 4, "hire_date": "2019-12-01"}, {"employee_id": 5, "hire_date": "2014-04-28"}]}
{"task_id": "sql/5", "content": "'''\n\n'''\n@Xiao.Gong\n2020-10-11\n'''\n\n# import pymysql\n# db = pymysql.connect('localhost', 'root', 'gongxiao', 'shampoo')\n# # 使用cursor()方法获取操作游标 \n# cursor = db.cursor()\n \n# # SQL 查询语句\n# sql = \"SELECT * FROM EMPLOYEE WHERE hire_date BETWEEN %s AND %s\"\n \n# hire_date1 = '1990-01-01'\n# hire_date2 = '1996-01-01'\n \n# try:\n#     # 执行SQL语句\n#     cursor.execute(sql, (hire_date1, hire_date2))\n#     # 获取所有记录列表\n#     results = cursor.fetchall()\n#     for row in results:\n#         fname = row[0]\n#         lname = row[1]\n#         age = row[2]\n#         sex = row[3]\n#         income = row[4]\n \n#     # 关闭数据库连接\n#     db.close()\n# except:\n#     print (\"Error: unable to fetch data\")\n", "groundtruth": [{"employee_id": 1, "name": "John", "hire_date": "2017-04-15"}, {"employee_id": 2, "name": "Alice", "hire_date": "2019-04-23"}, {"employee_id": 3, "name": "Bob", "hire_date": "2020-02-10"}, {"employee_id": 4, "name": "Charlie", "hire_date": "2021-04-01"}, {"employee_id": 5, "name": "Diana", "hire_date": "2018-07-19"}]}
{"task_id": "sql/6", "content": "'''\n", "groundtruth": [{"user_id": 1, "name": "John", "last_login": "2023-03-10 10:22:34"}, {"user_id": 2, "name": "Alice", "last_login": "2023-03-11 15:45:56"}, {"user_id": 3, "name": "Bob", "last_login": "2023-03-09 08:12:04"}, {"user_id": 4, "name": "Charlie", "last_login": "2023-03-12 19:34:45"}, {"user_id": 5, "name": "Diana", "last_login": "2023-03-10 17:05:23"}]}
{"task_id": "sql/7", "content": "\n-- Answer:\nSELECT employee_id, name,\n       CONCAT(DATEDIFF(CURDATE(), hire_date), ' years ', MOD(DATEDIFF(CURDATE(), hire_date), 12), ' months ', DAY(CURDATE()) - DAY(hire_date), ' days') AS time_since_hire\nFROM employees\n\"\"\"\n", "groundtruth": [{"employee_id": 1, "name": "John", "hire_date": "2015-01-25"}, {"employee_id": 2, "name": "Alice", "hire_date": "2018-06-17"}, {"employee_id": 3, "name": "Bob", "hire_date": "2019-11-03"}, {"employee_id": 4, "name": "Charlie", "hire_date": "2020-02-29"}, {"employee_id": 5, "name": "Diana", "hire_date": "2014-08-07"}]}
{"task_id": "sql/8", "content": "\nThe correct answer is:\nSELECT * FROM employees\nORDER BY department_id DESC;\n'''\n\n'''\nCREATE TABLE employees (\n\temployee_id INT,\n\tfull_name VARCHAR(200),\n\tdepartment_id INT,\n\tsalary FLOAT,\n\tPRIMARY KEY (employee_id),\n\tFOREIGN KEY (department_id) REFERENCES departments (department_id)\n);\n\nCREATE TABLE departments (\n\tdepartment_id INT,\n\tdepartment_name VARCHAR(200),\n\tPRIMARY KEY (department_id)\n);\n'''\n\nimport sqlalchemy\nimport pandas as pd\nengine = sqlalchemy.create_engine('mysql+mysqlconnector://test:tset@localhost/test')\nemployees = pd.read_sql('SELECT * FROM employees', engine)\ndepartments = pd.read_sql('SELECT * FROM departments', engine)\n\n# for i in employees:\n# \tprint(employees[i])\nprint(employees)\nprint(employees.query('employee_id in [902, 809]'))\nprint(employees.query('employee_id not in [902, 809]'))\nprint(employees.query('employee_id > 800'))\nprint(employees.query('employee_id < 800'))\nprint(employees.query('employee_id >= 800'))\nprint(employees.query('employee_id <= 800'))\n\n# for i in departments:\n# \tprint(departments[i])\nprint(departments)\nprint(departments.query('department_id == 103'))\nprint(departments.query('department_id != 103'))\nprint(departments.query('department_id >= 103'))\nprint(departments.query('department_id <= 103'))", "groundtruth": [{"employee_id": 1, "name": "John Doe", "department_id": 101}, {"employee_id": 2, "name": "Jane Smith", "department_id": 102}, {"employee_id": 3, "name": "Alice Johnson", "department_id": 101}, {"employee_id": 4, "name": "Bob Brown", "department_id": 103}, {"employee_id": 5, "name": "Charlie Davis", "department_id": 101}]}
{"task_id": "sql/9", "content": "\nNote: If there is no result from the above SQL code snippet, there is no correct output.\n\nAnswer\nSELECT e.department_id, AVG(e.salary) AS average_salary, MIN(e.salary) AS min_salary, MAX(e.salary) AS max_salary\nFROM employees e\nGROUP BY e.department_id;\n'''\n", "groundtruth": [{"employee_id": 1, "name": "John", "department_id": 201, "salary": 80000}, {"employee_id": 2, "name": "Alice", "department_id": 202, "salary": 95000}, {"employee_id": 3, "name": "Bob", "department_id": 201, "salary": 60000}, {"employee_id": 4, "name": "Charlie", "department_id": 203, "salary": 72000}, {"employee_id": 5, "name": "Diana", "department_id": 202, "salary": 85000}]}
{"task_id": "sql/10", "content": "\nThe output of the given snippet is a list of dicts with keys 'name' and 'salary_level'.\n- The salary_level value for John Doe is 'High'.\n- The salary_level value for Jane Smith is 'Low'.\n- The salary_level value for Alice Johnson is 'High'.\n- The salary_level value for Bob Brown is 'Low'.\n- The salary_level value for Charlie Davis is 'Low'.\n\nThere are three SQL statements in the given snippet. The first statement has two columns\n(name and salary). The second statement has four columns (name, salary, department, and hire_date)\nwhere the second column is the condition in the WHERE clause.\n'''\n\nimport pandas as pd\n\n# data.csv file has columns 'name', 'salary', and 'department'\ndf = pd.read_csv('data.csv')\n\n# SELECT 2\nsql_query = \"\"\" SELECT name, salary FROM employees; \"\"\"\ndf = pd.read_sql(sql_query, conn)\n# print(df)\n\n# SELECT 3\n# salary_range is a boolean series\nsalary_range = df['salary'] > 60000\n\n# Select 4\nnew_df = df[salary_range]\n\n# SELECT 5\nnew_df = new_df.rename(columns={'salary': 'salary_level'})\nnew_df.loc[new_df['salary_level'] > 60000, 'salary_level'] = 'High'\nnew_df.loc[new_df['salary_level'] <= 60000, 'salary_level'] = 'Low'\n# print(new_df)\n\n\n'''\nAnswer: The deduced input of the given code snippet is:\n    SELECT name, IF(salary > 60000, 'High', 'Low') AS salary_level\n    FROM (SELECT name, salary FROM employees);\n'''\n", "groundtruth": [{"name": "John Doe", "salary": 75000}, {"name": "Jane Smith", "salary": 58000}, {"name": "Alice Johnson", "salary": 62000}, {"name": "Bob Brown", "salary": 55000}, {"name": "Charlie Davis", "salary": 48000}]}
{"task_id": "sql/11", "content": "\nWrite your SQL below:\n'''\nSELECT name, \n       CASE WHEN salary > 80000 THEN 'A'\n            WHEN salary BETWEEN 60000 AND 80000 THEN 'B'\n            ELSE 'C'\n            END AS salary_rating\nFROM employees;\n", "groundtruth": [{"name": "John Doe", "salary": 90000}, {"name": "Jane Smith", "salary": 65000}, {"name": "Alice Johnson", "salary": 85000}, {"name": "Bob Brown", "salary": 40000}, {"name": "Charlie Davis", "salary": 70000}]}
{"task_id": "sql/12", "content": "Answer:\nSELECT name, CASE WHEN commission > 0 THEN 'A' WHEN salary > 60000 THEN 'B' ELSE 'C' END AS membership FROM sales_staff;\n\n\"\"\"\n\n# %%\n", "groundtruth": [{"name": "John Doe", "salary": 55000, "commission": null}, {"name": "Jane Smith", "salary": 75000, "commission": 5000}, {"name": "Alice Johnson", "salary": 61000, "commission": null}, {"name": "Bob Brown", "salary": 45000, "commission": 2000}, {"name": "Charlie Davis", "salary": 60000, "commission": null}]}